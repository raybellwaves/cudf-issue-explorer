{"assignees":[],"author":{"id":"MDQ6VXNlcjE5MDEwNTk=","is_bot":false,"login":"abellina","name":"Alessandro Bellina"},"body":"We found an issue late in 21.10 (https://github.com/NVIDIA/spark-rapids/issues/3736) with the AST driven inner join where given a smaller left side table our performance would drop significantly with AST, as opposed to using an unconditional join + a separate filter. This issue is to discuss whether cuDF could detect this and adjust how it handles such a join.\r\n\r\nIf the larger table is on the left, AST is at least ~1.3x faster than join + filter approach. If the smaller table is on the left, AST can be 10x slower than the join + filter approach. We can work around this for inner joins specifically, since we can swap in the plugin the sides fairly easily (https://github.com/NVIDIA/spark-rapids/issues/3832), but this is hacky and seems like it is something cuDF should be able to handle, especially for all the other types of joins where we can't just swap sides like this.\r\n\r\nThe reason for the swap of tables in Spark, is that there is logic to build left or build right, depending on the byte sizes of the inputs. The spark-rapids plugin will split into smaller chunks the left side (if building right), or the right side (if building left), streaming these chunks against the side of the join that wasn't split (aka the build side). In this case we went from a build-left regime which was good for the AST since the left side was not split, to a build-right regime when the left side started to get split.\r\n\r\nThe reason why these kernels are so sensitive to the left side, is because that's what is getting used to compute the grid size:\r\n```\r\n  detail::grid_1d config(left_table->num_rows(), DEFAULT_JOIN_BLOCK_SIZE);\r\n```\r\n\r\nAnd in our example (https://github.com/NVIDIA/spark-rapids/issues/3736) the left table could be hundreds of rows, where the right table could be 1M rows.","closed":false,"closedAt":null,"comments":[{"id":"IC_kwDOBWUGps44ZA_I","author":{"login":"vyasr"},"authorAssociation":"CONTRIBUTOR","body":"In early prototypes of the AST implementation there was logic in the kernels to automatically swap the left and right tables so that the kernel configuration would always run over the left table. I removed this because that code path was swapping the tables without making the necessary associated modifications to the expression (e.g. `operation(GREATER, 0, 1)` needs to be converted to `operation(GREATER, 1, 0)`), leading to incorrect results. It should definitely be possible to do this in a safe way, though, so I'll look into the best way to accomplish that.","createdAt":"2021-10-18T19:11:14Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[{"content":"HOORAY","users":{"totalCount":2}}],"url":"https://github.com/rapidsai/cudf/issues/9461#issuecomment-946081736","viewerDidAuthor":false},{"id":"IC_kwDOBWUGps44ZDsX","author":{"login":"abellina"},"authorAssociation":"CONTRIBUTOR","body":"@vyasr precisely, the hack we implemented builds the AST twice, so if this could be automatically done by cuDF that would be perfect","createdAt":"2021-10-18T19:25:20Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/9461#issuecomment-946092823","viewerDidAuthor":false},{"id":"IC_kwDOBWUGps44dDpu","author":{"login":"jrhemstad"},"authorAssociation":"CONTRIBUTOR","body":"@vyasr should we really be dabbling in changing the user provided expression? It seems to me like expression evaluation should be a garbage in, garbage out kind of interface. \r\n\r\nCan't we just change how we parallelize the operation? ","createdAt":"2021-10-19T22:05:43Z","includesCreatedEdit":true,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/9461#issuecomment-947141230","viewerDidAuthor":false},{"id":"IC_kwDOBWUGps44248b","author":{"login":"abellina"},"authorAssociation":"CONTRIBUTOR","body":"Confirmed that the patch by @vyasr (here https://github.com/rapidsai/cudf/pull/9523) handles the inner join case.","createdAt":"2021-10-28T14:39:59Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/9461#issuecomment-953913115","viewerDidAuthor":false},{"id":"IC_kwDOBWUGps46c2JG","author":{"login":"github-actions"},"authorAssociation":"NONE","body":"This issue has been labeled `inactive-30d` due to no recent activity in the past 30 days. Please close this issue if no further response or action is needed. Otherwise, please respond with a comment indicating any updates or changes to the original issue and/or confirm this issue still needs to be addressed. This issue will be labeled `inactive-90d` if there is no activity in the next 60 days.","createdAt":"2021-11-27T15:02:55Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/9461#issuecomment-980640326","viewerDidAuthor":false},{"id":"IC_kwDOBWUGps4-o_Qd","author":{"login":"github-actions"},"authorAssociation":"NONE","body":"This issue has been labeled `inactive-90d` due to no recent activity in the past 90 days. Please close this issue if no further response or action is needed. Otherwise, please respond with a comment indicating any updates or changes to the original issue and/or confirm this issue still needs to be addressed.","createdAt":"2022-02-25T15:05:04Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/9461#issuecomment-1050932253","viewerDidAuthor":false},{"id":"IC_kwDOBWUGps5Ow6mk","author":{"login":"GregoryKimball"},"authorAssociation":"CONTRIBUTOR","body":"@vyasr should we close this?","createdAt":"2022-11-21T04:19:12Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/9461#issuecomment-1321445796","viewerDidAuthor":false},{"id":"IC_kwDOBWUGps5OzqKL","author":{"login":"jlowe"},"authorAssociation":"MEMBER","body":"I don't think this has been solved for any case other than inner joins (which allows swapping the tables).","createdAt":"2022-11-21T14:43:27Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/9461#issuecomment-1322164875","viewerDidAuthor":false},{"id":"IC_kwDOBWUGps5PAOXj","author":{"login":"vyasr"},"authorAssociation":"CONTRIBUTOR","body":"@jlowe is correct, this has only been solved for inner joins. Solving it for other types of joins will be substantially more complicated and will likely require an entirely new algorithm, and the new algorithm will most likely have measurably larger overhead. Perhaps there is a generic solution that does not introduce any more work, but I was not able to come up with one at the time that this issue was originally raised, even if I allowed for modification of the expression IIRC.\r\n\r\nMost likely what we would need to do is some careful benchmarking of the current approach against a new approach for different data sizes to determine tradeoffs and perform a runtime dispatch to the appropriate code path depending on the size imbalance. That will also balloon compile time so it's something that we will have to consider very carefully.","createdAt":"2022-11-23T17:59:27Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/9461#issuecomment-1325458915","viewerDidAuthor":false},{"id":"IC_kwDOBWUGps5PAO8W","author":{"login":"vyasr"},"authorAssociation":"CONTRIBUTOR","body":"One possibly reasonable naive solution for might be to do a two pass approach that is an inner join followed by a left join with a suitable predicate to determine which rows had no matches in the inner join. That may still be sufficient to overcome the current performance bottlenecks in some cases without doubling the number of kernels or requiring the development of entirely new ones.","createdAt":"2022-11-23T18:01:38Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/9461#issuecomment-1325461270","viewerDidAuthor":false}],"createdAt":"2021-10-18T17:27:37Z","id":"I_kwDOBWUGps49W2En","labels":[{"id":"MDU6TGFiZWw1OTk2MjY1NTk=","name":"bug","description":"Something isn't working","color":"d73a4a"},{"id":"MDU6TGFiZWwxMTM5NzQwNjY2","name":"libcudf","description":"Affects libcudf (C++/CUDA) code.","color":"c5def5"},{"id":"MDU6TGFiZWwxMzIyMjUyNjE3","name":"Performance","description":"Performance related issue","color":"C2E0C6"},{"id":"MDU6TGFiZWwxNDA1MTQ2OTc1","name":"Spark","description":"Functionality that helps Spark RAPIDS","color":"7400ff"}],"milestone":{"number":21,"title":"Expression evaluation","description":"","dueOn":null},"number":9461,"projectCards":[{"project":{"name":"Bug Squashing"},"column":{"name":"Needs prioritizing"}}],"projectItems":[],"reactionGroups":[],"state":"OPEN","title":"[BUG] AST join slows down significantly with a small left table","updatedAt":"2022-11-23T18:01:38Z","url":"https://github.com/rapidsai/cudf/issues/9461"}

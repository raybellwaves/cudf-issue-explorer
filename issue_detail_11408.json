{"assignees":[],"author":{"id":"MDQ6VXNlcjM1MDYzMDg=","is_bot":false,"login":"hyperbolic2346","name":"Mike Wilson"},"body":"**What is your question?**\r\nShould [`byte_array_view`](https://github.com/rapidsai/cudf/blob/branch-22.08/cpp/src/io/statistics/byte_array_view.cuh) change to a different implementation method or even go away completely.\r\n\r\n### Motivation\r\nWhen reviewing the `byte_array_view` PR it was brought up in [review comments](https://github.com/rapidsai/cudf/pull/11322#discussion_r928012252) that things could be done differently and possibly better. This issue is an attempt to bring this design out in the light and get some discourse going so we can build it the best way possible. Jake was, rightfully, concerned about the cognitive overload of having another object type that has to be understood, no matter how minimal the type turns out to be.\r\n\r\n### Backstory and origin\r\nThe original thought was that it would be nice to leverage the existing templates in the statistics code to get elements and compute max/min just like everything else. This meant that `.element` on a column would be able to return a type that represents a `list<uint8>`. This is almost identical to a string column, so the thought was to have something analogous to `string_view` that could be used. This was quickly dismissed due to the issue of not having all list columns comprised of this thing and it felt like we were forcing something. All string columns are lists of chars, but not all list columns are lists of bytes.\r\n\r\n### Requirements\r\nThe requirements in the statistics code are the ability to get an element from a table, compare elements, and compose an element from a pointer and a length. The statistics code goes to great length to type-erase the statistics blobs so they can be easily consumed at a large scale on the GPU and the reconstructs them later. It also uses `thrust::min` and `cub::reduceBlock` to process them, so comparison operators are needed.\r\n\r\n### Slippery issues to understand\r\nWe can't use the same statistics types as strings because `string_view::max()` is actually not the same as a max byte or a max `byte_array_view`. The distinction is subtle, but important between all of them.\r\n\r\n- The max UTF8 string is actually just 5 bytes long and [defined inside the `string_view` header](https://github.com/rapidsai/cudf/blob/03f1c1c5c5fcf90bd594aabd41b6e15f54690777/cpp/include/cudf/strings/string_view.cuh#L75). No UTF8 string can have a higher value, so comparisons work even though it isn't an infinitely-long character string as one would initially think.\r\n- Maximum value for an unsigned byte is obviously 255, but this isn't the what is intended when one asks for the max byte array view. Instead, the goal is to know the \"biggest\" one. This includes the length and the internal bytes. `0xff, 0x05` is less than `0xff, 0x15` and `0xff` is less than `0x00, 0x00`.\r\n- Maximum `byte_array_view` is defined conceptually as an infinite array of 0xff. This isn't possible to statically define for comparison like the `string_view` class, so some [magic values](https://github.com/rapidsai/cudf/blob/03f1c1c5c5fcf90bd594aabd41b6e15f54690777/cpp/src/io/statistics/byte_array_view.cuh#L173) were used of a nullptr and max length. These then have to be [explicitly compared](https://github.com/rapidsai/cudf/blob/03f1c1c5c5fcf90bd594aabd41b6e15f54690777/cpp/src/io/statistics/byte_array_view.cuh#L101) later in the comparison function to achieve the proper results.\r\n\r\nLots of places required special handling for `byte_array_view` and potentially get worse with the different possible solutions. The goal of course is to make these areas as clean as possible, so I thought it would be good to point some of them out here.\r\n\r\n - [Here](https://github.com/rapidsai/cudf/blob/03f1c1c5c5fcf90bd594aabd41b6e15f54690777/cpp/src/io/statistics/column_statistics.cuh#L115) is where the code grabs the data from the column. There is conversion in here for types, which is used for things like duration and timestamps. Originally it was thought this could be a good spot to convert from a `list_view`, which can be returned from `.element` calls on a list column. This didn't end up being a great solution, but I can't remember the details.\r\n - min/max calculations and block reduce happens down in [typed_statistics_chunk](https://github.com/rapidsai/cudf/blob/03f1c1c5c5fcf90bd594aabd41b6e15f54690777/cpp/src/io/statistics/typed_statistics_chunk.cuh#L207). This code is responsible for figuring out min, max, null counts, and aggregations like sum. It has to pick up this new type and operate on it.\r\n - Actual data writing in parquet looks [something like this](https://github.com/rapidsai/cudf/blob/03f1c1c5c5fcf90bd594aabd41b6e15f54690777/cpp/src/io/parquet/page_enc.cu#L1094) where an element is grabbed and written into place.\r\n\r\n### Possible solutions\r\n1. Use `device_span` directly. This requires passing comparison functions to cub and thrust for the calculations, but is completely doable. This was [attempted](https://github.com/hyperbolic2346/cudf/tree/mwilson/test_byte_array_view_removal), potentially poorly, with not great looking results.\r\n2. Composition vs inheritance. This came up multiple times as to why it was built with composition, holding a `device_span` inside, vs inheriting from `device_span` either publicly or privately. There isn't a great answer here to argue against inheritance. I originally thought that this would be a very small subset of `device_span` and I didn't want to muddy the waters with all the accessors and iterators, but after further inspection, I don't see anything that I would want to remove from `device_span`, so this would be a viable path. It does still hold the issue of cognitive overload of yet another type someone encounters.\r\n3. Continues to live on as it is now.\r\n4. Your amazing idea that didn't come up in development or review.","closed":false,"closedAt":null,"comments":[{"id":"IC_kwDOBWUGps5HhsM0","author":{"login":"vuule"},"authorAssociation":"CONTRIBUTOR","body":"I got some ideas, but they depend on a few points I'm not sure about yet:\r\n\r\n1. Are comparison semantics of `byte_array_view` similar/equivalent to `string_view`?\r\n2. Is `byte_array_view` a `device_span`? I.e. would deriving from `device_span` follow [Liskov Substitution Principle](https://blog.knoldus.com/what-is-liskov-substitution-principle-lsp-with-real-world-examples/#:~:text=Simply%20put%2C%20the%20Liskov%20Substitution,the%20objects%20of%20our%20superclass.)?","createdAt":"2022-07-29T23:02:45Z","includesCreatedEdit":true,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/11408#issuecomment-1200014132","viewerDidAuthor":false},{"id":"IC_kwDOBWUGps5Hnk7U","author":{"login":"hyperbolic2346"},"authorAssociation":"CONTRIBUTOR","body":"1. Identical outside of max value. `string_view` has a nice and clean static for max value and the byte array has to indicate it with magic values.\r\n2. It can certainly be viewed as such. It is a `device_span` with helper comparison functions inside. It is a list of bytes, which is exactly a `device_span`.","createdAt":"2022-08-01T18:27:00Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/11408#issuecomment-1201557204","viewerDidAuthor":false},{"id":"IC_kwDOBWUGps5HoJx8","author":{"login":"vuule"},"authorAssociation":"CONTRIBUTOR","body":"Aiming to avoid code duplication:\r\n`ordered_device_span`: public device_span` + comparison impl\r\n\r\n`string_view` : derived from `ordered_device_span<char>` + min/max impl\r\n\r\n`byte_array_view` : derived from  `ordered_device_span<uint8_t>` + min/max impl\r\n\r\n~Probably requires CRTP for min/max without virtual functions.~ not required at all, never mind :)","createdAt":"2022-08-01T20:52:13Z","includesCreatedEdit":true,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/11408#issuecomment-1201708156","viewerDidAuthor":false},{"id":"IC_kwDOBWUGps5HoN94","author":{"login":"davidwendt"},"authorAssociation":"CONTRIBUTOR","body":"I'd rather keep `cudf::string_view` out of this discussion. It is intended to match up somewhat to `std::string_view` https://en.cppreference.com/w/cpp/string/basic_string_view\r\nAnd some version of it may migrate to libcu++ at some point. At the very least, the `cudf::string_view` in the future may _contain_ a `cuda::std::string_view` member.","createdAt":"2022-08-01T21:11:06Z","includesCreatedEdit":true,"isMinimized":false,"minimizedReason":"","reactionGroups":[{"content":"THUMBS_UP","users":{"totalCount":2}}],"url":"https://github.com/rapidsai/cudf/issues/11408#issuecomment-1201725304","viewerDidAuthor":false},{"id":"IC_kwDOBWUGps5Hosm_","author":{"login":"vuule"},"authorAssociation":"CONTRIBUTOR","body":"Didn't know about libcu++ potential involvement.\r\nIn that case, my vote is to publicly derive from `device_span` to remove duplicated data access members (FWIW). Much less exciting solution :D","createdAt":"2022-08-01T23:52:07Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/11408#issuecomment-1201850815","viewerDidAuthor":false},{"id":"IC_kwDOBWUGps5JhugN","author":{"login":"github-actions"},"authorAssociation":"NONE","body":"This issue has been labeled `inactive-30d` due to no recent activity in the past 30 days. Please close this issue if no further response or action is needed. Otherwise, please respond with a comment indicating any updates or changes to the original issue and/or confirm this issue still needs to be addressed. This issue will be labeled `inactive-90d` if there is no activity in the next 60 days.","createdAt":"2022-09-01T00:13:05Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/11408#issuecomment-1233577997","viewerDidAuthor":false}],"createdAt":"2022-07-29T21:19:39Z","id":"I_kwDOBWUGps5O1pXY","labels":[{"id":"MDU6TGFiZWw1OTk2MjY1NjQ=","name":"question","description":"Further information is requested","color":"D4C5F9"},{"id":"MDU6TGFiZWwxMTM5NzQwNjY2","name":"libcudf","description":"Affects libcudf (C++/CUDA) code.","color":"c5def5"},{"id":"MDU6TGFiZWwxMTg1MjQ0MTQy","name":"cuIO","description":"cuIO issue","color":"fef2c0"}],"milestone":{"number":22,"title":"Parquet continuous improvement","description":"","dueOn":null},"number":11408,"projectCards":[{"project":{"name":"Other Issues"},"column":{"name":"Needs prioritizing"}}],"projectItems":[],"reactionGroups":[],"state":"OPEN","title":"[QST] Should byte_array_view in parquet reader/writer change","updatedAt":"2024-02-23T17:59:19Z","url":"https://github.com/rapidsai/cudf/issues/11408"}

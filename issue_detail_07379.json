{"assignees":[],"author":{"id":"MDQ6VXNlcjM0NDEzMjE=","is_bot":false,"login":"revans2","name":"Robert (Bobby) Evans"},"body":"**Is your feature request related to a problem? Please describe.**\r\nSpark's sort is a stable sort.  Most of the time that does not mater much, but there are a few cases where it does make a difference in the output (some window functions in a single process).\r\n\r\n`cudf::merge` currently provides no way to ensure that if batch 1 came before batch 2 in read order that the output would be preserved.\r\n\r\n**Describe the solution you'd like**\r\nIt would be great in the case of ties in cudf::merge if the order of the rows could match the order of the tables passed in. If this is going to cause a performance difference with the existing merge then a separate API is fine too.\r\n\r\n**Describe alternatives you've considered**\r\nAdd in a separate row of longs with all of the data that is a sequence to get a total ordering of the data read in so I can then use it as the final key in the sort, but that adds a lot of extra memory for something that is a really rare use case.\r\n\r\n**Additional context**\r\nThis is not super critical, as I said it is for a few corner cases. But from looking at the code it looks like it is simple enough that I could do it. The underlying `trust::merge` says that it is stable for what we want in the docs. That just leaves the order in which the tables are merged. It looks like right now there is a priority queue used to try and reduce the amount of data transferred and merges done by merging the two smallest tables at a time. I think if we instead merged them in waves, we could still reduce the amount of intermediate data transferred and maintain stable ordering.  Not as clean as the existing code but the following pseudo code would probably do what we want.\r\n\r\n```\r\nqueue input(all the input tables)\r\nqueue output()\r\nwhile (input.size > 1) {\r\n  while (input.size > 1) {\r\n    left = input.pop\r\n    right = input.pop\r\n    output.add(merge(left, right))\r\n  }\r\n  if (input.size == 1) {\r\n    output.add(input.pop)\r\n  }\r\n  input = output\r\n  output.reset()\r\n}\r\nreturn input.pop\r\n```","closed":false,"closedAt":null,"comments":[{"id":"MDEyOklzc3VlQ29tbWVudDc3ODI0MDIxMQ==","author":{"login":"jrhemstad"},"authorAssociation":"CONTRIBUTOR","body":"I don't quite follow the psuedocode. Using a priority queue will break the original input ordering. It looks like you're just suggesting merging `(0,1)` then merginging that result with `2`, e.g., `(((0,1), 2), 3)),...`? Is that right?\r\n\r\nThat would work, but would defeat the optimization of always merging the smallest tables first (which makes a significant difference).\r\n\r\nIt should be possible to still maintain the original order and merge the smallest tables first, it will just be a bit complicated. E.g., if we have 5 tables A, B, C, D, E whose sizes are (100, 10, 50, 10, 100) then we could merge `B' = (B,D)`  (size is 20) then `B'' = (B', C)` (size is 70), then `A' = (A, B'')` (size is 170) and finally `Result = (A', E)` (size is 270).\r\n\r\nSo long as we always merge right to left, that should still result in the same order as if we did `((((A,B), C), D), E)`.  There's probably a clever algorithm to do this nicely. Maybe @codereport can think of it. ","createdAt":"2021-02-12T14:50:14Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/7379#issuecomment-778240211","viewerDidAuthor":false},{"id":"MDEyOklzc3VlQ29tbWVudDc3ODI1MjI3NA==","author":{"login":"jlowe"},"authorAssociation":"MEMBER","body":"> It should be possible to still maintain the original order and merge the smallest tables first\r\n\r\nI don't think that sort remains stable.  I'm assuming the final table ordering between tied sort keys needs to be A->E to match the order in which the tables were generated. No matter whether we merge (B,D) with C or C with (B,D), the stable ordering between B, C, and D has been violated.  (B,D) will be treated as a new input table, and there's no way to properly insert the C keys since we lost the ability to distinguish B from D once they merged. I think we'd have to manifest a discriminator column (e.g.: table ID) to be able to skip table ordering when finding a pair to merge yet maintain a stable sort.\r\n\r\nWithout a discriminator we could still be smart about merging smaller pairs first, but those pairs always have to be adjacent tables in the table ordering.","createdAt":"2021-02-12T15:11:24Z","includesCreatedEdit":true,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/7379#issuecomment-778252274","viewerDidAuthor":false},{"id":"MDEyOklzc3VlQ29tbWVudDc3ODMwMDUxMw==","author":{"login":"jrhemstad"},"authorAssociation":"CONTRIBUTOR","body":"> No matter whether we merge (B,D) with C or C with (B,D), the stable ordering between B, C, and D has been violated. (B,D) will be treated as a new input table, and there's no way to properly insert the C keys since we lost the ability to distinguish B from D once they merged.\r\n\r\nYeah, that's a good point. My idea won't work.\r\n\r\n> we could still be smart about merging smaller pairs first, but those pairs always have to be adjacent tables in the table ordering.\r\n\r\nYeah, this would work. It may not be as optimal as merging the exact smallest tables first, but it would at least be better than the naive left fold. \r\n\r\n","createdAt":"2021-02-12T16:34:01Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/7379#issuecomment-778300513","viewerDidAuthor":false},{"id":"MDEyOklzc3VlQ29tbWVudDc3OTk4MDA5OA==","author":{"login":"revans2"},"authorAssociation":"CONTRIBUTOR","body":"I do want to reiterate that this is for a minor corner case in Spark. We don't have a customer yet that is complaining about the corner case either. The priority should be fairly low until we do hit a customer complaint.","createdAt":"2021-02-16T17:08:03Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/7379#issuecomment-779980098","viewerDidAuthor":false},{"id":"MDEyOklzc3VlQ29tbWVudDc4MDIyMjkzOA==","author":{"login":"harrism"},"authorAssociation":"MEMBER","body":"Why not just provide a choice between fast and stable?","createdAt":"2021-02-17T01:07:58Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/7379#issuecomment-780222938","viewerDidAuthor":false},{"id":"MDEyOklzc3VlQ29tbWVudDgwMjQ1NTM1OQ==","author":{"login":"github-actions"},"authorAssociation":"NONE","body":"This issue has been labeled `inactive-30d` due to no recent activity in the past 30 days. Please close this issue if no further response or action is needed. Otherwise, please respond with a comment indicating any updates or changes to the original issue and/or confirm this issue still needs to be addressed. This issue will be labeled `inactive-90d` if there is no activity in the next 60 days.","createdAt":"2021-03-19T01:51:14Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/7379#issuecomment-802455359","viewerDidAuthor":false},{"id":"MDEyOklzc3VlQ29tbWVudDgwMjgyMjI5MQ==","author":{"login":"jlowe"},"authorAssociation":"MEMBER","body":"This is still desired but not high priority.","createdAt":"2021-03-19T13:11:24Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/7379#issuecomment-802822291","viewerDidAuthor":false},{"id":"MDEyOklzc3VlQ29tbWVudDgwMjg0MzY3Mg==","author":{"login":"jrhemstad"},"authorAssociation":"CONTRIBUTOR","body":"As @harrism mentioned, I think we can just have `merge` and `stable_merge` APIs to satisfy the different requirements. ","createdAt":"2021-03-19T13:44:46Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/7379#issuecomment-802843672","viewerDidAuthor":false},{"id":"MDEyOklzc3VlQ29tbWVudDgyMTk5NjgzNA==","author":{"login":"github-actions"},"authorAssociation":"NONE","body":"This issue has been labeled `inactive-30d` due to no recent activity in the past 30 days. Please close this issue if no further response or action is needed. Otherwise, please respond with a comment indicating any updates or changes to the original issue and/or confirm this issue still needs to be addressed. This issue will be labeled `inactive-90d` if there is no activity in the next 60 days.","createdAt":"2021-04-18T14:04:51Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/7379#issuecomment-821996834","viewerDidAuthor":false},{"id":"MDEyOklzc3VlQ29tbWVudDgyMjQ5MTA1NQ==","author":{"login":"jlowe"},"authorAssociation":"MEMBER","body":"Still desired.","createdAt":"2021-04-19T14:01:49Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/7379#issuecomment-822491055","viewerDidAuthor":false}],"createdAt":"2021-02-12T13:41:57Z","id":"MDU6SXNzdWU4MDcyNDU0MzQ=","labels":[{"id":"MDU6TGFiZWw1OTk2MjY1NjE=","name":"feature request","description":"New feature or request","color":"a2eeef"},{"id":"MDU6TGFiZWwxMDEzOTg3MzUy","name":"0 - Backlog","description":"In queue waiting for assignment","color":"d4c5f9"},{"id":"MDU6TGFiZWwxMTM5NzQwNjY2","name":"libcudf","description":"Affects libcudf (C++/CUDA) code.","color":"c5def5"},{"id":"MDU6TGFiZWwxNDA1MTQ2OTc1","name":"Spark","description":"Functionality that helps Spark RAPIDS","color":"7400ff"}],"milestone":null,"number":7379,"projectCards":[{"project":{"name":"Feature Planning"},"column":{"name":"Needs prioritizing"}}],"projectItems":[],"reactionGroups":[],"state":"OPEN","title":"[FEA] have cudf::merge or similar API be stable, with the order of the tables passed in","updatedAt":"2021-04-19T14:06:15Z","url":"https://github.com/rapidsai/cudf/issues/7379"}

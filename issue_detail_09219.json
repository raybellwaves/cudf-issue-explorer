{"assignees":[],"author":{"id":"MDQ6VXNlcjc0MTY5MzU=","is_bot":false,"login":"ttnghia","name":"Nghia Truong"},"body":"I observe that there are a lot of bugs related to the situations when an API directly accesses the child columns of a sliced column instead of calling to `get_sliced_child`. As such, the `slice` API is a kind of shallow slice, not a deep slice. Maybe shallow slice is more efficient as it can avoid unnecessary slicing of the children columns when we don't care, it has caused a lot of (potential) bugs that cost a lot of developer time.\r\n\r\nAn instance of such bugs is here: https://github.com/rapidsai/cudf/pull/9218. In the past, I have also dealt with many similar situations but I could catch them immediately through unit tests. If a developer forgets to write unit tests for sliced input, the bug may be there.\r\n\r\nI would like to rewrite `slice` into deep slicing, i.e., recursively calling to `slice` on all children columns of the column being sliced. This way, when we access its children column through the APIs `child_begin()`, `child_end`, or `child(idx)` we will have the expected results all the time. Although we have talked about this before and didn't do anything as deep slicing is expensive, I still decided to raise the issue again as it still causes bugs.\r\n\r\nAn alternative solution to this issue is to rename the existing `slice` API into `shallow_slice` then add another `slice` version that does recursively calling `shallow_slice` on the columns. So, a developer will only call `shallow_slice` if he/she knows exactly that just the shallow version is needed in the context. Otherwise, a more expensive `slice` version will produce the correct results in most situations.","closed":false,"closedAt":null,"comments":[{"id":"IC_kwDOBWUGps42vxCp","author":{"login":"jrhemstad"},"authorAssociation":"CONTRIBUTOR","body":"> I would like to rewrite slice into deep slicing, i.e., recursively calling to slice on all children columns of the column being sliced. This way, when we access its children column through the APIs child_begin(), child_end, or child(idx) we will have the expected results all the time. \r\n\r\nThis would break strings columns. And maybe lists? So this would only apply to structs, which would be pretty inconsistent behavior. ","createdAt":"2021-09-13T19:05:51Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/9219#issuecomment-918491305","viewerDidAuthor":false},{"id":"IC_kwDOBWUGps42w4bj","author":{"login":"ttnghia"},"authorAssociation":"CONTRIBUTOR","body":"Another related-similar issue is not just `child` and `sliced_child` but also `offsets`. When dealing with `lists_column_view`, I discovered a bug that is due to accessing `lists_column_view::offsets()` of a sliced lists column. The `offsets` API returns the original `offsets`, not the sliced `offsets`.\r\n\r\nI'm not sure if this is also the case for strings column.","createdAt":"2021-09-14T04:11:17Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/9219#issuecomment-918783715","viewerDidAuthor":false},{"id":"IC_kwDOBWUGps42yg1D","author":{"login":"jrhemstad"},"authorAssociation":"CONTRIBUTOR","body":"> The `offsets` API returns the original `offsets`, not the sliced `offsets`. I'm not sure if this is also the case for strings column.\r\n\r\nYes, it is. Otherwise it would require actually modifying device memory to update all of the values of the offset column to be relative to the offset of the parent. This is obviously expensive and not something we want to do except in cases where it is explicitly required. \r\n\r\n","createdAt":"2021-09-14T14:34:15Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/9219#issuecomment-919211331","viewerDidAuthor":false},{"id":"IC_kwDOBWUGps42yvfS","author":{"login":"ttnghia"},"authorAssociation":"CONTRIBUTOR","body":"I see. It seems that deep slicing is necessary to avoid bugs, but it is expensive thus we try to avoid.\r\n\r\nI have an idea: Apply *lazy evaluation* concept: we do deep slicing but do not initialize the `offset` value until we actually need it. Instead, when doing deep slicing that needs `memcpy` from the device, we just store the device memory addresses to be copied from. Something similar to this:\r\n```\r\nclass column_view {\r\n.....\r\nsize_type _offset = INVALID_OFFSET;\r\n\r\nsize_type offset() const {\r\n  if(_offset == INVALID_OFFSET) {\r\n    cudaMemcpy(.....);\r\n  }\r\n  return _offset;\r\n}\r\n\r\nvoid set_offset(void const* device_add) { ....}\r\n```\r\n\r\nOf course, actual implementation is more complex than this. But the idea above can:\r\n * Avoid expensive memcpy and device sync when deep slicing is not needed, and\r\n * Eliminate potential bugs due to accessing non-sliced children, as it is deep slicing by default\r\n\r\nNote that this is something similar to caching scalar value that we mentioned before.","createdAt":"2021-09-14T15:39:33Z","includesCreatedEdit":true,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/9219#issuecomment-919271378","viewerDidAuthor":false},{"id":"IC_kwDOBWUGps42zNlq","author":{"login":"davidwendt"},"authorAssociation":"CONTRIBUTOR","body":"Deep slicing is not always necessary. We could add a specific statement to the developer guide that child columns are not sliced.\r\n\r\nThis kind of coding error would ideally be caught by [an appropriate gtest](https://github.com/rapidsai/cudf/blob/branch-21.10/cpp/docs/TESTING.md#best-practices-what-should-we-test) or during a PR review.\r\n","createdAt":"2021-09-14T18:09:20Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/9219#issuecomment-919394666","viewerDidAuthor":false},{"id":"IC_kwDOBWUGps42zYPa","author":{"login":"jrhemstad"},"authorAssociation":"CONTRIBUTOR","body":"> I have an idea: Apply lazy evaluation concept: we do deep slicing but do not initialize the offset value until we actually need it. Instead, when doing deep slicing that needs memcpy from the device, we just store the device memory addresses to be copied from.\r\n\r\nUnfortunately its more complicated than that. When a strings/list column is sliced, the values of the offsets column remain unchanged. Meaning, the values of the offset column are still relative to the _un_sliced version of the parent.\r\n\r\nFor example, a strings column:\r\n\r\n```\r\nlogical: {\"a\", \"\", \"bc\"}\r\noffset: 0\r\nchars: {abc}\r\noffsets: {0, 1, 1, 3}\r\n```\r\n\r\nIf you were to slice off the last two elements of this strings column you'd have:\r\n```\r\nlogical: {\"\", \"bc\"}\r\noffset: 1\r\nchars: {abc}\r\noffsets: {0, 1, 1, 3}\r\n```\r\n\r\nThe values of the offsets column is still relative to the original unsliced column. \r\n\r\nSo it's not just a matter of changing the singular offset of the `chars` and `offsets` column, but you'd also need to change the _values_ of the `offsets` child. \r\n\r\n","createdAt":"2021-09-14T19:08:40Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/9219#issuecomment-919438298","viewerDidAuthor":false},{"id":"IC_kwDOBWUGps42zakX","author":{"login":"ttnghia"},"authorAssociation":"CONTRIBUTOR","body":"I see. This is really context-dependent :disappointed: ","createdAt":"2021-09-14T19:22:51Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/9219#issuecomment-919447831","viewerDidAuthor":false},{"id":"IC_kwDOBWUGps42zbbl","author":{"login":"jrhemstad"},"authorAssociation":"CONTRIBUTOR","body":"One idea would be to add a `chars_begin` and `offsets_begin` functions to `strings_column_view` that return a transform iterator that automatically applies the offset of the parent. \r\n\r\nI don't think that would solve many of the problems you highlighted above, but still seems like a useful thing that would alleviate similar kinds of problems. ","createdAt":"2021-09-14T19:28:38Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/9219#issuecomment-919451365","viewerDidAuthor":false},{"id":"IC_kwDOBWUGps45xqAx","author":{"login":"github-actions"},"authorAssociation":"NONE","body":"This issue has been labeled `inactive-30d` due to no recent activity in the past 30 days. Please close this issue if no further response or action is needed. Otherwise, please respond with a comment indicating any updates or changes to the original issue and/or confirm this issue still needs to be addressed. This issue will be labeled `inactive-90d` if there is no activity in the next 60 days.","createdAt":"2021-11-15T21:03:32Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/9219#issuecomment-969318449","viewerDidAuthor":false},{"id":"IC_kwDOBWUGps495X0y","author":{"login":"github-actions"},"authorAssociation":"NONE","body":"This issue has been labeled `inactive-90d` due to no recent activity in the past 90 days. Please close this issue if no further response or action is needed. Otherwise, please respond with a comment indicating any updates or changes to the original issue and/or confirm this issue still needs to be addressed.","createdAt":"2022-02-13T22:03:17Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/9219#issuecomment-1038449970","viewerDidAuthor":false}],"createdAt":"2021-09-11T13:07:19Z","id":"MDU6SXNzdWU5OTM4Mzc2MTE=","labels":[{"id":"MDU6TGFiZWw1OTk2MjY1NjE=","name":"feature request","description":"New feature or request","color":"a2eeef"},{"id":"MDU6TGFiZWwxMTM5NzQwNjY2","name":"libcudf","description":"Affects libcudf (C++/CUDA) code.","color":"c5def5"},{"id":"MDU6TGFiZWwyNTQ2NTIxMDI0","name":"improvement","description":"Improvement / enhancement to an existing function","color":"bfd4f2"}],"milestone":null,"number":9219,"projectCards":[{"project":{"name":"Feature Planning"},"column":{"name":"Needs prioritizing"}}],"projectItems":[],"reactionGroups":[],"state":"OPEN","title":"[FEA] Apply `sliced_child` when calling to `slice`","updatedAt":"2024-02-23T18:42:46Z","url":"https://github.com/rapidsai/cudf/issues/9219"}

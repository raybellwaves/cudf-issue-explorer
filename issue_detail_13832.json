{"assignees":[{"id":"MDQ6VXNlcjUzNzk2MDk5","login":"brandon-b-miller","name":""}],"author":{"id":"MDQ6VXNlcjUzNzk2MDk5","is_bot":false,"login":"brandon-b-miller","name":""},"body":"**Describe the bug**\r\nWhen performing an `idxmax` or `idxmin` reduction on a dataframe column during JIT groupby apply, pandas returns `NaN` as the index label corresponding to the answer where as we return the index of the start of the group. \r\n\r\n**Steps/Code to reproduce bug**\r\n```python\r\nimport pandas as pd\r\nimport cudf\r\ndf = pd.DataFrame({\r\n    'a': [1, 1, 1, 2, 2, 2],\r\n    'b': [float('nan')] * 6\r\n})\r\n\r\ngdf = cudf.from_pandas(df, nan_as_null=False)\r\n\r\nexpect = df.groupby('a').apply(lambda x: x['b'].idxmax())\r\ngot = gdf.groupby('a').apply(lambda x: x['b'].idxmax(), engine='jit')\r\n\r\nprint(expect)\r\nprint(got)\r\n\r\n```\r\n\r\n```\r\na\r\n1   NaN\r\n2   NaN\r\ndtype: float64\r\na\r\n1    0\r\n2    3\r\ndtype: int64\r\n```\r\n\r\n\r\n\r\n**Expected behavior**\r\nIdeally we'd match pandas.\r\n\r\n**Environment overview (please complete the following information)**\r\nBare Metal, 23.10\r\n\r\n**Additional context**\r\nOriginally came up [here](https://github.com/rapidsai/cudf/pull/11452#issuecomment-1403031678), and then again [here](https://github.com/rapidsai/cudf/pull/13820/files#r1284758449). This problem stems from the dtype of the answer being data dependent in pandas. In most cases, the `idx_{max,min}` functions return an `int64` if the index is of type `int64`, however this edge case of all `NaN` returns a `Nan` which is of float type. This poses a compatibility problem for the JIT engine as numba decides the types of all the variables in the input code up front, and currently an `idx_{max,min}` operation returns an `int64`. This leads to three options in my mind:\r\n\r\n1. Return some kind of \"sensible\" int (current state). This leads to edge cases where our results differ from pandas.\r\n2. Type `idxmax` and `idxmin` operations to return a float, e.g. cast the resulting integer to a float and return nan in the edge case, correctly. This trades a value mismatch for a dtype mismatch. \r\n3. Raise in the edge case. This would require some engineering, related to https://github.com/rapidsai/cudf/issues/8774.\r\n\r\n\r\n","closed":false,"closedAt":null,"comments":[{"id":"IC_kwDOBWUGps5jmhxp","author":{"login":"wence-"},"authorAssociation":"CONTRIBUTOR","body":"4. `idxmin/max` must be in `[0, 2**31)` (`cudf::size_type` is a 4 byte signed int). So if the return value is an unsigned type, you can use `(uint32_t)-1` to signal a NaN result, and postprocess. The kernel could return whether or not it needs post-processing if you want to avoid passing over the data many times if it is unnecessary.","createdAt":"2023-08-09T10:10:14Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/13832#issuecomment-1671044201","viewerDidAuthor":false}],"createdAt":"2023-08-08T14:55:52Z","id":"I_kwDOBWUGps5twsp2","labels":[{"id":"MDU6TGFiZWw1OTk2MjY1NTk=","name":"bug","description":"Something isn't working","color":"d73a4a"},{"id":"MDU6TGFiZWwxMDE2MzIwNzI3","name":"numba","description":"Numba issue","color":"9c2cdd"},{"id":"MDU6TGFiZWwxMTM5NzQxMjEz","name":"cuDF (Python)","description":"Affects Python cuDF API.","color":"1d76db"}],"milestone":null,"number":13832,"projectCards":[],"projectItems":[],"reactionGroups":[],"state":"OPEN","title":"[BUG] JIT Groupby Apply `idxmax`/`idxmin` reductions return incorrect values when the data is all NaN","updatedAt":"2023-08-09T10:10:15Z","url":"https://github.com/rapidsai/cudf/issues/13832"}

{"assignees":[],"author":{"id":"MDQ6VXNlcjE1MzgxNjU=","is_bot":false,"login":"vyasr","name":"Vyas Ramasubramani"},"body":"**Is your feature request related to a problem? Please describe.**\r\nCurrently users are responsible for keeping all subexpressions of an `expression` alive. In particular, `operation`s do not own their operands, which are stored as a `std::vector<std::reference_wrapper<expression const>> const`. This approach is cumbersome because it forces client code to keep track of all previously created expressions to avoid their premature destruction. \r\n\r\n**Describe the solution you'd like**\r\nInstead of storing a vector of references to its operands, an `operation` should instead store a vector of unique pointers to copies of the operands. While this change would create duplicate `expression`s, they are cheap to carry around, and this change would simplify the management of `expression` lifetimes in all client code.\r\n\r\n**Describe alternatives you've considered**\r\nWe could use `std::shared_ptr` instead of using `std::unique_ptr`, which would allow subexpression reuse. Reuse isn't that important here though because `expression`s are relatively small and only use host memory. The primary goal is to simplify the management of `expression` objects, which is simpler with `unique_ptr` than `shared_ptr`.\r\n\r\nWe could also retain the status quo, which is not unworkable, just more complex and less intuitive than necessary. The fact that higher-level clients built on top of libcudf likely to build different ownerships models into their wrappers of expression APIs indicates that the libcudf approach is not the friendliest API for programmatic expression construction.\r\n\r\n**Additional context**\r\nThis change would not change that a`literal` only stores a reference to the underlying `scalar`. Creating a `scalar` involves a device memory allocation, an expensive operation that we should not hide from a user. Additionally, it is reasonably straightforward for client code to wrap a literal in some owning container that handles scalar allocation if needed, whereas maintaining all subexpressions of potentially arbitrarily complex expressions is a significantly more onerous task.","closed":false,"closedAt":null,"comments":[{"id":"IC_kwDOBWUGps5CLPbk","author":{"login":"vyasr"},"authorAssociation":"CONTRIBUTOR","body":"@jlowe I believe that you were interested in something like this at one point as well. We had higher priorities and didn't consider addressing it at the time, but I think this would help simplify some of the JNI wrappers right?","createdAt":"2022-04-26T20:59:40Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/10744#issuecomment-1110243044","viewerDidAuthor":false},{"id":"IC_kwDOBWUGps5CLdQu","author":{"login":"jlowe"},"authorAssociation":"MEMBER","body":"> I believe that you were interested in something like this at one point as well.\r\n\r\nYes, it would simplify things a bit since the JNI code explicitly tracks all the subexpressions and deletes them when the parent expression is finally deleted.  The Java code does a full translation from a Java tree to a native tree in an explicit `compile()` step, so nothing in the Java layer should need to change.  It should only be a change in the JNI native code layer that explicitly tracks the AST sub-expressions.  Now that it's coded and working, not a high priority from my perspective. ðŸ˜„ ","createdAt":"2022-04-26T22:10:24Z","includesCreatedEdit":true,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/10744#issuecomment-1110299694","viewerDidAuthor":false},{"id":"IC_kwDOBWUGps5D5bxr","author":{"login":"github-actions"},"authorAssociation":"NONE","body":"This issue has been labeled `inactive-30d` due to no recent activity in the past 30 days. Please close this issue if no further response or action is needed. Otherwise, please respond with a comment indicating any updates or changes to the original issue and/or confirm this issue still needs to be addressed. This issue will be labeled `inactive-90d` if there is no activity in the next 60 days.","createdAt":"2022-05-26T23:03:08Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/10744#issuecomment-1139129451","viewerDidAuthor":false},{"id":"IC_kwDOBWUGps5LB_XO","author":{"login":"github-actions"},"authorAssociation":"NONE","body":"This issue has been labeled `inactive-90d` due to no recent activity in the past 90 days. Please close this issue if no further response or action is needed. Otherwise, please respond with a comment indicating any updates or changes to the original issue and/or confirm this issue still needs to be addressed.","createdAt":"2022-09-27T00:19:20Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/10744#issuecomment-1258812878","viewerDidAuthor":false}],"createdAt":"2022-04-26T20:58:28Z","id":"I_kwDOBWUGps5IgdvS","labels":[{"id":"MDU6TGFiZWwxMDEzOTg3MzUy","name":"0 - Backlog","description":"In queue waiting for assignment","color":"d4c5f9"},{"id":"MDU6TGFiZWwxMDEzOTg3OTIx","name":"proposal","description":"Change current process or code","color":"2a2c89"},{"id":"MDU6TGFiZWwxMTM5NzQwNjY2","name":"libcudf","description":"Affects libcudf (C++/CUDA) code.","color":"c5def5"}],"milestone":{"number":21,"title":"Expression evaluation","description":"","dueOn":null},"number":10744,"projectCards":[{"project":{"name":"Feature Planning"},"column":{"name":"Needs prioritizing"}}],"projectItems":[],"reactionGroups":[],"state":"OPEN","title":"[FEA] Make cudf::ast::operation own its subexpressions","updatedAt":"2024-02-23T17:59:24Z","url":"https://github.com/rapidsai/cudf/issues/10744"}

{"assignees":[{"id":"MDQ6VXNlcjExMjY5ODE=","login":"wence-","name":"Lawrence Mitchell"}],"author":{"id":"MDQ6VXNlcjExMjY5ODE=","is_bot":false,"login":"wence-","name":"Lawrence Mitchell"},"body":"This came up while reviewing #12704.\r\n\r\nQuoth the documentation:\r\n\r\n> Split a frame with split points in ``splits``. Returns a list of Frames of length `len(splits) + 1`.\r\n\r\nWhich is true, except if the input dataframe is empty:\r\n\r\n```python\r\nimport cudf\r\ndf = cudf.DataFrame({\"a\": []})\r\nprint(df._split([0])) # => []\r\n```\r\n\r\nThis makes writing generic code difficult, since we're expecting to get back a list of N+1 things to iterate over, but in this case we don't.\r\n\r\nSlicing empty dataframes works fine (and reproduces semantically what you \"expect\" from slicing empty python lists):\r\n\r\n```python\r\ndf[:0], df[0:] # => (Empty DataFrame, Empty DataFrame)\r\n```\r\n\r\n(Arguably slicing with an out of bounds index should raise an `IndexError`, but that ship has sailed.)\r\n\r\nWhat I would like:\r\n\r\n```python\r\nsplits = [...]\r\n\r\nassert df._split(splits) == [df[s:e] for s, e in zip([None] + splits, splits + [None])]\r\n```\r\n\r\n","closed":false,"closedAt":null,"comments":[],"createdAt":"2023-02-07T10:42:25Z","id":"I_kwDOBWUGps5d0r8G","labels":[{"id":"MDU6TGFiZWw1OTk2MjY1NTk=","name":"bug","description":"Something isn't working","color":"d73a4a"},{"id":"MDU6TGFiZWwxMDEzOTg3MzUy","name":"0 - Backlog","description":"In queue waiting for assignment","color":"d4c5f9"},{"id":"MDU6TGFiZWwxMTM5NzQxMjEz","name":"cuDF (Python)","description":"Affects Python cuDF API.","color":"1d76db"}],"milestone":null,"number":12717,"projectCards":[{"project":{"name":"Bug Squashing"},"column":{"name":"Needs prioritizing"}}],"projectItems":[],"reactionGroups":[],"state":"OPEN","title":"[BUG] `IndexedFrame._split` is inconsistent for empty dataframes","updatedAt":"2023-06-06T04:45:32Z","url":"https://github.com/rapidsai/cudf/issues/12717"}

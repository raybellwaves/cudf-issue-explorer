{"assignees":[],"author":{"id":"MDQ6VXNlcjEwNjQ3MDgy","is_bot":false,"login":"mroeschke","name":"Matthew Roeschke"},"body":"Curious if any numpy function that dispatches to `__array_function__` should work on `cudf.DataFrame`\r\n\r\n```\r\nIn [3]: import numpy as np\r\n\r\nIn [4]: np.shape(pd.DataFrame([1, 2]))\r\nOut[4]: (2, 1)\r\n\r\nIn [6]: np.shape(cudf.DataFrame([1, 2]))\r\n---------------------------------------------------------------------------\r\nTypeError                                 Traceback (most recent call last)\r\nCell In[6], line 1\r\n----> 1 np.shape(cudf.DataFrame([1, 2]))\r\n\r\nFile <__array_function__ internals>:180, in shape(*args, **kwargs)\r\n\r\nTypeError: no implementation found for 'numpy.shape' on types that implement __array_function__: [<class 'cudf.core.dataframe.DataFrame'>]\r\n```","closed":false,"closedAt":null,"comments":[{"id":"IC_kwDOBWUGps5ZGLMJ","author":{"login":"galipremsagar"},"authorAssociation":"CONTRIBUTOR","body":"We currently raise an error for our `DataFrame.__array__` implementation, should we be doing the same for `__array_function__` too? or give this an exception to have an implementation on our end?  cc: @shwina ","createdAt":"2023-04-03T18:32:45Z","includesCreatedEdit":true,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/13045#issuecomment-1494790921","viewerDidAuthor":false},{"id":"IC_kwDOBWUGps5ZNAeL","author":{"login":"mroeschke"},"authorAssociation":"CONTRIBUTOR","body":"A similar question too for `__array_ufunc__`\r\n\r\n```\r\nIn [3]: cudf.DataFrame(np.eye(2)) * np.eye(2)\r\n---------------------------------------------------------------------------\r\nTypeError                                 Traceback (most recent call last)\r\nCell In[3], line 1\r\n----> 1 cudf.DataFrame(np.eye(2)) * np.eye(2)\r\n\r\nTypeError: operand type(s) all returned NotImplemented from __array_ufunc__(<ufunc 'multiply'>, '__call__',      0    1\r\n0  1.0  0.0\r\n1  0.0  1.0, array([[1., 0.],\r\n       [0., 1.]])): 'DataFrame', 'ndarray'\r\n\r\nIn [4]: import pandas as pd\r\n\r\nIn [5]: pd.DataFrame(np.eye(2)) * np.eye(2)\r\nOut[5]: \r\n     0    1\r\n0  1.0  0.0\r\n1  0.0  1.0\r\n```","createdAt":"2023-04-04T20:43:58Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/13045#issuecomment-1496582027","viewerDidAuthor":false},{"id":"IC_kwDOBWUGps5Zc2yg","author":{"login":"vyasr"},"authorAssociation":"CONTRIBUTOR","body":"No, we should not raise by default. However, we probably want a smarter dispatch pattern here.\r\n\r\nThe problem with `__array__` is that it provides an implicit conversion pathway from device data to host data. That means that a cudf object could be passed to some other library that accesses this attribute and triggers an implicit conversion to host memory. That's an easy performance footgun to eliminate.\r\n\r\n`__array_ufunc__` and `__array_function__` are different since they are dispatch pathways for functions. If possible, we should support them. ufuncs are easier since they are [enumerated by numpy](https://numpy.org/doc/stable/reference/ufuncs.html#available-ufuncs). The set of functions supported by the [`__array_function__` protocol](https://numpy.org/doc/stable/reference/arrays.classes.html#numpy.class.__array_function__), on the other hand, is not. Ideally, our implementation is designed to try to run the function in a way that we know, and fail if no such way is found, and that is what we want.\r\n\r\nThe two errors above indicate to me that we may want to clean up our failure pathways, though. I'm not sure what errors look like for a given object that is supposed to support these protocols if they don't support a particular ufunc/array func, but we should endeavor to match that. The easiest way to test is probably to define a trivial array-like object with those attribute and see what the expected traceback is. Alternatively the specs for those protocols should indicate exactly what should be done. We may be returning `NotImplemented` somewhere that we should be doing something else, or accessing `__array_ufunc__` directly without the necessary error checking that numpy does internally when it accesses that attribute.","createdAt":"2023-04-08T00:14:42Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/13045#issuecomment-1500736672","viewerDidAuthor":false}],"createdAt":"2023-03-30T23:12:00Z","id":"I_kwDOBWUGps5iQTwd","labels":[{"id":"MDU6TGFiZWw1OTk2MjY1NjE=","name":"feature request","description":"New feature or request","color":"a2eeef"},{"id":"MDU6TGFiZWwxMDEzOTg3MzUy","name":"0 - Backlog","description":"In queue waiting for assignment","color":"d4c5f9"},{"id":"MDU6TGFiZWwxMTM5NzQxMjEz","name":"cuDF (Python)","description":"Affects Python cuDF API.","color":"1d76db"}],"milestone":null,"number":13045,"projectCards":[],"projectItems":[],"reactionGroups":[],"state":"OPEN","title":"[FEA] `np.shape` does not work on `cudf.DataFrame`","updatedAt":"2023-06-07T20:49:27Z","url":"https://github.com/rapidsai/cudf/issues/13045"}

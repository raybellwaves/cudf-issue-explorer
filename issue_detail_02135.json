{"assignees":[],"author":{"id":"MDQ6VXNlcjQ3OTAxOTkx","is_bot":false,"login":"chinmaychandak","name":"Chinmay Chandak"},"body":"For our use cases, it would be helpful if rolling window objects have more functionality.\r\n\r\nBasically, this would mean adding support for median, variance, standard deviation, quantile, and aggregate functions for rolling objects.\r\n\r\nAn example of support for aggregate() is below:\r\n```\r\nimport cudf\r\ndf = cudf.DataFrame({'x': np.arange(10)})\r\nprint(df.x.rolling(2).aggregate({'x':'max'}))\r\n```\r\n\r\n**EDIT**\r\nAs of 7/11/2022, the following methods exist: min, mean, max, std, var, sum, count, apply. What remains is to implement:\r\n- [ ] median (see also #6276)\r\n- [ ] quantile\r\n- [ ] aggregate","closed":false,"closedAt":null,"comments":[{"id":"MDEyOklzc3VlQ29tbWVudDUwNzY4NzAxNQ==","author":{"login":"javy-kong"},"authorAssociation":"NONE","body":"can we add the rolling apply here too? a side question, is there a way/example to do GPU rolling apply in the rapid? I don't see apply implemented in the cudf rolling yet. Thanks.","createdAt":"2019-07-02T13:53:14Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/2135#issuecomment-507687015","viewerDidAuthor":false},{"id":"MDEyOklzc3VlQ29tbWVudDUwNzY4OTExMA==","author":{"login":"kkraus14"},"authorAssociation":"COLLABORATOR","body":"@javy-kong there isn't quite yet, but we will work on it and add it in the future!","createdAt":"2019-07-02T13:58:08Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/2135#issuecomment-507689110","viewerDidAuthor":false},{"id":"MDEyOklzc3VlQ29tbWVudDUwNzY5ODMxNA==","author":{"login":"javy-kong"},"authorAssociation":"NONE","body":"@kkraus14 Thanks for the quick response! Any suggestions on what's currently the best way to achieve this function if cudf is not ready yet?","createdAt":"2019-07-02T14:19:28Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/2135#issuecomment-507698314","viewerDidAuthor":false},{"id":"MDEyOklzc3VlQ29tbWVudDUwODI5Mjk1MQ==","author":{"login":"kkraus14"},"authorAssociation":"COLLABORATOR","body":"@javy-kong There unfortunately won't be an easy way today. Ultimately you want the code to run vectorized on the GPU, so we need to be careful to prevent Python serial iteration accidentally.\r\n\r\n@randerzander @beckernick @ayushdg any ideas on workarounds here to do some UDFs?","createdAt":"2019-07-04T00:06:09Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/2135#issuecomment-508292951","viewerDidAuthor":false},{"id":"MDEyOklzc3VlQ29tbWVudDUxMDU5NDQwNQ==","author":{"login":"beckernick"},"authorAssociation":"MEMBER","body":"@javy-kong it wouldn't be clean (and would have potentially large memory implications), but you could possibly do something like:\r\n\r\n1. Manually shift columns using `shift` (window size - 1 shifts)\r\n2. Write a numba kernel that accepts the original and shifted columns as inputs, carefully handles indices across the columns (since they will be off by one for each shift window), conducts some set of operations, and writes the result to an output array","createdAt":"2019-07-11T18:09:57Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/2135#issuecomment-510594405","viewerDidAuthor":false}],"createdAt":"2019-06-27T17:30:18Z","id":"MDU6SXNzdWU0NjE2NTY3OTg=","labels":[{"id":"MDU6TGFiZWw1OTk2MjY1NjE=","name":"feature request","description":"New feature or request","color":"a2eeef"},{"id":"MDU6TGFiZWwxMTM5NzQwNjY2","name":"libcudf","description":"Affects libcudf (C++/CUDA) code.","color":"c5def5"},{"id":"MDU6TGFiZWwxMTM5NzQxMjEz","name":"cuDF (Python)","description":"Affects Python cuDF API.","color":"1d76db"}],"milestone":{"number":5,"title":"Pandas API Alignment and Coverage","description":"","dueOn":null},"number":2135,"projectCards":[{"project":{"name":"Feature Planning"},"column":{"name":"Needs prioritizing"}}],"projectItems":[],"reactionGroups":[],"state":"OPEN","title":"[FEA] Add more functionality to rolling objects","updatedAt":"2024-05-10T22:21:10Z","url":"https://github.com/rapidsai/cudf/issues/2135"}

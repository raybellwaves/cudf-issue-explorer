{"assignees":[],"author":{"id":"MDQ6VXNlcjE5MDEwNTk=","is_bot":false,"login":"abellina","name":"Alessandro Bellina"},"body":"While analyzing an nsys trace for a Spark job with deeply nested tables, we see an `explode` kernel call that is followed by a train of `null_count`, which end in `is_valid`. \r\n\r\nAfter we call `cudf::explode` we build up a table, and construct java `ColumnVector` objects. I think the construction of these objects is triggering it.\r\n\r\nThis task is to confirm that the columns with missing a null count are coming from the `explode` kernels. If they are coming from `explode`, it would be great if `explode` could compute null count as part of that kernel.\r\n\r\nIn this screenshot, it is the ~20ms at the end after `explode`:\r\n![Screenshot from 2022-10-14 11-21-24](https://user-images.githubusercontent.com/1901059/195894495-ee65f7e6-0387-4bd6-990b-185bcc11a659.png)\r\n","closed":false,"closedAt":null,"comments":[{"id":"IC_kwDOBWUGps5MvBux","author":{"login":"GregoryKimball"},"authorAssociation":"CONTRIBUTOR","body":"I'd like to cross-reference this issue with #11968. It's likely that the `null_count` appearances in profiles will change as we refactor `null_count` for compatibility with user-provided streams.","createdAt":"2022-10-21T20:17:55Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/11923#issuecomment-1287396273","viewerDidAuthor":false},{"id":"IC_kwDOBWUGps5M7kag","author":{"login":"jrhemstad"},"authorAssociation":"CONTRIBUTOR","body":">  it would be great if explode could compute null count as part of that kernel.\r\n\r\nI'm not following. `explode` returns a `table`: https://github.com/rapidsai/cudf/blob/7d173c9d144a64c5e1a0467d2a5eb4181854f25e/cpp/include/cudf/lists/explode.hpp#L72\r\n\r\nAre you then constructing a `column_view` for each of the lists that were exploded? \r\n\r\nIf so, then yeah, you're going to have a problem with computing the null count of each of those `column_view`s individually. \r\n\r\nTo make that efficient, you'd have to do what we do in `cudf::split` where we compute the individual null counts in bulk with a single `segmented_null_count`: https://github.com/rapidsai/cudf/blob/9c06330363db4da99803a3728b8bf44f9829f0b9/cpp/include/cudf/detail/null_mask.hpp#L186-L204","createdAt":"2022-10-25T14:52:45Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/11923#issuecomment-1290684064","viewerDidAuthor":false}],"createdAt":"2022-10-14T16:22:33Z","id":"I_kwDOBWUGps5UBITg","labels":[{"id":"MDU6TGFiZWwxMTM5NzQwNjY2","name":"libcudf","description":"Affects libcudf (C++/CUDA) code.","color":"c5def5"},{"id":"MDU6TGFiZWwxMzIyMjUyNjE3","name":"Performance","description":"Performance related issue","color":"C2E0C6"},{"id":"MDU6TGFiZWwxNDA1MTQ2OTc1","name":"Spark","description":"Functionality that helps Spark RAPIDS","color":"7400ff"}],"milestone":null,"number":11923,"projectCards":[{"project":{"name":"Feature Planning"},"column":{"name":"Needs prioritizing"}}],"projectItems":[],"reactionGroups":[],"state":"OPEN","title":"[TASK][JNI] Investigate train of `null_count` after `explode`","updatedAt":"2022-10-25T14:52:45Z","url":"https://github.com/rapidsai/cudf/issues/11923"}

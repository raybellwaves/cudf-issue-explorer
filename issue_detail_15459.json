{"assignees":[],"author":{"id":"MDQ6VXNlcjMxOTA0MDU=","is_bot":false,"login":"shwina","name":"Ashwin Srinath"},"body":"**Describe the bug**\r\nWhen `cudf.pandas` is enabled, we can pickle and unpickle objects using `pickle.dump/load` or `pickle.dumps/loads`. But if we choose to unpickle with `pd.read_pickle`, things go awry. Here's a minimal reproducer:\r\n\r\n```python\r\nimport pandas as pd\r\nfrom io import BytesIO\r\nimport pickle\r\n\r\npdf = pd.DataFrame({'a': [1.0, 2.0, None, 3.0]})\r\n\r\nwith open(\"pickled_pdf.pkl\", \"wb\") as f:\r\n    pickle.dump(pdf, f)\r\n\r\nwith open(\"pickled_pdf.pkl\", \"rb\") as f:\r\n    df = pd.read_pickle(f)\r\n\r\nprint(df)\r\n```\r\n\r\n<details>\r\n\r\n```\r\nIn [1]: %load_ext cudf.pandas\r\n\r\nIn [2]: import pandas as pd\r\n\r\nIn [3]: from io import BytesIO\r\n   ...: import pickle\r\n   ...: \r\n   ...: pdf = pd.DataFrame({'a': [1.0, 2.0, None, 3.0]})\r\n   ...: \r\n   ...: with open(\"pickled_pdf.pkl\", \"wb\") as f:\r\n   ...:     pickle.dump(pdf, f)\r\n   ...: \r\n   ...: with open(\"pickled_pdf.pkl\", \"rb\") as f:\r\n   ...:     df = pd.read_pickle(f)\r\n   ...: \r\n   ...: print(df)\r\n---------------------------------------------------------------------------\r\nAttributeError                            Traceback (most recent call last)\r\nFile ~/mroeschke-cudf/python/cudf/cudf/pandas/fast_slow_proxy.py:888, in _fast_slow_function_call(func, *args, **kwargs)\r\n    883 with nvtx.annotate(\r\n    884     \"EXECUTE_FAST\",\r\n    885     color=_CUDF_PANDAS_NVTX_COLORS[\"EXECUTE_FAST\"],\r\n    886     domain=\"cudf_pandas\",\r\n    887 ):\r\n--> 888     fast_args, fast_kwargs = _fast_arg(args), _fast_arg(kwargs)\r\n    889     result = func(*fast_args, **fast_kwargs)\r\n\r\nFile ~/mroeschke-cudf/python/cudf/cudf/pandas/fast_slow_proxy.py:1007, in _fast_arg(arg)\r\n   1006 seen: Set[int] = set()\r\n-> 1007 return _transform_arg(arg, \"_fsproxy_fast\", seen)\r\n\r\nFile ~/mroeschke-cudf/python/cudf/cudf/pandas/fast_slow_proxy.py:934, in _transform_arg(arg, attribute_name, seen)\r\n    932 if type(arg) is tuple:\r\n    933     # Must come first to avoid infinite recursion\r\n--> 934     return tuple(_transform_arg(a, attribute_name, seen) for a in arg)\r\n    935 elif hasattr(arg, \"__getnewargs_ex__\"):\r\n    936     # Partial implementation of to reconstruct with\r\n    937     # transformed pieces\r\n    938     # This handles scipy._lib._bunch._make_tuple_bunch\r\n\r\nFile ~/mroeschke-cudf/python/cudf/cudf/pandas/fast_slow_proxy.py:934, in <genexpr>(.0)\r\n    932 if type(arg) is tuple:\r\n    933     # Must come first to avoid infinite recursion\r\n--> 934     return tuple(_transform_arg(a, attribute_name, seen) for a in arg)\r\n    935 elif hasattr(arg, \"__getnewargs_ex__\"):\r\n    936     # Partial implementation of to reconstruct with\r\n    937     # transformed pieces\r\n    938     # This handles scipy._lib._bunch._make_tuple_bunch\r\n\r\nFile ~/mroeschke-cudf/python/cudf/cudf/pandas/fast_slow_proxy.py:917, in _transform_arg(arg, attribute_name, seen)\r\n    916 if isinstance(arg, (_FastSlowProxy, _FastSlowProxyMeta, _FunctionProxy)):\r\n--> 917     typ = getattr(arg, attribute_name)\r\n    918     if typ is _Unusable:\r\n\r\nFile ~/mroeschke-cudf/python/cudf/cudf/pandas/fast_slow_proxy.py:553, in _FastSlowProxy.__getattr__(self, name)\r\n    550 if name.startswith(\"_fsproxy\"):\r\n    551     # an AttributeError was raised when trying to evaluate\r\n    552     # an internal attribute, we just need to propagate this\r\n--> 553     _raise_attribute_error(self.__class__.__name__, name)\r\n    554 if name in {\r\n    555     \"_ipython_canary_method_should_not_exist_\",\r\n    556     \"_ipython_display_\",\r\n   (...)\r\n    568     # This is somewhat delicate to the order in which IPython\r\n    569     # implements special display fallbacks.\r\n\r\nFile ~/mroeschke-cudf/python/cudf/cudf/pandas/fast_slow_proxy.py:392, in _raise_attribute_error(obj, name)\r\n    387 \"\"\"\r\n    388 Raise an AttributeError with a message that is consistent with\r\n    389 the error raised by Python for a non-existent attribute on a\r\n    390 proxy object.\r\n    391 \"\"\"\r\n--> 392 raise AttributeError(f\"'{obj}' object has no attribute '{name}'\")\r\n\r\nAttributeError: 'function' object has no attribute '_fsproxy_fast'\r\n\r\nDuring handling of the above exception, another exception occurred:\r\n\r\nAttributeError                            Traceback (most recent call last)\r\n<ipython-input-3-deda8b8b446c> in ?()\r\n      8 \r\n      9 with open(\"pickled_pdf.pkl\", \"rb\") as f:\r\n     10     df = pd.read_pickle(f)\r\n     11 \r\n---> 12 print(df)\r\n\r\n~/mroeschke-cudf/python/cudf/cudf/pandas/fast_slow_proxy.py in ?(self, *args, **kwargs)\r\n    836     def __call__(self, *args, **kwargs) -> Any:\r\n--> 837         result, _ = _fast_slow_function_call(\r\n    838             # We cannot directly call self here because we need it to be\r\n    839             # converted into either the fast or slow object (by\r\n    840             # _fast_slow_function_call) to avoid infinite recursion.\r\n\r\n~/mroeschke-cudf/python/cudf/cudf/pandas/fast_slow_proxy.py in ?(func, *args, **kwargs)\r\n    898             domain=\"cudf_pandas\",\r\n    899         ):\r\n    900             slow_args, slow_kwargs = _slow_arg(args), _slow_arg(kwargs)\r\n    901             with disable_module_accelerator():\r\n--> 902                 result = func(*slow_args, **slow_kwargs)\r\n    903     return _maybe_wrap_result(result, func, *args, **kwargs), fast\r\n\r\n~/mroeschke-cudf/python/cudf/cudf/pandas/fast_slow_proxy.py in ?(fn, args, kwargs)\r\n     29 def call_operator(fn, args, kwargs):\r\n---> 30     return fn(*args, **kwargs)\r\n\r\n~/miniforge3/envs/cudf-dev/lib/python3.11/site-packages/pandas/core/frame.py in ?(self)\r\n   1199             self.info(buf=buf)\r\n   1200             return buf.getvalue()\r\n   1201 \r\n   1202         repr_params = fmt.get_dataframe_repr_params()\r\n-> 1203         return self.to_string(**repr_params)\r\n\r\n~/miniforge3/envs/cudf-dev/lib/python3.11/site-packages/pandas/util/_decorators.py in ?(*args, **kwargs)\r\n    329                     msg.format(arguments=_format_argument_list(allow_args)),\r\n    330                     FutureWarning,\r\n    331                     stacklevel=find_stack_level(),\r\n    332                 )\r\n--> 333             return func(*args, **kwargs)\r\n\r\n~/miniforge3/envs/cudf-dev/lib/python3.11/site-packages/pandas/core/frame.py in ?(self, buf, columns, col_space, header, index, na_rep, formatters, float_format, sparsify, index_names, justify, max_rows, max_cols, show_dimensions, decimal, line_width, min_rows, max_colwidth, encoding)\r\n   1361         \"\"\"\r\n   1362         from pandas import option_context\r\n   1363 \r\n   1364         with option_context(\"display.max_colwidth\", max_colwidth):\r\n-> 1365             formatter = fmt.DataFrameFormatter(\r\n   1366                 self,\r\n   1367                 columns=columns,\r\n   1368                 col_space=col_space,\r\n\r\n~/miniforge3/envs/cudf-dev/lib/python3.11/site-packages/pandas/io/formats/format.py in ?(self, frame, columns, col_space, header, index, na_rep, formatters, justify, float_format, sparsify, index_names, max_rows, min_rows, max_cols, show_dimensions, decimal, bold_rows, escape)\r\n    443         bold_rows: bool = False,\r\n    444         escape: bool = True,\r\n    445     ) -> None:\r\n    446         self.frame = frame\r\n--> 447         self.columns = self._initialize_columns(columns)\r\n    448         self.col_space = self._initialize_colspace(col_space)\r\n    449         self.header = header\r\n    450         self.index = index\r\n\r\n~/miniforge3/envs/cudf-dev/lib/python3.11/site-packages/pandas/io/formats/format.py in ?(self, columns)\r\n    552             cols = ensure_index(columns)\r\n    553             self.frame = self.frame[cols]\r\n    554             return cols\r\n    555         else:\r\n--> 556             return self.frame.columns\r\n\r\n~/miniforge3/envs/cudf-dev/lib/python3.11/site-packages/pandas/core/generic.py in ?(self, name)\r\n   6292             and name not in self._accessors\r\n   6293             and self._info_axis._can_hold_identifiers_and_holds_name(name)\r\n   6294         ):\r\n   6295             return self[name]\r\n-> 6296         return object.__getattribute__(self, name)\r\n\r\nproperties.pyx in ?()\r\n---> 65 'Could not get source, probably due dynamically evaluated source code.'\r\n\r\n~/miniforge3/envs/cudf-dev/lib/python3.11/site-packages/pandas/core/generic.py in ?(self, name)\r\n   6292             and name not in self._accessors\r\n   6293             and self._info_axis._can_hold_identifiers_and_holds_name(name)\r\n   6294         ):\r\n   6295             return self[name]\r\n-> 6296         return object.__getattribute__(self, name)\r\n\r\nAttributeError: 'DataFrame' object has no attribute '_mgr'\r\n```\r\n</details>\r\n \r\nWe can (and do) control what happens when objects are pickled and unpickled via the pickle protocol (`pickle.dump` and `pickle.load`) [here](https://github.com/rapidsai/cudf/blob/5192b608eeed4bda9317c657253c3a5630aa4c5d/python/cudf/cudf/pandas/fast_slow_proxy.py#L722-L741). \r\n\r\nAnd pandas' `read_pickle` does call the \"regular\" [`pickle.load` function](https://github.com/pandas-dev/pandas/blob/05ab1af783f6590b8a2d9fbea6d39793e88dfb04/pandas/io/pickle.py#L203). \r\n\r\nSo what's going on?\r\n\r\nWhen we call `pd.read_pickle` in `cudf.pandas` mode, that will first call `cudf.read_pickle` (doesn't exist) and then fall back to the real `pandas.read_pickle`. Importantly, during fallback, we [disable ourselves](https://github.com/rapidsai/cudf/blob/5192b608eeed4bda9317c657253c3a5630aa4c5d/python/cudf/cudf/pandas/fast_slow_proxy.py#L901). Which means that our special pickle protocol handling doesn't kick in and that messes everything up. \r\n\r\n### Solutions\r\n\r\nThe only solution I could think of is we vendor `pandas.read_pickle`, so we can keep ourselves enabled when it is called.","closed":false,"closedAt":null,"comments":[],"createdAt":"2024-04-03T20:24:39Z","id":"I_kwDOBWUGps6EjR-l","labels":[{"id":"MDU6TGFiZWw1OTk2MjY1NTk=","name":"bug","description":"Something isn't working","color":"d73a4a"},{"id":"LA_kwDOBWUGps8AAAABlj4eYg","name":"cudf.pandas","description":"Issues specific to cudf.pandas","color":"984DFB"}],"milestone":{"number":35,"title":"Proxying - cudf.pandas","description":"","dueOn":null},"number":15459,"projectCards":[],"projectItems":[],"reactionGroups":[],"state":"OPEN","title":"[BUG] Unpickling objects with `pd.read_pickle()` doesn't work with cudf.pandas enabled","updatedAt":"2024-04-15T14:34:02Z","url":"https://github.com/rapidsai/cudf/issues/15459"}

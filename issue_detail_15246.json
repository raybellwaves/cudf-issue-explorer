{"assignees":[],"author":{"id":"U_kgDOCakYeg","is_bot":false,"login":"blue-cat-whale","name":""},"body":"When running my code with `cudf`, I got `TypeError: a bytes-like object is required, not 'dict'` in the multi-thread returning part.\r\n1. Running the code without `-m cudf.pandas` option is *fine*.\r\n2. It's *okay* if each multi-thread branch returns merely a scalar.\r\n3. Program **CRUSHES** if a multi-thread branch returns a dataframe.\r\n\r\nThis is the code message:\r\n```\r\nconcurrent.futures.process._RemoteTraceback:\r\n'''\r\nTraceback (most recent call last):\r\n  File \"/usr/lib64/python3.9/concurrent/futures/process.py\", line 387, in wait_result_broken_or_wakeup\r\n    result_item = result_reader.recv()\r\n  File \"/usr/lib64/python3.9/multiprocessing/connection.py\", line 255, in recv\r\n    return _ForkingPickler.loads(buf.getbuffer())\r\n  File \"/usr/local/lib64/python3.9/site-packages/cudf/pandas/fast_slow_proxy.py\", line 742, in __setstate__\r\n    unpickled_wrapped_obj = pickle.loads(state)\r\nTypeError: a bytes-like object is required, not 'dict'\r\n'''\r\n\r\nThe above exception was the direct cause of the following exception:\r\n\r\nTraceback (most recent call last):\r\n  File \"/usr/lib64/python3.9/runpy.py\", line 197, in _run_module_as_main\r\n    return _run_code(code, main_globals, None,\r\n  File \"/usr/lib64/python3.9/runpy.py\", line 87, in _run_code\r\n    exec(code, run_globals)\r\n  File \"/usr/local/lib64/python3.9/site-packages/cudf/pandas/__main__.py\", line 91, in <module>\r\n    main()\r\n  File \"/usr/local/lib64/python3.9/site-packages/cudf/pandas/__main__.py\", line 87, in main\r\n    runpy.run_path(args.args[0], run_name=\"__main__\")\r\n  File \"/usr/lib64/python3.9/runpy.py\", line 288, in run_path\r\n    return _run_module_code(code, init_globals, run_name,\r\n  File \"/usr/lib64/python3.9/runpy.py\", line 97, in _run_module_code\r\n    _run_code(code, mod_globals, init_globals,\r\n  File \"/usr/lib64/python3.9/runpy.py\", line 87, in _run_code\r\n    exec(code, run_globals)\r\n  File \"clean_header.py\", line 48, in <module>\r\n    main()\r\n  File \"clean_header.py\", line 45, in main\r\n    my_func()\r\n  File \"clean_header.py\", line 39, in my_func\r\n    for obj in r:\r\n  File \"/usr/lib64/python3.9/concurrent/futures/process.py\", line 562, in _chain_from_iterable_of_lists\r\n    for element in iterable:\r\n  File \"/usr/lib64/python3.9/concurrent/futures/_base.py\", line 609, in result_iterator\r\n    yield fs.pop().result()\r\n  File \"/usr/lib64/python3.9/concurrent/futures/_base.py\", line 439, in result\r\n    return self.__get_result()\r\n  File \"/usr/lib64/python3.9/concurrent/futures/_base.py\", line 391, in __get_result\r\n    raise self._exception\r\nconcurrent.futures.process.BrokenProcessPool: A process in the process pool was terminated abruptly while the future was running or pending.\r\n```\r\n\r\n\r\nHere is my code.\r\n```\r\nfrom datetime import datetime, timedelta, date\r\nimport numpy as np\r\nimport pandas as pd\r\nfrom random import randint\r\nimport swifter\r\nimport json, sys, os\r\nfrom cudf.pandas.module_accelerator import disable_module_accelerator\r\n\r\nfrom functools import partial\r\nfrom concurrent.futures import ProcessPoolExecutor as Pool\r\nfrom multiprocessing import set_start_method\r\n\r\n\r\ndef data_generation(nRows: int):\r\n################## unimportant, for reproducing purpose ###################\r\n# This function generates the dataframe obj, which has 5 columns, and the data are sorted by WorkingDay and Minute ascendingly\r\n    my_df = pd.DataFrame(data={'WorkingDay': ['2019-01-02', '2018-01-02', '2019-05-02', '2020-01-02', '2021-01-02'], 'name': ['albert', 'alex', 'alice', 'ben', 'bob'], 'Minute': ['09:00:00', '09:20:00', '08:00:00', '07:00:00', '09:30:00'], 'aaa': np.random.rand(5), 'bbb': np.    random.rand(5)})\r\n    my_df = pd.concat([my_df for i in range(int(nRows/5))], axis=0)\r\n    my_df['WorkingDay'] = my_df['WorkingDay'].map(lambda x: (date(randint(2010,2020), randint(1,4), randint(1,5))).strftime('%Y-%m-%d'))\r\n    my_df['Minute'] = np.random.permutation(my_df['Minute'].values)\r\n    my_df = my_df.sort_values(by=['WorkingDay', 'Minute'], inplace=False).reset_index(drop=True,inplace=False)\r\n    return my_df\r\n\r\ndef my_func_single(branchIndex: int):\r\n    my_df = data_generation(20-5*branchIndex)\r\n# data generated\r\n#############################################################################\r\n    # The multi-thread return is problematic\r\n#############################################################################\r\n    #return my_df.shape[0]\r\n    return my_df\r\n\r\n\r\ndef my_func():\r\n    set_start_method('spawn')\r\n    my_func_partial = partial(my_func_single)\r\n    with Pool(max_workers=2) as pool:\r\n        r = pool.map(my_func_partial, range(4))\r\n    for obj in r:\r\n        #print('df has length: {}.'.format(obj))\r\n        print('df has length: {}.'.format(obj.shape[0]))\r\n\r\ndef main():\r\n    print('-------------------- program starts -----------------------')\r\n    my_func()\r\n\r\nif __name__ == '__main__':\r\n    main()\r\n```\r\n\r\nRelevant dependencies:\r\n```\r\ncuda-python==12.4.0\r\ncudf-cu12==24.4.0a516\r\ncugraph-cu12==24.4.0a69\r\ncuml-cu12==24.4.0a37\r\ndask==2024.1.1\r\ndask-cuda==24.4.0a11\r\ndask-cudf-cu12==24.4.0a516\r\npylibcugraph-cu12==24.4.0a69\r\npylibraft-cu12==24.4.0a70\r\n```\r\n","closed":false,"closedAt":null,"comments":[{"id":"IC_kwDOBWUGps52Lp6I","author":{"login":"blue-cat-whale"},"authorAssociation":"NONE","body":"I tried another parallel mechanism and a similar error appers.\r\n\r\nThe new code:\r\n```\r\ndef my_func():\r\n  num_cores = 2\r\n  inputs = range(4)\r\n  results = Parallel(n_jobs=num_cores)(delayed(my_func_single)(i) for i in inputs)\r\n  for obj in results:   \r\n    print('df has length: {}.'.format(obj.shape[0]))\r\n\r\ndef main():\r\n  print('-------------------- program starts -----------------------')\r\n  my_func()  \r\n\r\nif __name__ == '__main__':\r\n  main()\r\n```\r\n\r\nThe error message:\r\n```\r\njoblib.externals.loky.process_executor._RemoteTraceback:\r\n\"\"\"\r\nTraceback (most recent call last):\r\n  File \"/usr/local/lib64/python3.9/site-packages/joblib/externals/loky/process_executor.py\", line 661, in wait_result_broken_or_wakeup\r\n    result_item = result_reader.recv()\r\n  File \"/usr/lib64/python3.9/multiprocessing/connection.py\", line 255, in recv\r\n    return _ForkingPickler.loads(buf.getbuffer())\r\n  File \"/usr/local/lib64/python3.9/site-packages/cudf/pandas/fast_slow_proxy.py\", line 742, in __setstate__\r\n    unpickled_wrapped_obj = pickle.loads(state)\r\nTypeError: a bytes-like object is required, not 'dict'\r\n\"\"\"\r\n\r\nThe above exception was the direct cause of the following exception:\r\n\r\nTraceback (most recent call last):\r\n  File \"/usr/lib64/python3.9/runpy.py\", line 197, in _run_module_as_main\r\n    return _run_code(code, main_globals, None,\r\n  File \"/usr/lib64/python3.9/runpy.py\", line 87, in _run_code\r\n    exec(code, run_globals)\r\n  File \"/usr/local/lib64/python3.9/site-packages/cudf/pandas/__main__.py\", line 91, in <module>\r\n    main()\r\n  File \"/usr/local/lib64/python3.9/site-packages/cudf/pandas/__main__.py\", line 87, in main\r\n    runpy.run_path(args.args[0], run_name=\"__main__\")\r\n  File \"/usr/lib64/python3.9/runpy.py\", line 288, in run_path\r\n    return _run_module_code(code, init_globals, run_name,\r\n  File \"/usr/lib64/python3.9/runpy.py\", line 97, in _run_module_code\r\n    _run_code(code, mod_globals, init_globals,\r\n  File \"/usr/lib64/python3.9/runpy.py\", line 87, in _run_code\r\n    exec(code, run_globals)\r\n  File \"clean_header.py\", line 49, in <module>\r\n    main()\r\n  File \"clean_header.py\", line 45, in main\r\n    my_func()\r\n  File \"clean_header.py\", line 38, in my_func\r\n    results = Parallel(n_jobs=num_cores)(delayed(my_func_single)(i) for i in inputs)\r\n  File \"/usr/local/lib64/python3.9/site-packages/joblib/parallel.py\", line 1952, in __call__\r\n    return output if self.return_generator else list(output)\r\n  File \"/usr/local/lib64/python3.9/site-packages/joblib/parallel.py\", line 1595, in _get_outputs\r\n    yield from self._retrieve()\r\n  File \"/usr/local/lib64/python3.9/site-packages/joblib/parallel.py\", line 1699, in _retrieve\r\n    self._raise_error_fast()\r\n  File \"/usr/local/lib64/python3.9/site-packages/joblib/parallel.py\", line 1734, in _raise_error_fast\r\n    error_job.get_result(self.timeout)\r\n  File \"/usr/local/lib64/python3.9/site-packages/joblib/parallel.py\", line 736, in get_result\r\n    return self._return_or_raise()\r\n  File \"/usr/local/lib64/python3.9/site-packages/joblib/parallel.py\", line 754, in _return_or_raise\r\n    raise self._result\r\njoblib.externals.loky.process_executor.BrokenProcessPool: A result has failed to un-serialize. Please ensure that the objects returned by the function are always picklable.\r\n```","createdAt":"2024-03-07T07:39:36Z","includesCreatedEdit":true,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/15246#issuecomment-1982766728","viewerDidAuthor":false},{"id":"IC_kwDOBWUGps52NCXL","author":{"login":"blue-cat-whale"},"authorAssociation":"NONE","body":"I use `return my_df.values, list(my_df.index)` to bypass this problem.","createdAt":"2024-03-07T09:48:56Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/15246#issuecomment-1983129035","viewerDidAuthor":false},{"id":"IC_kwDOBWUGps52Q-dM","author":{"login":"vyasr"},"authorAssociation":"CONTRIBUTOR","body":"I'm glad you were able to get the issue resolved in your case! That said, it does look like you're highlighting a real issue with using cudf.pandas objects in multiprocessing, so I'm going to reopen this issue for now. Here's a MWE for future investigation indicating that it's also sensitive to how the process is created. Since fork works while spawn does not, we're probably relying on some implicit state being preserved that is lost when a new process is spawned.\r\n\r\n```\r\n# Works correctly for `import cudf as pd`\r\nimport pandas as pd\r\n\r\nfrom concurrent.futures import ProcessPoolExecutor as Pool\r\nfrom multiprocessing import set_start_method\r\n\r\n\r\ndef f(i: int):\r\n    return pd.DataFrame({'a': [i]})\r\n\r\n\r\ndef main():\r\n    for method in ['fork', 'spawn', 'forkserver']:\r\n        set_start_method(method, force=True)\r\n        with Pool(max_workers=2) as pool:\r\n            r = pool.map(f, range(4))\r\n        try:\r\n            list(r)\r\n        except Exception as e:\r\n            print(f'{type(e).__name__}: {method}')\r\n        else:\r\n            print(f'Succeeded: {method}')\r\n\r\nif __name__ == '__main__':\r\n    main()\r\n```","createdAt":"2024-03-07T18:19:57Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/15246#issuecomment-1984161612","viewerDidAuthor":false},{"id":"IC_kwDOBWUGps52fq3Z","author":{"login":"wence-"},"authorAssociation":"CONTRIBUTOR","body":"This problem exhibits because when using `spawn` or `forkserver`, the new python process that is started by `multiprocessing` does not have the custom cudf.pandas metapath finder installed. Hence, the import of pandas as `import pandas as pd` fetches the real (unwrapped) pandas module, rather than the wrapped (cudf.pandas) module.\r\n\r\nConsider:\r\n\r\n```python\r\nimport sys\r\nfrom concurrent.futures import ProcessPoolExecutor as Pool\r\nfrom multiprocessing import set_start_method\r\n\r\ndef f():\r\n    print(sys.meta_path)\r\n\r\ndef main():\r\n    for method in ['fork', 'spawn', 'forkserver']:\r\n        print(method)\r\n        set_start_method(method, force=True)\r\n        with Pool(max_workers=1) as pool:\r\n            result = pool.submit(f).result()\r\n\r\nif __name__ == \"__main__\":\r\n    main()\r\n```\r\n\r\nWhen run with `python -m cudf.pandas bug.py`:\r\n```\r\nfork\r\n[ModuleAccelerator(fast=cudf, slow=pandas), <_distutils_hack.DistutilsMetaFinder object at 0x76f18b8991e0>, <_rmm_editable.ScikitBuildRedirectingFinder object at 0x76f18ba67fa0>, <_cudf_kafka_editable.ScikitBuildRedirectingFinder object at 0x76f18ba64700>, <_cudf_editable.ScikitBuildRedirectingFinder object at 0x76f18bb2b3d0>, <class '_frozen_importlib.BuiltinImporter'>, <class '_frozen_importlib.FrozenImporter'>, <class '_frozen_importlib_external.PathFinder'>, <six._SixMetaPathImporter object at 0x76f04651b4c0>]\r\n ^^^^^^^^^^^^^^^^^^^ Good!\r\nspawn\r\n[<_distutils_hack.DistutilsMetaFinder object at 0x78af5ec412d0>, <_rmm_editable.ScikitBuildRedirectingFinder object at 0x78af5ec405b0>, <_cudf_kafka_editable.ScikitBuildRedirectingFinder object at 0x78af5ee0c7f0>, <_cudf_editable.ScikitBuildRedirectingFinder object at 0x78af5eed74c0>, <class '_frozen_importlib.BuiltinImporter'>, <class '_frozen_importlib.FrozenImporter'>, <class '_frozen_importlib_external.PathFinder'>]\r\n ^ BAD!\r\nforkserver\r\n[<_distutils_hack.DistutilsMetaFinder object at 0x7c5cd58e92a0>, <_rmm_editable.ScikitBuildRedirectingFinder object at 0x7c5cd58e8580>, <_cudf_kafka_editable.ScikitBuildRedirectingFinder object at 0x7c5cd58a47c0>, <_cudf_editable.ScikitBuildRedirectingFinder object at 0x7c5cd596f490>, <class '_frozen_importlib.BuiltinImporter'>, <class '_frozen_importlib.FrozenImporter'>, <class '_frozen_importlib_external.PathFinder'>]\r\n```\r\n\r\nThe way one can work around this is to use the functional interface to cudf.pandas and install manually at the start of the file. Note that this must be done before an import of pandas. So:\r\n\r\n```\r\nimport cudf.pandas\r\ncudf.pandas.install()\r\n\r\nimport pandas as pd\r\nfrom concurrent.futures import ProcessPoolExecutor as Pool\r\nfrom multiprocessing import set_start_method\r\n\r\n\r\ndef f(i: int):\r\n    return pd.DataFrame({'a': [i]})\r\n\r\n\r\ndef main():\r\n    for method in ['fork', 'spawn', 'forkserver']:\r\n        set_start_method(method, force=True)\r\n        with Pool(max_workers=2) as pool:\r\n            r = pool.map(f, range(4))\r\n        try:\r\n            list(r)\r\n        except Exception as e:\r\n            print(f'{type(e).__name__}: {method}')\r\n        else:\r\n            print(f'Succeeded: {method}')\r\n\r\nif __name__ == '__main__':\r\n    main()\r\n```\r\n\r\nWill work for all three cases.","createdAt":"2024-03-11T09:52:58Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/15246#issuecomment-1988013529","viewerDidAuthor":false},{"id":"IC_kwDOBWUGps52fq_M","author":{"login":"wence-"},"authorAssociation":"CONTRIBUTOR","body":"We should probably add this as a known limitation in the FAQ.","createdAt":"2024-03-11T09:53:12Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/15246#issuecomment-1988014028","viewerDidAuthor":false}],"createdAt":"2024-03-07T07:19:32Z","id":"I_kwDOBWUGps6Bh5Nf","labels":[{"id":"MDU6TGFiZWw1OTk2MjY1NjQ=","name":"question","description":"Further information is requested","color":"D4C5F9"},{"id":"MDU6TGFiZWwxMDEzOTg5MDIz","name":"doc","description":"Documentation","color":"1C62F8"}],"milestone":null,"number":15246,"projectCards":[],"projectItems":[],"reactionGroups":[],"state":"OPEN","title":"[QST] Returning from multi-thread. TypeError: a bytes-like object is required, not 'dict'","updatedAt":"2024-03-11T09:53:25Z","url":"https://github.com/rapidsai/cudf/issues/15246"}

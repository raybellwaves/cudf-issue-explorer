{"assignees":[],"author":{"id":"MDQ6VXNlcjM5NDM3NjE=","is_bot":false,"login":"bdice","name":"Bradley Dice"},"body":"**Is your feature request related to a problem? Please describe.**\r\nI would like to be able to access the offsets of a Series of lists. That would allow me to implement a function like `list_add` that takes two \"awkward arrays,\" Series of lists of numbers that have the same list shape, and adds them together. The binary operation can be straightforwardly applied to the \"leaves\" of each list column, which is the child column containing the data. However, to do this, I need a way to access indices and rebuild the list structure. For example, if `Series.list.offsets` and `cudf.Series.list.from_arrays(offsets, values)` existed, I could run something like:\r\n\r\n```python\r\ndef list_add(s1, s2):\r\n    \"\"\"Take two Series of lists of numerical data and add them.\"\"\"\r\n    # Ignore nested lists for simplicity -- this only works for a single level of lists\r\n    if s1.list.offsets!= s2.list.offsets:\r\n        raise ValueError(\"List columns must have corresponding offsets.\")\r\n    return cudf.Series.list.from_arrays(s1.list.offsets, s1.list.leaves + s2.list.leaves)\r\n```\r\n\r\n**Describe the solution you'd like**\r\n- Implement a property `Series.list.offsets` that exposes the offset array, similar to [PyArrow's `pyarrow.ListArray.offsets`](https://arrow.apache.org/docs/python/generated/pyarrow.ListArray.html#pyarrow.ListArray.offsets) but returning a GPU-resident array.\r\n\r\n- Implement a constructor `Series.list.from_arrays(offsets, values)` that builds a Series of lists from input offsets and values, similar to [PyArrow's `pyarrow.ListArray.from_arrays`](https://arrow.apache.org/docs/python/generated/pyarrow.ListArray.html#pyarrow.ListArray.from_arrays) but enabling construction from GPU-resident arrays.\r\n\r\n**Describe alternatives you've considered**\r\nI strongly prefer this approach over implementing binops directly on list types because it allows for precise control of what APIs are exposed and how they behave. Implementing binops for lists would allow for operators like `+` to be used, which is prone to error because it overloads the Python-like list semantics of \"adding is list concatenation\" with the array-like semantics of normal addition.\r\n\r\n**Additional context**\r\nIt's not clear to me where the name \"leaves\" came from. To align with PyArrow, we would rename \"leaves\" to `Series.list.values`.","closed":false,"closedAt":null,"comments":[{"id":"IC_kwDOBWUGps5FStPW","author":{"login":"shwina"},"authorAssociation":"CONTRIBUTOR","body":"FWIW, there is a \"Pandas compatible\" way to do this today: https://github.com/rapidsai/cudf/issues/10967#issuecomment-1138590222. But I'd agree that a more explicit API would be desirable.\r\n\r\nI wouldn't have any objections to adding an `.offsets` accessor, other than I suppose it leaks some implementation detail (insofar as cuDF following the Arrow format is an \"implementation detail\").\r\n\r\nMy 2c here is that the ideal way to do this would be to zero copy to something like a GPU accelerated Awkward Array and back. ","createdAt":"2022-06-22T01:48:47Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/11130#issuecomment-1162531798","viewerDidAuthor":false},{"id":"IC_kwDOBWUGps5FSu-N","author":{"login":"bdice"},"authorAssociation":"CONTRIBUTOR","body":"@shwina That's very helpful, I did not consider `explode()`/`agg(list)`. To simplify and match this example:\r\n```python\r\ndef list_add(s1, s2):\r\n    return (s1.explode() - s2.explode()).groupby(level=0).agg(list)\r\n```\r\nI'm guessing that `explode()` returns a copy, unlike `Series.list.leaves`, and that `groupby(level=0).agg(list)` is nontrivial to compute compared to a constructor from offsets and values. Perhaps there would be good reasons for performance and flexibility to expose the offset accessor / list constructor primitives.\r\n\r\nAs to whether offsets are an implementation detail -- I considered this as well. My view is that offsets are helpful to expose and doing so does not make stronger promises about our data model than what we already make in other ways ([offsets are already exposed in the libcudf API](https://docs.rapids.ai/api/libcudf/nightly/classcudf_1_1lists__column__view.html#a3d738360310aad73666f1e3de3b7e50e), and cuDF has a stated aim to be Arrow-conformant to a large extent).\r\n\r\nI definitely agree that the ability to do this computation in a zero-copy way and compatibility with GPU Awkward Arrays would be desirable. Exposing the raw offsets and a way to rebuild a list from them seems like a good step in both of those directions.","createdAt":"2022-06-22T02:03:32Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/11130#issuecomment-1162538893","viewerDidAuthor":false},{"id":"IC_kwDOBWUGps5FVLkM","author":{"login":"shwina"},"authorAssociation":"CONTRIBUTOR","body":"> It's not clear to me where the name \"leaves\" came from. To align with PyArrow, we would rename \"leaves\" to Series.list.values.\r\n\r\nNote  that  `values` are distinct from `leaves`:\r\n\r\nThe `values` of a list array is what you get by removing \"one level of nesting\" from the array:\r\n\r\n```python\r\n>>> pa.array([[[[1, 2]]]]).values\r\n<pyarrow.lib.ListArray object at 0x7fe4de05df40>\r\n[\r\n  [\r\n    [\r\n      1,\r\n      2\r\n    ]\r\n  ]\r\n]\r\n```\r\n\r\nWhereas what we call `leaves` is what you get from removing _all_ levels of nesting:\r\n\r\n```python\r\nIn [7]: cudf.Series([[[[1, 2]]]]).list.leaves\r\nOut[7]:\r\n0    1\r\n1    2\r\ndtype: int64\r\n```","createdAt":"2022-06-22T14:32:11Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[{"content":"THUMBS_UP","users":{"totalCount":1}}],"url":"https://github.com/rapidsai/cudf/issues/11130#issuecomment-1163180300","viewerDidAuthor":false},{"id":"IC_kwDOBWUGps5FVaTQ","author":{"login":"bdice"},"authorAssociation":"CONTRIBUTOR","body":"@shwina Interesting. Would you consider exposing both `list.values` and `list.leaves`? It seems important to have a way to un-nest one level at a time (like with `list.offsets`).","createdAt":"2022-06-22T15:14:20Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/11130#issuecomment-1163240656","viewerDidAuthor":false},{"id":"IC_kwDOBWUGps5FVhTD","author":{"login":"shwina"},"authorAssociation":"CONTRIBUTOR","body":">  Would you consider exposing both list.values and list.leaves? It seems important to have a way to un-nest one level at a time (like with list.offsets).\r\n\r\nAgain, while I'm not _opposed_ to exposing these, I'm much more in favor of higher-level APIs that allow the user not to worry about how lists are actually implemented. For example, if we want to enable binary/unary ops involving list columns, perhaps a better API is something like `eval`?\r\n\r\n```python\r\ndf.list.eval(\"a + b * sin(c)\"`\r\n```\r\n\r\n","createdAt":"2022-06-22T15:33:48Z","includesCreatedEdit":true,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/11130#issuecomment-1163269315","viewerDidAuthor":false},{"id":"IC_kwDOBWUGps5FVm1x","author":{"login":"bdice"},"authorAssociation":"CONTRIBUTOR","body":"I would expect eval’s behavior with + to match the + operator’s behavior, but we stated in a previous conversation (last week’s standup, I think?) that we explicitly do not want to overload operators where array-like operator semantics could conflict with Python list operator semantics (concatenation vs. elementwise addition). I am opposed to making eval act elementwise on lists — I expect an error there. An explicit function like `array_add` makes it more clear how the lists are being interpreted.\r\n\r\nIn any case, I think the right move is to add offsets/values accessors for alignment with libcudf and PyArrow, and debate/implement the action of array-like operators separately.\r\n\r\nI think it is important to be able to construct lists from GPU resident arrays, but that may not be possible without relying on the implementation of offsets/values.","createdAt":"2022-06-22T15:51:30Z","includesCreatedEdit":true,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/11130#issuecomment-1163292017","viewerDidAuthor":false},{"id":"IC_kwDOBWUGps5FVnzw","author":{"login":"shwina"},"authorAssociation":"CONTRIBUTOR","body":"Right, which is why I'm suggesting a distinct `DataFrame.list.eval` API (note the namespace).","createdAt":"2022-06-22T15:54:48Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[{"content":"THUMBS_UP","users":{"totalCount":1}}],"url":"https://github.com/rapidsai/cudf/issues/11130#issuecomment-1163295984","viewerDidAuthor":false},{"id":"IC_kwDOBWUGps5FVqY1","author":{"login":"bdice"},"authorAssociation":"CONTRIBUTOR","body":"> Right, which is why I'm suggesting a distinct `DataFrame.list.eval` API (note the namespace).\r\n\r\nI missed that namespace, thanks for the pointer. I have a lot of questions about how this would act and I don’t think the answers are obvious. AST limitations could be harshly constraining here and no broadcasting would be possible. It also introduces an undesirable asymmetry between operators and eval, and is beyond the API scope of both Pandas and Arrow… but so is `array_add`. Let’s table this for a separate discussion. @GregoryKimball might have insight on use cases that would motivate this but I don’t think we have an urgent need for new APIs if we implement the accessors / constructor.","createdAt":"2022-06-22T16:03:05Z","includesCreatedEdit":true,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/11130#issuecomment-1163306549","viewerDidAuthor":false},{"id":"IC_kwDOBWUGps5FV6VJ","author":{"login":"shwina"},"authorAssociation":"CONTRIBUTOR","body":"I agree - let's move the discussion relating to `eval` elsewhere.\r\n\r\nMy broader point though is that we shouldn't require the user to know or care about  `.values` and `.offsets` in order to do interesting things with lists in cuDF.\r\n\r\nIndeed, we could expose `values` and `offsets` and, with some effort, much of the existing list functionality could be implemented by the user knowing those.\r\n\r\nTwo questions I would ask are:\r\n\r\n1. What functionality do we want to ultimately unlock for users by exposing the `.offsets` and `.values` of an existing list column? Can/should we implement that functionality ourselves?\r\n\r\n3. Who/what is producing GPU-resident `offsets` and `values` arrays that requires a `from_arrays()` constructor? Can we have it return a list column instead?\r\n\r\nWe have been successful so far in totally hiding how strings, for instance, are implemented in cuDF. It'd be nice to do the same for lists.","createdAt":"2022-06-22T16:47:40Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/11130#issuecomment-1163371849","viewerDidAuthor":false},{"id":"IC_kwDOBWUGps5F7nsl","author":{"login":"GregoryKimball"},"authorAssociation":"CONTRIBUTOR","body":"Hello @shwina and @bdice, [bucketize](https://github.com/pytorch/torcharrow/blob/main/csrc/velox/functions/rec/bucketize.h) is a feature that we might unlock if we could construct a list column from offsets and values. \r\nBucketize is performed on leaves and uses the same offsets of the input columns.\r\n\r\n```\r\ndef bucketize(series, buckets):    \r\n    ans = cudf.Series([0] * len(series.list.leaves)) \r\n    for b in buckets:\r\n        ans += series.list.leaves > b\r\n    return cudf.Series.list.from_arrays(series.list.offsets, ans.list.leaves)\r\n```","createdAt":"2022-07-04T02:02:21Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/11130#issuecomment-1173256997","viewerDidAuthor":false},{"id":"IC_kwDOBWUGps5F7400","author":{"login":"GregoryKimball"},"authorAssociation":"CONTRIBUTOR","body":"To my surprise the `explode` trick from #10967 works here as well:\r\n```\r\ndef bucketize(a, buckets):\r\n    a_x = a.explode()\r\n    b = a_x * 0\r\n    for k in buckets:\r\n        b += a_x > k\r\n    return b.groupby(level=0).agg(list)\r\n```\r\n```\r\nimport cudf\r\ndf = cudf.DataFrame({'a':[[1, 2, 3, 3],[1, 2, 1, 0, 1]]})\r\ndf['b'] = bucketize(df['a'], [1, 2])\r\n```\r\n```\r\n                 a                b\r\n0     [1, 2, 3, 3]     [0, 1, 2, 2]\r\n1  [1, 2, 1, 0, 1]  [0, 1, 0, 0, 0]\r\n```","createdAt":"2022-07-04T04:24:15Z","includesCreatedEdit":true,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/11130#issuecomment-1173327156","viewerDidAuthor":false},{"id":"IC_kwDOBWUGps5F91mF","author":{"login":"shwina"},"authorAssociation":"CONTRIBUTOR","body":"Then `list.bucketize()` is an API we may want to consider adding, rather than having each user write their own version of it. ","createdAt":"2022-07-04T13:42:31Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/11130#issuecomment-1173838213","viewerDidAuthor":false},{"id":"IC_kwDOBWUGps5Hw39S","author":{"login":"github-actions"},"authorAssociation":"NONE","body":"This issue has been labeled `inactive-30d` due to no recent activity in the past 30 days. Please close this issue if no further response or action is needed. Otherwise, please respond with a comment indicating any updates or changes to the original issue and/or confirm this issue still needs to be addressed. This issue will be labeled `inactive-90d` if there is no activity in the next 60 days.","createdAt":"2022-08-03T14:03:11Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/11130#issuecomment-1203994450","viewerDidAuthor":false}],"createdAt":"2022-06-21T21:05:08Z","id":"I_kwDOBWUGps5MPVQI","labels":[{"id":"MDU6TGFiZWw1OTk2MjY1NjE=","name":"feature request","description":"New feature or request","color":"a2eeef"},{"id":"MDU6TGFiZWwxMTM5NzQxMjEz","name":"cuDF (Python)","description":"Affects Python cuDF API.","color":"1d76db"}],"milestone":{"number":2,"title":"List and Struct data types and operations","description":"","dueOn":null},"number":11130,"projectCards":[{"project":{"name":"Feature Planning"},"column":{"name":"Needs prioritizing"}}],"projectItems":[],"reactionGroups":[],"state":"OPEN","title":"[FEA] Get Series.list offsets / Construct Series of lists from offsets and values","updatedAt":"2024-02-23T18:42:29Z","url":"https://github.com/rapidsai/cudf/issues/11130"}

{"assignees":[],"author":{"id":"MDQ6VXNlcjExMjY5ODE=","is_bot":false,"login":"wence-","name":"Lawrence Mitchell"},"body":"**Describe the bug**\r\n\r\nIn pandas, `eval` treats `a op b` as always meaning the bitwise version `op in {and, or, &, |, ^}`. In cudf, due to the way we parse the expression without type information (and the dispatching scheme to the AST interpreter in libcudf), `and` and `or` mean \"logical\" and `&`, `|`, and `^` mean \"bitwise\". There's a final wrinkle that (like spark) for bools only, masked values are treated as `False`.\r\n\r\nThis can cause differences in the result between calling `eval` with pandas and with cudf. Although the docstring mentions these differences, when using `cudf.pandas`, we don't see the cudf docstring (only the pandas one).\r\n\r\n**Expected behavior**\r\n\r\nEventually, we should match pandas. I think this should be done by running a type inference pass on the user-provided expression and rewriting to an appropriate combination of bitwise and logical operations. This would have the nice side-effect of also allowing mixed-type operands in `eval` expressions by cudf upcasting before passing off to libcudf.\r\n\r\nIn the short term, we should probably raise a `NotImplementedError` when running in pandas-compat mode if the expression contains logical/bitwise binops.","closed":false,"closedAt":null,"comments":[{"id":"IC_kwDOBWUGps5tPeqn","author":{"login":"vyasr"},"authorAssociation":"CONTRIBUTOR","body":"Clarifying this statement:\r\n> There's a final wrinkle that (like spark) for bools only, masked values are treated as False.\r\n\r\nthis refers to the output of boolean column operations:\r\n```\r\n>>> pd.DataFrame({'a': [10], 'b': [True]}).eval('a and a')\r\n0    10\r\nName: a, dtype: int64\r\n>>> pd.DataFrame({'a': [10], 'b': [True]}).eval('a & a')\r\n0    10\r\nName: a, dtype: int64\r\n>>> pd.DataFrame({'a': [10], 'b': [True]}).eval('b and b')\r\n0    True\r\nName: b, dtype: bool\r\n>>> pd.DataFrame({'a': [10], 'b': [True]}).eval('b & b')\r\n0    True\r\nName: b, dtype: bool\r\n```\r\n\r\nIOW the statement being true relies on bitwise operators between bools being defined as returning bools.","createdAt":"2023-11-29T22:04:25Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/14517#issuecomment-1832774311","viewerDidAuthor":false},{"id":"IC_kwDOBWUGps5tPq_0","author":{"login":"wence-"},"authorAssociation":"CONTRIBUTOR","body":"No, replace your a column with a null value. the behaviour is different if it is a masked bool column to when it is a masked any other kind of column","createdAt":"2023-11-29T22:50:53Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/14517#issuecomment-1832824820","viewerDidAuthor":false},{"id":"IC_kwDOBWUGps5tP0tx","author":{"login":"vyasr"},"authorAssociation":"CONTRIBUTOR","body":"Ah OK. In that case my comment is more relevant as a separate statement about what behavior we need to see.","createdAt":"2023-11-29T23:32:19Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/14517#issuecomment-1832864625","viewerDidAuthor":false}],"createdAt":"2023-11-28T18:15:07Z","id":"I_kwDOBWUGps54GuLF","labels":[{"id":"MDU6TGFiZWw1OTk2MjY1NTk=","name":"bug","description":"Something isn't working","color":"d73a4a"},{"id":"MDU6TGFiZWwxMTM5NzQxMjEz","name":"cuDF (Python)","description":"Affects Python cuDF API.","color":"1d76db"}],"milestone":null,"number":14517,"projectCards":[],"projectItems":[],"reactionGroups":[],"state":"OPEN","title":"[BUG] Treatment of logical and bitwise binops in `DataFrame.eval` does not match pandas","updatedAt":"2024-05-16T05:09:16Z","url":"https://github.com/rapidsai/cudf/issues/14517"}

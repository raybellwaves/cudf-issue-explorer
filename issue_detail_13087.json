{"assignees":[],"author":{"id":"MDQ6VXNlcjQyNDk0NDc=","is_bot":false,"login":"lmeyerov","name":""},"body":"**Is your feature request related to a problem? Please describe.**\r\n\r\nWe get wide dataframes in situations like machine learning (easily 1-5K cols) and genomics (10K+ cols), and while there is some speedup from cudf (say 2-3X), it'd be easy to get to the 10X+ level with much higher GPU utilization if we could spawn concurrent tasks for each column . Getting this all the way to the df level seems tricky, but async primitives at the column level would get us far. \r\n\r\nOne Python-native idea is doing via `async/await`, when one cudf operation is getting scheduled, allocated, & run, we can be scheduling the next, and ideally, cudf can run them independently . It smoothed out 2-3 years ago in python + javascript as a popular native choice, and has since been  a lot more popular in pydata, e.g., langchain just rewrote to support async versions of all methods. Ex: https://trends.google.com/trends/explore?date=all&q=async%20await&hl=en . Separately, there's heightened value for pydata dashboarding scenarios like plotly, streamlit, etc as these ecosystem increasingly build for async io underneath as well.\r\n\r\n(Another idea with precedent is a lazy mode similar to haskell or dask, discussed below as well)\r\n\r\n**Describe the solution you'd like**\r\n\r\nI'd like to be do something like:\r\n\r\n```python\r\n\r\nasync def f(s: cudf.Series) -> cudf.Series:\r\n    # async mode for core series operations lets other f() calls proceed while this runs\r\n    s2 = await  s.stra.hex_to_int('AABBCC')\r\n   \r\n    # math can be clean and enable the same\r\n    # if we're super clever, this may even unlock query plan optimizations like fusion in the future\r\n    async with cudf.async.binop_mode:\r\n        s3_a = s2 + 1 / 3\r\n        s3 = await s3_a\r\n\r\n   return s3\r\n  \r\ncols2 = await async.gather([  f(df[col]) for col in df ])\r\n```\r\n\r\n**Describe alternatives you've considered**\r\n\r\n1. Use existing abstractions\r\n\r\nIn theory we can setup threads or multiple dask workers, but (1) both are super awkward, (2) underneath, cudf will not do concurrent jobs\r\n\r\n2. Lazy cudf\r\n\r\nAnother thought is to create a lazy mode for cudf. This has precedent with Haskell, and in modern pydata land, more so with polars. Dask does this too, and we'd use it if that can work, but it's awkward -- I haven't used, but polars sounds to be more friendly in practice:\r\n\r\n```python\r\n\r\ndef f(s: cudf.Series) -> cudf.Series:\r\n    # explicitly lazy ops\r\n    s2 = s.str_lazy.hex_to_int('AABBCC')\r\n\r\n    # binops know they're lazy\r\n    s3 = s2 + 1 / 3\r\n\r\n    return s3\r\n\r\n# force with async friendliness  \r\ncols2 = await cudf_client.compute_async([  f(df[col]) for col in df ])\r\n```\r\n\r\nUnderneath, cudf can reinvent async/io, dask, or whatever\r\n\r\n\r\n**Additional context**\r\n\r\nSlack thread: https://rapids-goai.slack.com/archives/C5E06F4DC/p1680710488795869 \r\n","closed":false,"closedAt":null,"comments":[{"id":"IC_kwDOBWUGps5Zb6IS","author":{"login":"lmeyerov"},"authorAssociation":"NONE","body":"From Slack: There's thinking of starting at the level of pylibcudf cpython bindings layer \r\n\r\nI can imagine there may be some worthwhile cudf internals that can be the first consumer of such things. Ex: Maybe some cuml kernels, or `df.str.xyz` df-level ones like hashing.","createdAt":"2023-04-07T17:28:08Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/13087#issuecomment-1500488210","viewerDidAuthor":false},{"id":"IC_kwDOBWUGps5eA20m","author":{"login":"GregoryKimball"},"authorAssociation":"CONTRIBUTOR","body":"Thank you @lmeyerov for raising this, and thank you for joining into the Slack discussion. \r\n\r\nHere are some points from the discussion:\r\n* RAPIDS is working on a new `pylibcudf` API that has low-level bindings to libcudf and will enable CUDA stream control. We expect that the appropriate usage pattern of streams in Python could accelerate your high-column-count transformations, even if it's not host-async\r\n* `asyncio` is associated with [high overhead](https://rapids-goai.slack.com/archives/C5E06F4DC/p1681368614519629?thread_ts=1680710488.795869&cid=C5E06F4DC) for short-running tasks, and most column transformations are likely to be small tasks \r\n* When CUDA streams are exposed in the python API, users will be able to write their own [asyncio coroutines](https://rapids-goai.slack.com/archives/C5E06F4DC/p1681372363833429?thread_ts=1680710488.795869&cid=C5E06F4DC).","createdAt":"2023-06-05T18:39:26Z","includesCreatedEdit":true,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/13087#issuecomment-1577282854","viewerDidAuthor":false},{"id":"IC_kwDOBWUGps5eJVHW","author":{"login":"lmeyerov"},"authorAssociation":"NONE","body":"Yes, that'll be interesting to us wrt some of the hot loops in https://github.com/graphistry/cu-cat: parallel per-column tasks, some sparse matrix math, ...","createdAt":"2023-06-06T21:59:22Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/13087#issuecomment-1579504086","viewerDidAuthor":false}],"createdAt":"2023-04-07T17:09:44Z","id":"I_kwDOBWUGps5i4ouf","labels":[{"id":"MDU6TGFiZWw1OTk2MjY1NjE=","name":"feature request","description":"New feature or request","color":"a2eeef"},{"id":"MDU6TGFiZWwxMDEzOTg3MzUy","name":"0 - Backlog","description":"In queue waiting for assignment","color":"d4c5f9"},{"id":"MDU6TGFiZWwxMTM5NzQwNjY2","name":"libcudf","description":"Affects libcudf (C++/CUDA) code.","color":"c5def5"},{"id":"MDU6TGFiZWwxMTM5NzQxMjEz","name":"cuDF (Python)","description":"Affects Python cuDF API.","color":"1d76db"}],"milestone":{"number":19,"title":"Enable streams","description":"Enable safe usage of a stream-ordered libcudf API","dueOn":null},"number":13087,"projectCards":[],"projectItems":[],"reactionGroups":[],"state":"OPEN","title":"[FEA] Async mode for cudf.series operations","updatedAt":"2023-06-06T21:59:22Z","url":"https://github.com/rapidsai/cudf/issues/13087"}

{"assignees":[],"author":{"id":"MDQ6VXNlcjM2MTU4NTk=","is_bot":false,"login":"aocsa","name":"Alexander Ocsa"},"body":"## Describe the bug\r\n\r\nThe AST evaluator and pandas evaluator are yielding divergent outcomes when evaluating expressions that include nullable columns.\r\n \r\nSteps/Code to reproduce bug\r\n\r\n```\r\nimport cudf\r\nimport pandas as pd\r\nfrom io import StringIO\r\n\r\n# Your CSV data as a string\r\ncsv_data = \"\"\"\\\r\nBrand#32,MED PKG,,,754.84,4428,3537.78\r\nBrand#53,MED BOX,,,3.98,1646,23333.44\r\nBrand#41,WRAP BAG,1,8,763.34,3547,14687.36\r\nBrand#43,SM BOX,2,46,15.45,6523,72572.36\r\nBrand#42,WRAP PKG,3,31,778.19,3849,33608.96\r\nBrand#23,LG JAR,4,43,101.93,4592,50407.61\r\n\"\"\"\r\ndtype_schema = {\r\n    'p_brand': 'string',   \r\n    'p_container': 'string', \r\n    'l_linenumber': 'float64',\r\n    'l_quantity': 'float64',  \r\n    'ps_supplycost': 'float64',   \r\n    'ps_availqty': 'float64',  \r\n    'l_extendedprice': 'float64'\r\n}\r\n\r\ndf = pd.read_csv(StringIO(csv_data), header=None, delimiter=',', dtype=dtype_schema, names=[name for name in dtype_schema])\r\n\r\ndf.eval(\"(p_brand == 'Brand#23' or p_container == 'MED BOX') or (l_quantity < ps_supplycost)\").value_counts()\r\ngdf = cudf.from_pandas(df)\r\n\r\ngdf.eval(\"(p_brand == 'Brand#23' or p_container == 'MED BOX') or (l_quantity < ps_supplycost)\").value_counts()\r\n``` \r\n\r\n## Expected behavior\r\n\r\nThe cuDF AST evaluator is expected to yield results consistent with those produced by the pandas evaluator.\r\n\r\nSee: \r\n```\r\n>>> df.eval(\"(p_brand == 'Brand#23' or p_container == 'MED BOX') or (l_quantity < ps_supplycost)\").value_counts()\r\nTrue     4\r\nFalse     2\r\ndtype: int64\r\n\r\n>>> gdf = cudf.from_pandas(df)\r\n>>> gdf.eval(\"(p_brand == 'Brand#23' or p_container == 'MED BOX') or (l_quantity < ps_supplycost)\").value_counts()\r\nTrue     3\r\nFalse     1\r\ndtype: int32\r\n\r\n>>> df[ ((df['p_brand'] == 'Brand#23') | (df['p_container'] == 'MED BOX')) | (df['l_quantity'] < df['ps_supplycost']) ]\r\n    p_brand p_container  l_linenumber  l_quantity  ps_supplycost  ps_availqty  l_extendedprice\r\n1  Brand#53     MED BOX           NaN         NaN           3.98       1646.0         23333.44\r\n2  Brand#41    WRAP BAG           1.0         8.0         763.34       3547.0         14687.36\r\n4  Brand#42    WRAP PKG           3.0        31.0         778.19       3849.0         33608.96\r\n5  Brand#23      LG JAR           4.0        43.0         101.93       4592.0         50407.61\r\n>>> gdf[ ((gdf['p_brand'] == 'Brand#23') | (gdf['p_container'] == 'MED BOX')) | (gdf['l_quantity'] < gdf['ps_supplycost']) ]\r\n    p_brand p_container  l_linenumber  l_quantity  ps_supplycost  ps_availqty  l_extendedprice\r\n2  Brand#41    WRAP BAG           1.0         8.0         763.34       3547.0         14687.36\r\n4  Brand#42    WRAP PKG           3.0        31.0         778.19       3849.0         33608.96\r\n5  Brand#23      LG JAR           4.0        43.0         101.93       4592.0         50407.61\r\n>>>\r\n```\r\n\r\n\r\nEnvironment overview  \r\n\r\nEnvironment location: conda\r\nMethod of cuDF install: conda\r\nbranch-23.10, origin/branch-23.10","closed":false,"closedAt":null,"comments":[{"id":"IC_kwDOBWUGps5q4-yp","author":{"login":"kkraus14"},"authorAssociation":"COLLABORATOR","body":"If we wanted to match Pandas behavior here it looks like it should be using `NULL_LOGICAL_OR` and `NULL_LOGICAL_AND` instead of `LOGICAL_OR` and `LOGICAL_AND`","createdAt":"2023-11-04T03:22:49Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[{"content":"THUMBS_UP","users":{"totalCount":1}}],"url":"https://github.com/rapidsai/cudf/issues/14361#issuecomment-1793322153","viewerDidAuthor":false},{"id":"IC_kwDOBWUGps5sbwRt","author":{"login":"wence-"},"authorAssociation":"CONTRIBUTOR","body":"There are two issues here:\r\n\r\n1. `cudf.from_pandas` maps nans to nulls by default: if you run `gdf = cudf.from_pandas(df, nan_as_null=False)` then you get the same results as pandas.\r\n2. NULL handling differences between cudf and pandas\r\n\r\n(1) is a footgun that I don't really know how best to square.\r\n\r\nNote that if you use pandas _nullable_ dtypes, the value_counts result is `[4, 1]` (not `[4, 2]`) since the first row is neither true nor false.\r\n\r\nFor (2), the operators `or`, `and`, and `~` are _bitwise_, not logical (so both the existing code and @kkraus14's suggestion would produce the wrong answer):\r\n```\r\nIn [89]: df = pd.DataFrame({\"s\": [5, 6, 7], \"y\": [12, 12, 12]})\r\n\r\nIn [90]: df.eval(\"s or y\")\r\nOut[90]: \r\n0    13\r\n1    14\r\n2    15\r\ndtype: int64\r\n```\r\n\r\nSupposing we fixed that, we need to special-case bitwise ops between two boolean columns :( when they contain nulls. Specifically (and this translates to the series case):\r\n\r\n```\r\nl = pd.Series([False, True], dtype=\"bool\")\r\nr = pd.Series([pd.NA, pd.NA], dtype=\"boolean\") # nullable bool column\r\nl | r\r\n# 0    <NA>\r\n# 1    True\r\n# dtype: boolean\r\n\r\n# Whereas\r\nl.astype(\"Int32\") | r\r\n0    <NA>\r\n1    <NA>\r\ndtype: boolean\r\n\r\n# Or\r\nl | r.astype(\"Int32\")\r\n0    <NA>\r\n1    <NA>\r\ndtype: boolean\r\n```","createdAt":"2023-11-20T14:52:33Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/14361#issuecomment-1819214957","viewerDidAuthor":false},{"id":"IC_kwDOBWUGps5upRIF","author":{"login":"GregoryKimball"},"authorAssociation":"CONTRIBUTOR","body":"Thank you @wence- for analyzing this. \r\n\r\n1) for Nan/null handling in pandas, do you think pandas 2.0 (or beyond) will improve the user experience with cudf?\r\n\r\n2) Do you think the operators `or`, `and`, and `~` should be logical instead of bitwise in cudf?","createdAt":"2023-12-14T17:43:54Z","includesCreatedEdit":true,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/14361#issuecomment-1856311813","viewerDidAuthor":false},{"id":"IC_kwDOBWUGps5upTSX","author":{"login":"wence-"},"authorAssociation":"CONTRIBUTOR","body":"wrt 1, I am not sure what the putative future default handling of nan/null is in pandas\r\n\r\nwrt 2: currently cudf (for reasonable reasons) dispatches `and`/`or` to logical and/or and `~`/`&` to bitwise and/or. This differs from the pandas semantics which _always_ dispatch to bitwise and/or. I think the way to fix this is to run a type-inference pass on the parsed AST expression and then we can figure out what to dispatch to on the backend. This can be done walking over the Python AST but it is a bit messy. The reason currently cudf handles and/or separately from ~/& is because in the backend libcudf AST code we need to emit different operators for those cases. Without type inference we don't know what to do.","createdAt":"2023-12-14T17:50:17Z","includesCreatedEdit":true,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/14361#issuecomment-1856320663","viewerDidAuthor":false}],"createdAt":"2023-11-04T00:47:47Z","id":"I_kwDOBWUGps511-oO","labels":[{"id":"MDU6TGFiZWw1OTk2MjY1NTk=","name":"bug","description":"Something isn't working","color":"d73a4a"},{"id":"MDU6TGFiZWwxMDEzOTg3MzUy","name":"0 - Backlog","description":"In queue waiting for assignment","color":"d4c5f9"},{"id":"MDU6TGFiZWwxMTM5NzQxMjEz","name":"cuDF (Python)","description":"Affects Python cuDF API.","color":"1d76db"}],"milestone":null,"number":14361,"projectCards":[],"projectItems":[],"reactionGroups":[],"state":"OPEN","title":"[BUG] Inconsistent Results Between AST and Pandas Evaluators for Expressions with Nullable Columns","updatedAt":"2023-12-14T17:53:53Z","url":"https://github.com/rapidsai/cudf/issues/14361"}

{"assignees":[],"author":{"id":"MDQ6VXNlcjExMjY1Mw==","is_bot":false,"login":"mattf","name":"Matthew Farrellee"},"body":"**Describe the bug**\r\nusing `import cudf as pd`\r\n\r\n**Steps/Code to reproduce bug**\r\n```\r\nIn [1]: import cudf as pd\r\n\r\nIn [2]: pd.__version__\r\nOut[2]: '22.12.00'\r\n\r\nIn [3]: df = pd.DataFrame({\"A\": [\"foo\", \"foo\", \"foo\", \"foo\", \"foo\",\r\n   ...:                          \"bar\", \"bar\", \"bar\", \"bar\"],\r\n   ...:                    \"B\": [\"one\", \"one\", \"one\", \"two\", \"two\",\r\n   ...:                          \"one\", \"one\", \"two\", \"two\"],\r\n   ...:                    \"C\": [\"small\", \"large\", \"large\", \"small\",\r\n   ...:                          \"small\", \"large\", \"small\", \"small\",\r\n   ...:                          \"large\"],\r\n   ...:                    \"D\": [1, 2, 2, 3, 3, 4, 5, 6, 7],\r\n   ...:                    \"E\": [2, 4, 5, 5, 6, 6, 8, 9, 9]})\r\n\r\nIn [4]: df.query(\"D > 5 & E > 5\")\r\nOut[4]: \r\nEmpty DataFrame\r\nColumns: [A, B, C, D, E]\r\nIndex: []\r\n\r\nIn [5]: df.to_pandas().query(\"D > 5 & E > 5\")\r\nOut[5]: \r\n     A    B      C  D  E\r\n7  bar  two  small  6  9\r\n8  bar  two  large  7  9\r\n\r\nIn [6]: df.query(\"D > 5 | E > 5\")\r\nOut[6]: \r\nEmpty DataFrame\r\nColumns: [A, B, C, D, E]\r\nIndex: []\r\n\r\nIn [7]: df.to_pandas().query(\"D > 5 | E > 5\")\r\nOut[7]: \r\n     A    B      C  D  E\r\n4  foo  two  small  3  6\r\n5  bar  one  large  4  6\r\n6  bar  one  small  5  8\r\n7  bar  two  small  6  9\r\n8  bar  two  large  7  9\r\n```","closed":false,"closedAt":null,"comments":[{"id":"IC_kwDOBWUGps5eDGFa","author":{"login":"GregoryKimball"},"authorAssociation":"CONTRIBUTOR","body":"I'm considering closing this as an issue where we do not want to match pandas.\r\n\r\nWe support these correctly:\r\n`df.query(\"(D > 5) & (E > 5)\")`, with parentheses\r\n`df.query(\"D > 5 and E > 5\")`, with \"and\" \r\n`df.query(\"D > 5 & E > 5\")`, IMO should not be considered as valid...\r\n\r\n","createdAt":"2023-06-06T04:03:13Z","includesCreatedEdit":true,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/12568#issuecomment-1577869658","viewerDidAuthor":false},{"id":"IC_kwDOBWUGps5-P6dX","author":{"login":"vyasr"},"authorAssociation":"CONTRIBUTOR","body":"This issue here is, I think, similar to [what we document for `eval`](https://github.com/rapidsai/cudf/blob/d10b8e4c9b437377cb6d231873e8f0fe9f8dc817/python/cudf/cudf/core/dataframe.py#L7684) where the meaning of the operators is type dependent. In this case, considering the following:\r\n```\r\nIn [114]: np.bitwise_and(df[\"D\"], df[\"E\"])\r\nOut[114]:\r\n0    0\r\n1    0\r\n2    0\r\n3    1\r\n4    2\r\n5    4\r\n6    0\r\n7    0\r\n8    1\r\ndtype: int64\r\n\r\nIn [115]: df.query(\"(D & E) > 1\")\r\nOut[115]:\r\n     A    B      C  D  E\r\n4  foo  two  small  3  6\r\n5  bar  one  large  4  6\r\n```\r\nHere `&` is clearly being treated as a bitwise operator because the logical and would be empty (it can only return 0 or 1, so no rows would be >1). However, [Python operator precedence rules](https://docs.python.org/3/reference/expressions.html#operator-precedence) clearly state that `&` is higher precedence than `>`, which in turn is higher precedence than `and`. By that logic, \r\n```\r\ndf.query(\"D > 5 & E > 5\")\r\n```\r\nShould be interpreted as\r\n```\r\ndf.query(\"D > (5 & E) > 5\")\r\n```\r\nwhich is obviously nonsensical. The only way to produce the observed pandas result is if this is being interpreted as \r\n```\r\ndf.query(\"(D > 5) and (E > 5)\")\r\n```\r\nI would consider both this and the behavior of eval in this kind of situation to be bugs in pandas, which should treat these Python operators as they would be treated in pure Python code and follow the expected conventions.\r\n\r\n@mroeschke WDYT?","createdAt":"2024-05-17T17:39:42Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/12568#issuecomment-2118100823","viewerDidAuthor":false},{"id":"IC_kwDOBWUGps5-Q5Ro","author":{"login":"mroeschke"},"authorAssociation":"CONTRIBUTOR","body":"In the pandas docs, it does state that `eval` (which executes `query`) makes bitwise and boolean operators have the same precedence with it's default `\"pandas\"` engine. There does exist a `\"python\"` engine that should make these operators have the expected language precedence rules\r\n\r\nhttps://pandas.pydata.org/docs/user_guide/enhancingperf.html#pandas-eval-parsers\r\nhttps://pandas.pydata.org/docs/reference/api/pandas.eval.html#pandas.eval","createdAt":"2024-05-17T20:42:41Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/12568#issuecomment-2118358120","viewerDidAuthor":false},{"id":"IC_kwDOBWUGps5-cS3i","author":{"login":"vyasr"},"authorAssociation":"CONTRIBUTOR","body":"Oh good call, I didn't consider the behavior of the different engines. This distinction is potentially problematic for cudf.pandas users. What we should consider doing is adding support for the engine keyword in cudf, but have the default value be \"python\" when using cudf directly and have it be \"pandas\" when cudf.pandas is active. We should raise an exception if the mode is anything other than \"python\". That way, cudf's default behavior is to match the python engine and it works out of the box, whereas with cudf.pandas (perhaps whenever the pandas-compatible option is set, depending on how we configure this; we could also monkey-patch) the default behavior is to use the nonexistent \"pandas\" engine, which triggers an exception and then falls back to pandas. That way users only get the speedup if they specify a python engine. It's a bit unfortunate since I imagine that most users don't specify an engine, but the only immediate alternative is giving users unexpected results. The other option is to actually implement the other semantics, of course, but I don't know if we can prioritize that anytime soon.","createdAt":"2024-05-20T22:52:45Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/12568#issuecomment-2121346530","viewerDidAuthor":false}],"createdAt":"2023-01-18T17:50:38Z","id":"I_kwDOBWUGps5bsmUg","labels":[{"id":"MDU6TGFiZWw1OTk2MjY1NTk=","name":"bug","description":"Something isn't working","color":"d73a4a"},{"id":"MDU6TGFiZWwxMDEzOTg3MzUy","name":"0 - Backlog","description":"In queue waiting for assignment","color":"d4c5f9"},{"id":"MDU6TGFiZWwxMTM5NzQxMjEz","name":"cuDF (Python)","description":"Affects Python cuDF API.","color":"1d76db"}],"milestone":{"number":5,"title":"Pandas API Alignment and Coverage","description":"","dueOn":null},"number":12568,"projectCards":[{"project":{"name":"Bug Squashing"},"column":{"name":"Needs prioritizing"}}],"projectItems":[],"reactionGroups":[],"state":"OPEN","title":"[BUG] DataFrame.query binary-ops do not match pandas","updatedAt":"2024-05-20T22:52:45Z","url":"https://github.com/rapidsai/cudf/issues/12568"}

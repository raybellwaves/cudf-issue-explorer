{"assignees":[{"id":"MDQ6VXNlcjM2MDI3NDAz","login":"codereport","name":"Conor Hoekstra"}],"author":{"id":"MDQ6VXNlcjM0NDEzMjE=","is_bot":false,"login":"revans2","name":"Robert (Bobby) Evans"},"body":"**Describe the bug**\r\nWe have code to check if casting a Decimal to a long will overflow. The default code creates an INT64 scalar value with the min long value in it, and another with the max long value in it.  Then it uses binary ops like LESS, GREATER, LESS_EQUAL, and GREATER_EQUAL to see if the values are within the given range. This works generally great for bytes, shorts and ints, but for longs (INT64) it always comes back as true.  The values are in the desired range. I have to explicitly create a decimal scalar with a corresponding scale to make this check work. My guess is that both values are being cast to an INT64 before doing the comparison and the result by definition cannot be outside the range of those values.","closed":false,"closedAt":null,"comments":[{"id":"IC_kwDOBWUGps43L7j-","author":{"login":"jrhemstad"},"authorAssociation":"CONTRIBUTOR","body":"I'm not quite following what you mean. Can you give an example (just numbers, not code) of what you mean? ","createdAt":"2021-09-23T14:34:38Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/9282#issuecomment-925874430","viewerDidAuthor":false},{"id":"IC_kwDOBWUGps43MrR1","author":{"login":"revans2"},"authorAssociation":"CONTRIBUTOR","body":"@jrhemstad\r\n\r\nI have a DECIMAL64 value that is larger than can fit in an INT64.  A value of '999999999999999999' with scale 3 for example which is the equivalent of `999999999999999999000`.  Then I create a Scalar of INT64 with a value of `9223372036854775807` (`Long.MaxValue`). I ask cudf if my DECIMAL column > my INT64 scalar, logically it should say yes the decimal value is larger than the INT64 value, but cudf says false.  My guess is that cudf is casting the decimal to an INT64 first.  There is no int64 value that is > `Long.MaxValue`, so it will always return true.  This looks to be essentially the same kind of issue as was in the casting bug I filed, just in a separate place.","createdAt":"2021-09-23T18:52:47Z","includesCreatedEdit":true,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/9282#issuecomment-926069877","viewerDidAuthor":false},{"id":"IC_kwDOBWUGps43Mual","author":{"login":"jrhemstad"},"authorAssociation":"CONTRIBUTOR","body":"Aha, that makes sense. Thanks. ","createdAt":"2021-09-23T19:11:41Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/9282#issuecomment-926082725","viewerDidAuthor":false},{"id":"IC_kwDOBWUGps43MueP","author":{"login":"jrhemstad"},"authorAssociation":"CONTRIBUTOR","body":"@codereport this sounds like a similar kind of problem? ","createdAt":"2021-09-23T19:12:04Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/9282#issuecomment-926082959","viewerDidAuthor":false},{"id":"IC_kwDOBWUGps43NP2H","author":{"login":"codereport"},"authorAssociation":"CONTRIBUTOR","body":"> @codereport this sounds like a similar kind of problem?\r\n\r\nThis doesn't sound like the same thing. \r\n\r\n1. Comparing `INT64` and `Deimcal64` should not be possible\r\n2. The correct way to do this is casting the `INT64` to `Decimal64` and then compare (ideally in the scale of the `Decimal64` number you are comparing it to)\r\n3. If you only converted it to scale 0, I would expect the `Decimal64` number to potentially overflow, because the comparison operators are implemented using rescaling, similar to this:\r\n```cpp\r\n  auto const scale = std::min(lhs._scale, rhs._scale);\r\n  return lhs.rescaled(scale)._value < rhs.rescaled(scale)._value;\r\n```\r\n\r\n**Note:** If you are currently able to compare `int64_t` with `decimal64` in libcudf, that might be a bug. While working on another job, I noticed that the compiled binary ops didn't have the same checks as the jit binary ops. I have fixed that in my other PR, but I haven't checked if that was introduced in my PR or in main.","createdAt":"2021-09-23T22:54:46Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/9282#issuecomment-926219655","viewerDidAuthor":false},{"id":"IC_kwDOBWUGps43NtTq","author":{"login":"jrhemstad"},"authorAssociation":"CONTRIBUTOR","body":"Hm, yeah, if the decimal64 number represents a value larger than INT64_MAX, how would you compare it to an int64? \r\n\r\nA quick and dirty way to do Bobby's check would be to convert the decimal64 to a `double` and then doing the comparison. You might get some weird effects due to the spacing between representable integers gets pretty far apart at that scale... I'm not sure if this would cause false negatives or false positives.  ","createdAt":"2021-09-24T04:44:43Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/9282#issuecomment-926340330","viewerDidAuthor":false},{"id":"IC_kwDOBWUGps43Nu1b","author":{"login":"jrhemstad"},"authorAssociation":"CONTRIBUTOR","body":"> The correct way to do this is casting the INT64 to Decimal64 and then compare\r\n\r\nOh, right, this would work. So if you have `9223372036854775807`, you can create a `decimal64` with scale 3 to get the logical value `9223372036854775807000`. Then you can compare that against `999999999999999999000`. Since they have the same scale, it won't need to rescale either value and will just compare the rep between the two. \r\n\r\nCan't we do this automatically for binops? i.e., construct a decimal64 value around the integer value with the same scale as the other decimal value? This would essentially be like implicit conversion for an integer when comparing against a float. \r\n\r\nIn fact, can't we just add an overload for `operator<(fixed_point, integer)`? Am I missing a situation where this would be unsafe? ","createdAt":"2021-09-24T04:56:53Z","includesCreatedEdit":true,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/9282#issuecomment-926346587","viewerDidAuthor":false},{"id":"IC_kwDOBWUGps43Ox_4","author":{"login":"revans2"},"authorAssociation":"CONTRIBUTOR","body":"> The correct way to do this is casting the INT64 to Decimal64 and then compare\r\n\r\nThat is what I did as a work round in the Spark code.","createdAt":"2021-09-24T13:23:42Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[{"content":"THUMBS_UP","users":{"totalCount":1}}],"url":"https://github.com/rapidsai/cudf/issues/9282#issuecomment-926621688","viewerDidAuthor":false},{"id":"IC_kwDOBWUGps43O2V1","author":{"login":"revans2"},"authorAssociation":"CONTRIBUTOR","body":"> Am I missing a situation where this would be unsafe?\r\n\r\nThe first problem would show up for equality. `9223372036854775807` != `9223372036854775000` but if you automatically cast `9223372036854775807` to a DECIMAL64 with scale 3 you have lost some data and now it looks like they are equal. I think you can work around it and detect that you lost information when doing the cast to a decimal, and then always say that they are not equal.\r\n\r\nThe second issue would be with how you round.\r\n\r\nFor example: \r\n\r\nLONG `9223372036854775807` < DEC `9223372036854776000`\r\n\r\nI would want to round the LONG towards 0 to get the right answer. But if I switch it (and adjust the DEC value so it shows the problem).\r\n\r\nDEC `9223372036854775000` < LONG `9223372036854775807`\r\n\r\nNow I want to round away from 0 for the long to give me the correct answer on the comparison.\r\n\r\nI think that is correct.  Might need to play with some negative value examples to be sure that my rounding is spot on.","createdAt":"2021-09-24T13:48:51Z","includesCreatedEdit":true,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/9282#issuecomment-926639477","viewerDidAuthor":false},{"id":"IC_kwDOBWUGps43O22O","author":{"login":"codereport"},"authorAssociation":"CONTRIBUTOR","body":"@jrhemstad \r\n> Oh, right, this would work. So if you have 9223372036854775807, you can create a decimal64 with scale 3 to get the logical value 9223372036854775807000. Then you can compare that against 999999999999999999000. Since they have the same scale, it won't need to rescale either value and will just compare the rep between the two.\r\n\r\nThis is correct, however, to be specific your value of `9223372036854775807000` is `9223372036854775807 * 1000` whereas the actual value will be `9223372036854775807 / 1000` and then `9223372036854775` is stored and it represents `9223372036854775000`.\r\n\r\n> Can't we do this automatically for binops? i.e., construct a decimal64 value around the integer value with the same scale as the other decimal value? This would essentially be like implicit conversion for an integer when comparing against a float.\r\n\r\nWe could do this automatically. It is worth discussing though. I don't think we would want to auto-construct same-scale values when multiplying or adding - which means that the behaviour would be custom depending on the binary operation.\r\n\r\n> In fact, can't we just add an overload for operator<(fixed_point, integer)? Am I missing a situation where this would be unsafe?\r\n\r\nNo, it isn't this simple. The `fixed_point` `operator<` is not what is invoked during a binary op. It would be a change somewhere else in the compiled binary_ops code.","createdAt":"2021-09-24T13:51:37Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/9282#issuecomment-926641550","viewerDidAuthor":false},{"id":"IC_kwDOBWUGps43O5tN","author":{"login":"codereport"},"authorAssociation":"CONTRIBUTOR","body":"@revans2 \r\n\r\n> I think you can work around it and detect that you lost information when doing the cast to a decimal, and then always say that they are not equal.\r\n\r\nYea, I think it is possible for most case to construct to a scale n-1 and then do a `cudf::round`\r\n\r\n> The second issue would be with how you round.\r\n> DEC 9223372036854775000 < LONG 9223372036854775807\r\n\r\n:arrow_up: this is the way it happens whenever `decimal` construction happens, truncation. This is the way CNL works and at one point we had rounding but it was decided to always truncate because of the complexity that it adds.","createdAt":"2021-09-24T14:06:04Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/9282#issuecomment-926653261","viewerDidAuthor":false},{"id":"IC_kwDOBWUGps43PAu-","author":{"login":"revans2"},"authorAssociation":"CONTRIBUTOR","body":"I get why you don't want the added complexity of round when constructing a decimal by default. But in this case we would probably want to construct the decimal with a scale of 0, and then explicitly round it to the appropriate scale using the correct rounding method based off of the operation being performed, along with all of the other gotchas involved with this type of an operation. There is a lot of very specific things that would need to be done correctly to make these comparison operations work correctly and generically. So I totally understand if the result of this BUG is simply CUDF does not support this type of operation and possibly some documentation why.","createdAt":"2021-09-24T14:41:22Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/9282#issuecomment-926682046","viewerDidAuthor":false},{"id":"IC_kwDOBWUGps45xp-P","author":{"login":"github-actions"},"authorAssociation":"NONE","body":"This issue has been labeled `inactive-30d` due to no recent activity in the past 30 days. Please close this issue if no further response or action is needed. Otherwise, please respond with a comment indicating any updates or changes to the original issue and/or confirm this issue still needs to be addressed. This issue will be labeled `inactive-90d` if there is no activity in the next 60 days.","createdAt":"2021-11-15T21:03:23Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/9282#issuecomment-969318287","viewerDidAuthor":false},{"id":"IC_kwDOBWUGps495X0O","author":{"login":"github-actions"},"authorAssociation":"NONE","body":"This issue has been labeled `inactive-90d` due to no recent activity in the past 90 days. Please close this issue if no further response or action is needed. Otherwise, please respond with a comment indicating any updates or changes to the original issue and/or confirm this issue still needs to be addressed.","createdAt":"2022-02-13T22:03:10Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/9282#issuecomment-1038449934","viewerDidAuthor":false}],"createdAt":"2021-09-23T13:44:29Z","id":"I_kwDOBWUGps477gTY","labels":[{"id":"MDU6TGFiZWw1OTk2MjY1NTk=","name":"bug","description":"Something isn't working","color":"d73a4a"},{"id":"MDU6TGFiZWwxMTM5NzQwNjY2","name":"libcudf","description":"Affects libcudf (C++/CUDA) code.","color":"c5def5"}],"milestone":{"number":3,"title":"Decimal data type and operations","description":"","dueOn":null},"number":9282,"projectCards":[{"project":{"name":"Bug Squashing"},"column":{"name":"Needs prioritizing"}}],"projectItems":[],"reactionGroups":[],"state":"OPEN","title":"[BUG] Comparing decimal values with positive scale to MAX LONG or MIN LONG produces incorrect results","updatedAt":"2022-11-21T04:13:55Z","url":"https://github.com/rapidsai/cudf/issues/9282"}

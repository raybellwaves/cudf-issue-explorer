{"assignees":[],"author":{"id":"MDQ6VXNlcjE1MjIxMjg5","is_bot":false,"login":"jrhemstad","name":"Jake Hemstad"},"body":"**Is your feature request related to a problem? Please describe.**\r\n\r\nThe new experimental row operators require non-trivial preprocessing that involves new allocations whose lifetime must be maintained while attempting to do any row-wise operations on the specified data. \r\n\r\nTo manage this, we introduced owning and non-owning comparator types.\r\n\r\nFor example, `self_comparator` is an owning type that handles doing row-wise operations on a single table. \r\n\r\n`self_comparator` is not a binary callable object (it doesn't have an `operator()`). Creating the actual non-owning callable object is currently done through a member factory function of the owning type (renamed in https://github.com/rapidsai/cudf/pull/10870).\r\n\r\n```\r\ntable_view input_table{...};\r\nself_comparator s{input_table}; // \"Expensive\" construction that does necessary pre-processing and allocations\r\nauto callable = s.less(); // \"Cheap\" factory that returns a binary callable suitable for passing to algorithms like thrust::sort\r\nthrust::sort(..., callable);\r\n```\r\nAfter reviewing code using this functionality I've noticed that the callable being returned from a member of the owning type is a bit awkward. For instance the `s.less()` call above isn't immediately obvious that this is actually a factory returning a callable function object. One way to remedy that could be to call it `s.make_less()` instead, but I think there's an all together better way. \r\n\r\n**Describe the solution you'd like**\r\nInspired by `std::` function objects like `std::less/std::equal_to`, I think we should make the callable objects currently being returned from functions like `less()/less_equivalent()/equal_to()` to instead be freestanding types that are _constructible from_ the owning types instead of being returned from a factory of the owning type. \r\n\r\nI think this would simplify the owning type as well as make the owner/viewer relationship more clear and explicit.\r\n\r\nFor example, the code above would become:\r\n```\r\ntable_view input_table{...};\r\nself_comparator s{input_table}; // \"Expensive\" construction that does necessary pre-processing and allocations\r\nauto callable = cudf::row::less{s}; // \"Cheap\" construction that _views_ the internals of self_comparator\r\nthrust::sort(..., callable);\r\n```\r\n\r\nHere's a high level sketch of how this idea could be implemented: https://godbolt.org/z/5fbK7PTb6\r\n\r\nSalient points:\r\n- `less` is a standalone type constructible from the `owning` type\r\n- `less` is a `friend` of the owning type to access internals\r\n- `less` deletes constructions from an r-value ref of the owning type to prevent construction from a temporary of the owning type. If allowed, this would lead to dangling references. \r\n- For simplicity, this sketch has `less::operator()` just invoke the `PhysicalComparator`. The actual implementation would have more layers. It would be roughly equivalent to what the internals of the `self_comparator::less` factory above does today. \r\n\r\n\r\n**Additional Thoughts**\r\n\r\nI've come to believe that \"comparator\" is probably an inappropriate name for the owning types. It's not a comparator (not invokable), it just preprocesses and holds data needed by the actual comparators.\r\n\r\nI don't have a good suggestion for a different name yet. ","closed":false,"closedAt":null,"comments":[{"id":"IC_kwDOBWUGps5ET8tC","author":{"login":"jrhemstad"},"authorAssociation":"CONTRIBUTOR","body":"@bdice @rwlee @devavret ","createdAt":"2022-06-03T15:31:05Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/11040#issuecomment-1146080066","viewerDidAuthor":false},{"id":"IC_kwDOBWUGps5EULmH","author":{"login":"jrhemstad"},"authorAssociation":"CONTRIBUTOR","body":"Staring at this some more and thinking about names for the \"owning\" comparators I realized that there is effectively no reason for them to exist. \r\n\r\nOnce you make the callables freestanding types, the only purpose of the owning comparators is to add the minor convenience of not needing to construct the preprocessed tables yourself. Otherwise we can eliminate them entirely. \r\n\r\n```\r\n// self\r\ntable_view input_table{...};\r\npreprocessed_table processed_input{input_table}; // \"Expensive\" construction that does necessary pre-processing and allocations\r\nauto callable = cudf::row::self::less{p}; // \"Cheap\" construction that _views_ the internals of the preprocessed table\r\nthrust::sort(..., callable);\r\n...\r\n// two table\r\ntable_view lhs{...};\r\ntable_view rhs{...};\r\nauto lhs_processed = preprocessed_table{lhs};\r\nauto rhs_processed = preprocessed_table{rhs};\r\nauto callable = cudf::row::two::less{lhs_processed, rhs_processed};\r\nthrust::merge(..., callable);\r\n```\r\n\r\nI have an idea of how we can get rid of needing to be explicit about `self` vs `two_table` as well that I need to explore some more. \r\n","createdAt":"2022-06-03T16:11:20Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/11040#issuecomment-1146141063","viewerDidAuthor":false},{"id":"IC_kwDOBWUGps5EUN-K","author":{"login":"devavret"},"authorAssociation":"CONTRIBUTOR","body":"> Staring at this some more and thinking about names for the \"owning\" comparators I realized that there is effectively no reason for them to exist.\n\nThis is how I was thinking of designing this originally. ","createdAt":"2022-06-03T16:23:34Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/11040#issuecomment-1146150794","viewerDidAuthor":false},{"id":"IC_kwDOBWUGps5EUOr9","author":{"login":"ttnghia"},"authorAssociation":"CONTRIBUTOR","body":"I would prefer some other term like `comparator_builder` for the owning ones. So you create just one builder that provides any type of comparator that you need later on, or even to share its preprocessed data.","createdAt":"2022-06-03T16:27:15Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/11040#issuecomment-1146153725","viewerDidAuthor":false},{"id":"IC_kwDOBWUGps5EUPgQ","author":{"login":"jrhemstad"},"authorAssociation":"CONTRIBUTOR","body":"Alright, here's how we can get rid of the owning comparator types all together (obviously keeping the `preprocessed_table` owning type) _and_ get rid of the user-facing \"two-table\" vs \"self\" comparators.\r\n\r\nhttps://godbolt.org/z/fz1veocdc\r\n\r\nThe main idea is to just infer \"self\" vs \"two-table\" based on how many tables are passed to the `less` constructor. Using deduction guides we can steer these two situations to two different partial specializations of the `less` template. ","createdAt":"2022-06-03T16:31:23Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/11040#issuecomment-1146157072","viewerDidAuthor":false},{"id":"IC_kwDOBWUGps5EUVGn","author":{"login":"ttnghia"},"authorAssociation":"CONTRIBUTOR","body":"IMO, it looks more _natural_ to do it this way:\r\n```\r\nauto builder = ...;\r\nauto comp = builder.less(); // builder.equal();\r\n```\r\nthan doing this way:\r\n```\r\nauto  lhs = preprocessed_data{...}; // <= what data? why preprocessed?\r\nauto  rhs = preprocessed_data{...};\r\nauto comp = less{lhs, rhs};\r\n```\r\n\r\nMaybe I missed some key insight here?","createdAt":"2022-06-03T16:59:33Z","includesCreatedEdit":true,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/11040#issuecomment-1146180007","viewerDidAuthor":false},{"id":"IC_kwDOBWUGps5EUaZ7","author":{"login":"jrhemstad"},"authorAssociation":"CONTRIBUTOR","body":"Cuts both ways :) \r\n```\r\nauto builder = ...; //  what builder? Why build? \r\nauto comp = builder.less(); // less? Is this a predicate? builder is less than what? \r\n```\r\n\r\nFurthermore, the `preprocessed_data` was just a shorthand for the proof of concept. The real code would still keep the `preprocessed_table` nomenclature. \r\n```\r\ntable_view lhs, rhs;\r\nauto lhs_processed = preprocessed_table{lhs};\r\nauto rhs_processed = preprocessed_table{rhs};\r\nauto callable = less{lhs_processed, rhs_processed};\r\n```\r\n\r\nAlso, if you want to reuse the same preprocessed tables with a builder it becomes even more code:\r\n```\r\ntable_view lhs, rhs;\r\nauto lhs_processed = preprocessed_table{lhs};\r\nauto rhs_processed = preprocessed_table{rhs};\r\nauto builder = build{lhs_processed, rhs_processed};\r\nauto comp = builder.less();\r\n```\r\n\r\nAll the \"builder\" does is hide the construction of the `preprocessed_table` in some situations. That does provide some minor convenience, but imo not enough to make it worth all the extra code and complexity of providing the builder.\r\n\r\nAlso, with a \"builder\" it's not clear what it's lifetime requirements are. Is it owning? How long do I need to keep it alive?\r\n\r\nConstructing the `preprocessed_table` makes it explicit to the caller that this is an object that needs to be kept alive.","createdAt":"2022-06-03T17:28:02Z","includesCreatedEdit":true,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/11040#issuecomment-1146201723","viewerDidAuthor":false},{"id":"IC_kwDOBWUGps5F7Mek","author":{"login":"github-actions"},"authorAssociation":"NONE","body":"This issue has been labeled `inactive-30d` due to no recent activity in the past 30 days. Please close this issue if no further response or action is needed. Otherwise, please respond with a comment indicating any updates or changes to the original issue and/or confirm this issue still needs to be addressed. This issue will be labeled `inactive-90d` if there is no activity in the next 60 days.","createdAt":"2022-07-03T18:03:17Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/11040#issuecomment-1173145508","viewerDidAuthor":false},{"id":"IC_kwDOBWUGps5LXgt0","author":{"login":"github-actions"},"authorAssociation":"NONE","body":"This issue has been labeled `inactive-90d` due to no recent activity in the past 90 days. Please close this issue if no further response or action is needed. Otherwise, please respond with a comment indicating any updates or changes to the original issue and/or confirm this issue still needs to be addressed.","createdAt":"2022-10-01T19:04:27Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/11040#issuecomment-1264454516","viewerDidAuthor":false},{"id":"IC_kwDOBWUGps5MuFnn","author":{"login":"vyasr"},"authorAssociation":"CONTRIBUTOR","body":"One additional consideration that came up here during the implementation of the list lexicographic comparator is the need for separate code paths for when the compared tables contain nested data to avoid slowdowns of the non-nested data case due to the compiler's inability to sufficiently inline and optimize the complex code paths involving nested types. Whatever approach we take here will need to account for that as well.","createdAt":"2022-10-21T15:52:40Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/11040#issuecomment-1287150055","viewerDidAuthor":false}],"createdAt":"2022-06-03T15:24:33Z","id":"I_kwDOBWUGps5LGr4o","labels":[{"id":"MDU6TGFiZWw1OTk2MjY1NjE=","name":"feature request","description":"New feature or request","color":"a2eeef"},{"id":"MDU6TGFiZWwxMDEzOTg3OTIx","name":"proposal","description":"Change current process or code","color":"2a2c89"},{"id":"MDU6TGFiZWwxMTM5NzQwNjY2","name":"libcudf","description":"Affects libcudf (C++/CUDA) code.","color":"c5def5"}],"milestone":{"number":2,"title":"List and Struct data types and operations","description":"","dueOn":null},"number":11040,"projectCards":[],"projectItems":[],"reactionGroups":[],"state":"OPEN","title":"[FEA] Alternate design for owning/non-owning comparators ","updatedAt":"2024-02-23T18:42:32Z","url":"https://github.com/rapidsai/cudf/issues/11040"}

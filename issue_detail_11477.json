{"assignees":[{"id":"MDQ6VXNlcjEwNjQ3MDgy","login":"mroeschke","name":"Matthew Roeschke"},{"id":"MDQ6VXNlcjUzNzk2MDk5","login":"brandon-b-miller","name":""}],"author":{"id":"MDQ6VXNlcjUzNzk2MDk5","is_bot":false,"login":"brandon-b-miller","name":""},"body":"**Describe the bug**\r\nIn the cases described in the title, we are getting a `DataFrame` rather than a `Series` object like we should.\r\n\r\n\r\n**Steps/Code to reproduce bug**\r\n```python\r\n>>> df1 = cudf.DataFrame({\r\n...     'a': [1, 2, 3],\r\n...     'b': ['a', 'b', 'c']\r\n... })\r\n>>> df2 = cudf.DataFrame({\r\n...     'a': [1, 2, 3],\r\n...     'b': [4, 5, 6]\r\n... })\r\n>>> type(df1.iloc[0])\r\n<class 'cudf.core.dataframe.DataFrame'>\r\n>>> type(df2.iloc[0]) \r\n<class 'cudf.core.series.Series'>\r\n>>> type(df1.to_pandas().iloc[0])\r\n<class 'pandas.core.series.Series'>\r\n>>> type(df2.to_pandas().iloc[0])\r\n<class 'pandas.core.series.Series'>\r\n```\r\n\r\n**Expected behavior**\r\nWe should get the same object as pandas (a series)\r\n\r\n**Additional Information**\r\nBranch-22.10","closed":false,"closedAt":null,"comments":[{"id":"IC_kwDOBWUGps5Jr12H","author":{"login":"github-actions"},"authorAssociation":"NONE","body":"This issue has been labeled `inactive-30d` due to no recent activity in the past 30 days. Please close this issue if no further response or action is needed. Otherwise, please respond with a comment indicating any updates or changes to the original issue and/or confirm this issue still needs to be addressed. This issue will be labeled `inactive-90d` if there is no activity in the next 60 days.","createdAt":"2022-09-04T01:34:46Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/11477#issuecomment-1236229511","viewerDidAuthor":false},{"id":"IC_kwDOBWUGps5PUoeJ","author":{"login":"wence-"},"authorAssociation":"CONTRIBUTOR","body":"This is not possible because `Series` objects contain data of a single homogenous dtype. In this case (mixed string and numeric columns), the series that we want to get would contain heterogeneous dtypes, which is not supported. Pandas can happily store `object` arrays that really support heterogeneous dtypes so it is not a problem there.","createdAt":"2022-11-29T15:16:02Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/11477#issuecomment-1330808713","viewerDidAuthor":false},{"id":"IC_kwDOBWUGps5PguqX","author":{"login":"shwina"},"authorAssociation":"CONTRIBUTOR","body":"Should we {raise, warn, something_else}?","createdAt":"2022-12-01T15:53:58Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/11477#issuecomment-1333979799","viewerDidAuthor":false},{"id":"IC_kwDOBWUGps5PlJ2d","author":{"login":"wence-"},"authorAssociation":"CONTRIBUTOR","body":"I think we should never try and convert to a `Series`. That makes `.i?loc`-based indexing have consistent semantics in all cases, and try and convince pandas that that should also be the behaviour there. The isomorphism between a 1xN dataframe and length-N series in pandas is not really that strong anyway which is probably a cause of a bunch of special-casing.\r\n\r\ne.g.\r\n```python\r\nimport pandas as pd\r\ndf = pd.DataFrame({\"a\": [1, 2, 3, 4],\r\n                   \"b\": [1, 2, 1, 2],\r\n                   \"c\": [1, 1, 2, 2],\r\n                   \"d\": [1, 2, 3, 4]}, index=[\"e\", \"f\", \"g\", \"h\"])\r\n\r\nprint(df.loc[\"e\"][\"a\"] * df)    # single number is broadcast\r\n#    a  b  c  d\r\n# e  1  1  1  1\r\n# f  2  2  1  2\r\n# g  3  1  2  3\r\n# h  4  2  2  4\r\nprint(df.loc[[\"e\"]][\"a\"] * df)  # (1,) series is not aligned\r\n#     a   b   c   d   e\r\n# e NaN NaN NaN NaN NaN\r\n# f NaN NaN NaN NaN NaN\r\n# g NaN NaN NaN NaN NaN\r\n# h NaN NaN NaN NaN NaN\r\n\r\n```","createdAt":"2022-12-02T12:03:37Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/11477#issuecomment-1335139741","viewerDidAuthor":false},{"id":"IC_kwDOBWUGps5Plxpo","author":{"login":"brandon-b-miller"},"authorAssociation":"CONTRIBUTOR","body":"I'd agree with @wence- here over the long term and would rather see pandas always return a dataframe. As for what to do in the short term, there was a little discussion around raising in https://github.com/rapidsai/cudf/pull/11501 that I liked. For me, both the casting and the returning of inconsistent object types (that might fail downstream handling) are approximately equally bad problems.","createdAt":"2022-12-02T14:20:19Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/11477#issuecomment-1335302760","viewerDidAuthor":false},{"id":"IC_kwDOBWUGps5Pneuu","author":{"login":"vyasr"},"authorAssociation":"CONTRIBUTOR","body":"I concur with everything @wence- says. It's not just a question of the special-casing of the code, but also the fact that the relationship between a single-row DataFrame and a Series is pretty weak (much weaker than between a row vector and a column vector I would argue given the metadata associated with the tabular structure). I don't think it makes much of an improvement to the API, and it's certainly inconsistent with databases like SQL that have no concept of a Series and will just produce a table with a single row for such operations. It's also important to realize that indexing methods are just one of multiple cases where pandas DataFrame operations will return a Series if the operations reduces to a single row. Reductions are one other example, e.g. `df.mean`. We should try to get this changed by pandas, and not just in this particular case.\r\n\r\nFrom cudf's perspective I would also point out that the current behavior causes additional headaches due to the different memory layouts of DataFrame and Series, some of which can also lead to serious performance issues. One important case is when users want to do anything where the newly generated Series interacts with the original DataFrame. Consider something like `df[df == df.max()]`. This code is hiding an unexpected performance bottleneck. `max` will generate a Series where the index corresponds to the original column names. Since libcudf doesn't offer a way to create a scalar view into each element, the equality operator ends up requiring the creation of a new DeviceScalar (and therefore a new allocation + D2H2D transfer) for each element. \r\n\r\nCC @mroeschke ","createdAt":"2022-12-02T19:46:59Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/11477#issuecomment-1335749550","viewerDidAuthor":false},{"id":"IC_kwDOBWUGps5Pn89F","author":{"login":"mroeschke"},"authorAssociation":"CONTRIBUTOR","body":"pandas row indexing with a single element vs single element in a list (`.iloc[pos]` vs `.iloc[[pos]]`) was odd to me too when first encountering it, but I think overtime pandas has been trying to return a consistent object with respect to indexer type. Specifically centralizing around, \"a single list-like indexer should always return a DataFrame\"\r\n\r\n```\r\nIn [7]: import pandas as pd\r\n   ...: df = pd.DataFrame({\"a\": [1, 2, 3, 4],\r\n   ...:                    \"b\": [1, 2, 1, 2],\r\n   ...:                    \"c\": [1, 1, 2, 2],\r\n   ...:                    \"d\": [1, 2, 3, 4]}, index=[\"e\", \"f\", \"g\", \"h\"])\r\n\r\nIn [8]: df.loc[[\"e\"]]\r\nOut[8]:\r\n   a  b  c  d\r\ne  1  1  1  1\r\n\r\nIn [9]: df.loc[[]]\r\nOut[9]:\r\nEmpty DataFrame\r\nColumns: [a, b, c, d]\r\nIndex: []\r\n\r\nIn [10]: df.iloc[[0]]\r\nOut[10]:\r\n   a  b  c  d\r\ne  1  1  1  1\r\n\r\nIn [11]: df.iloc[[]]\r\nOut[11]:\r\nEmpty DataFrame\r\nColumns: [a, b, c, d]\r\nIndex: []\r\n```","createdAt":"2022-12-02T21:45:42Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/11477#issuecomment-1335873349","viewerDidAuthor":false},{"id":"IC_kwDOBWUGps5Xmr38","author":{"login":"wence-"},"authorAssociation":"CONTRIBUTOR","body":"> pandas row indexing with a single element vs single element in a list (`.iloc[pos]` vs `.iloc[[pos]]`) was odd to me too when first encountering it, but I think overtime pandas has been trying to return a consistent object with respect to indexer type. Specifically centralizing around, \"a single list-like indexer should always return a DataFrame\"\r\n> \r\n> ```\r\n> In [7]: import pandas as pd\r\n>    ...: df = pd.DataFrame({\"a\": [1, 2, 3, 4],\r\n>    ...:                    \"b\": [1, 2, 1, 2],\r\n>    ...:                    \"c\": [1, 1, 2, 2],\r\n>    ...:                    \"d\": [1, 2, 3, 4]}, index=[\"e\", \"f\", \"g\", \"h\"])\r\n> \r\n> In [8]: df.loc[[\"e\"]]\r\n> Out[8]:\r\n>    a  b  c  d\r\n> e  1  1  1  1\r\n> \r\n> In [9]: df.loc[[]]\r\n> Out[9]:\r\n> Empty DataFrame\r\n> Columns: [a, b, c, d]\r\n> Index: []\r\n> \r\n> In [10]: df.iloc[[0]]\r\n> Out[10]:\r\n>    a  b  c  d\r\n> e  1  1  1  1\r\n> \r\n> In [11]: df.iloc[[]]\r\n> Out[11]:\r\n> Empty DataFrame\r\n> Columns: [a, b, c, d]\r\n> Index: []\r\n> ```\r\n\r\nJust to follow up here, because I'm thinking about this again. The inconsistency is not when providing a singleton list index entry, but rather a singleton index entry:\r\n\r\nCompare:\r\n\r\n```python\r\nimport pandas as pd\r\ndf = pd.DataFrame({\"a\": [1, 2, 3], \"b\": [1, 2, 3]}, index=[\"c\", \"d\"]})\r\n\r\ndf.loc[[\"c\"]] # => dataframe\r\ndf.loc[\"c\"] # => series\r\n```\r\nIf trying to standardise on pyarrow datatypes rather than python ones in pandas, this will cause the same problems as @brandon-b-miller notes in the initial issue. When the columns of your dataframe have mixed types it's not possible to take a row and turn it into a series of homogenous type.\r\n\r\nI realise it's rather late in the day, but do you think it is worth trying to make a change to these indexing semantics in pandas 2? (@mroeschke)","createdAt":"2023-03-15T10:36:55Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/11477#issuecomment-1469758972","viewerDidAuthor":false},{"id":"IC_kwDOBWUGps5XpM8y","author":{"login":"mroeschke"},"authorAssociation":"CONTRIBUTOR","body":"Looks like currently pandas will fall back to object dtype if indexing a row of mixed pyarrow types\r\n\r\n```\r\nIn [1]: df = pd.DataFrame({\r\n   ...: \"A\": pd.array([1], dtype=\"int64[pyarrow]\"),\r\n   ...: \"B\": pd.array([b\"foo\"], dtype=\"binary[pyarrow]\")})\r\n\r\nIn [2]: df\r\nOut[2]:\r\n   A       B\r\n0  1  b'foo'\r\n\r\nIn [3]: df.iloc[0]\r\nOut[3]:\r\nA         1\r\nB    b'foo'\r\nName: 0, dtype: object\r\n```\r\n\r\nwhich I think is acceptable behavior for pandas to fall back to object type here even though there's no pyarrow object type.\r\n\r\nI think it would be a fairly late to change this for pandas 2.0 since an RC already has been released but I think it might be worth discussing for pandas 3.0","createdAt":"2023-03-15T17:04:45Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/11477#issuecomment-1470418738","viewerDidAuthor":false},{"id":"IC_kwDOBWUGps5xjABd","author":{"login":"mroeschke"},"authorAssociation":"CONTRIBUTOR","body":"With respect to the original example https://github.com/rapidsai/cudf/issues/11477#issue-1329308430 and availability of `cudf.pandas`, I think that row indexing that would result in non-homogenous types should raise a `MixedTypeError` or `NotImplementedError`","createdAt":"2024-01-22T23:16:07Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/11477#issuecomment-1905000541","viewerDidAuthor":false},{"id":"IC_kwDOBWUGps5xjdHM","author":{"login":"mroeschke"},"authorAssociation":"CONTRIBUTOR","body":"So this already raises in pandas compatibility mode. To confirm, do we want to also make this raise in non pandas compatibility mode?\r\n\r\n```python\r\nIn [5]: with cudf.option_context(\"mode.pandas_compatible\", True):\r\n   ...:     df1.iloc[0]\r\nTypeError: cudf does not support mixed types, please type-cast both series to same dtypes.\r\n\r\nIn [6]: with cudf.option_context(\"mode.pandas_compatible\", True):\r\n   ...:     df1.loc[\"a\"]\r\nTypeError: All columns need to be of same type, please typecast to common dtype.\r\n```","createdAt":"2024-01-23T01:18:14Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/11477#issuecomment-1905119692","viewerDidAuthor":false},{"id":"IC_kwDOBWUGps5xjg4o","author":{"login":"shwina"},"authorAssociation":"CONTRIBUTOR","body":"For regular mode, raising would be fine - but we should throw a deprecation warning for at least a release.","createdAt":"2024-01-23T01:37:05Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/11477#issuecomment-1905135144","viewerDidAuthor":false},{"id":"IC_kwDOBWUGps5xyoBz","author":{"login":"mroeschke"},"authorAssociation":"CONTRIBUTOR","body":"One more follow up. How strict do we want to be about \"all columns must have the same type when selecting rows\"? Do we want to try to implement coercion of types for numeric types coercion be absolutely strict (e.g. float32 & float64 columns would raise)?\r\n\r\n```python\r\nIn [2]: pd.DataFrame([[1, 1.0]]).iloc[0]\r\nOut[2]: \r\n0    1.0\r\n1    1.0\r\nName: 0, dtype: float64\r\n```","createdAt":"2024-01-24T23:31:00Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/11477#issuecomment-1909096563","viewerDidAuthor":false},{"id":"IC_kwDOBWUGps5x1UMF","author":{"login":"wence-"},"authorAssociation":"CONTRIBUTOR","body":"My finger in the air feeling is:\r\n\r\n- try to coerce in pandas-compat mode\r\n- raise without coercion in non-compat mode\r\n\r\nI note that pandas has already deprecated the case of _setting_ a row of a dataframe with mismatching dtypes. Although it appears like it is still value-dependent:\r\n```\r\nIn [19]: df = pd.DataFrame([[1, 1.0]])\r\n\r\nIn [20]: s = pd.Series([2.5, 2.5])\r\n\r\nIn [21]: df.iloc[0, :] = s\r\n<ipython-input-21-dc029282b8b2>:1: FutureWarning: Setting an item of incompatible dtype is deprecated and will raise an error in a future version of pandas. Value '2.5' has dtype incompatible with int64, please explicitly cast to a compatible dtype first.\r\n  df.iloc[0, :] = s\r\n\r\nIn [22]: df\r\nOut[22]: \r\n     0    1\r\n0  2.5  2.5\r\n\r\nIn [23]: df = pd.DataFrame([[1, 1.0]])\r\n\r\nIn [24]: s = pd.Series([2.0, 2.0])\r\n\r\nIn [25]: df.iloc[0, :] = s\r\n\r\nIn [26]: df\r\nOut[26]: \r\n   0    1\r\n0  2  2.0\r\n```","createdAt":"2024-01-25T10:04:24Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/11477#issuecomment-1909801733","viewerDidAuthor":false}],"createdAt":"2022-08-05T00:34:53Z","id":"I_kwDOBWUGps5PO6MO","labels":[{"id":"MDU6TGFiZWw1OTk2MjY1NTk=","name":"bug","description":"Something isn't working","color":"d73a4a"},{"id":"MDU6TGFiZWwxMTM5NzQxMjEz","name":"cuDF (Python)","description":"Affects Python cuDF API.","color":"1d76db"}],"milestone":null,"number":11477,"projectCards":[{"project":{"name":"v22.12 Release"},"column":{"name":"Issue-Needs prioritizing"}}],"projectItems":[],"reactionGroups":[{"content":"EYES","users":{"totalCount":1}}],"state":"OPEN","title":"[BUG] `DataFrame.iloc` returns the wrong type of object when a string column is present","updatedAt":"2024-01-25T10:04:26Z","url":"https://github.com/rapidsai/cudf/issues/11477"}

{"assignees":[],"author":{"id":"MDQ6VXNlcjExNjY0MjU5","is_bot":false,"login":"galipremsagar","name":"GALI PREM SAGAR"},"body":"### Background\r\n\r\nMost of pyarrow is implemented in Cython. They have a lazy-loaded pandas-shim which they use to interoperate with pandas. This is implemented as the `_PandasAPIShim` `cdef` class. There is a singleton shim object that is accessible as `pyarrow.lib._pandas_api` from python (and as both `pyarrow.lib._pandas_api` and `pyarrow.lib.pandas_api` from cython):\r\n```\r\nIn [1]: import pyarrow\r\nIn [2]: pyarrow.lib.pandas_api\r\n---------------------------------------------------------------------------\r\nAttributeError                            Traceback (most recent call last)\r\nCell In[2], line 1\r\n----> 1 pyarrow.lib.pandas_api\r\n\r\nAttributeError: module 'pyarrow.lib' has no attribute 'pandas_api'\r\n\r\nIn [3]: pyarrow.lib._pandas_api\r\nOut[3]: <pyarrow.lib._PandasAPIShim at 0x7f3838413c10>\r\n```\r\n\r\nSo at import time we make this API shim, and then it lazily initialises itself on first use.\r\n\r\nThis object saves a number of things:\r\n\r\n1. The observed pandas module it exported (by doing `import pandas; self.pandas = pandas`)\r\n2. Various type constructors (e.g. `self.data_frame = pandas.DataFrame`)\r\n\r\nThe first is relatively unproblematic. What we would like is for that module to be our intercepted wrapped module, which we can arrange with a little bit of rejigging of imports in cudf. It is the memoisation of the type constructors that is the problematic thing.\r\n\r\n### cudf.pandas wrapping scheme\r\nRecall that the way our wrapping scheme works is that we deliver wrapped _modules_ and decide at `__getattr__` time whether any attribute lookups deliver real or wrapped attributes. So:\r\n\r\n```\r\n%load_ext cudf.pandas\r\n\r\nimport pandas as pd # pd is _always_ a wrapped module\r\n\r\nDataFrame = pd.DataFrame # this is context-dependant either a real or wrapped constructor\r\n```\r\n\r\nThis works well, as long as someone doesn't memoise an attribute lookup. If they do, we only get to make the decision about what type of attribute to deliver once:\r\n\r\n```\r\nIn [1]: %load_ext cudf.pandas\r\n\r\nIn [3]: from cudf.pandas.module_finder import disable_transparent_mode_if_enabled\r\n\r\nIn [4]: with disable_transparent_mode_if_enabled():\r\n   ...:     from pandas import DataFrame\r\n   ...: \r\n\r\nIn [5]: DataFrame\r\nOut[5]: pandas.core.frame.DataFrame\r\n\r\nIn [6]: from pandas import DataFrame\r\n\r\nIn [7]: DataFrame\r\nOut[7]: cudf.pandas._wrappers.pandas.DataFrame\r\n```\r\n\r\nUnfortunately, pyarrow's pandas shim does exactly this. And we can't make the right decision, because sometimes (when used inside cudf) we need to deliver real objects, other times (when the user is using pyarrow) we need to deliver wrapped ones.\r\n\r\nI said it would be a miracle if @shwina's approach worked, and it _kind of_ does, but unfortunately it's not quite miraculous enough. Here's what's going on:\r\n\r\n`pa.table` uses `pa.lib._pandas_api.is_data_frame` to determine if the passed object is a pandas dataframe. The leading underscore here is crucial! This is a python object that we can replace. Similarly, `pa.Table.from_pandas` calls out to some Python code that uses `pa.lib._pandas_api` (which we can control).\r\n\r\nHowever, the `to_pandas` method on the resulting object calls `pyarrow.lib.pandas_api.data_frame` note _no_ leading underscore. This is a Cython level module attribute that we _can't_ replace from Python.\r\n\r\nSo, we have this:\r\n\r\n```\r\n%load_ext cudf.pandas\r\n\r\nimport pyarrow as pa\r\npa.lib._pandas_api = pa.lib._PandasAPIShim()\r\npa.lib.pandas_api = pa.lib._pandas_api # this doesn't do anything at the Cython level\r\n\r\nimport pandas as pd\r\ndf = pd.DataFrame({\"a\": [1, 2, 3]})\r\ntab = pa.table(df) # works\r\ndf2 = tab.to_pandas()\r\n\r\nprint(type(df))\r\n# <class 'cudf.pandas._wrappers.pandas.DataFrame'>\r\nprint(type(df2))\r\n# <class 'pandas.core.frame.DataFrame'>\r\n```\r\n\r\n### What if we initialise the Cython level object with wrapped attributes?\r\n\r\nThis seems like it might work, we have to be a bit careful about how we're importing pyarrow in cudf, but we can make this work so that `pa.lib.pandas_api` is a shim wrapper that sees our wrapped attributes.\r\n\r\n_But_ the memoisation breaks things, because inside cudf we use `to_arrow().to_pandas()` in various places to produce an honest-to-goodness pandas object, but this will now produce a wrapped object (and wrapping things in a `disable_transparent_mode_if_enabled()` context manager won't help because we _already_ took the decision about what constructor to deliver).\r\n\r\n### Options\r\n\r\n1. Convince the arrow folks that the memoisation of attribute lookup in their pandas shim is not really a performance win, and that it would be convenient if they just used `self.pandas.DataFrame`. This would allow us to (context-dependently) provide a real or wrapped object as appropriate. We would likely do this after releasing cudf-PAM since then the motivation is clear.\r\n2. Rather than letting module attribute lookup be context dependent, always deliver wrapped types such that the constructor context-dependently decides whether or not to deliver a real or wrapped type.\r\n3. Something else?\r\n\r\n\r\n\r\n**Steps/Code to reproduce bug**\r\n```python\r\nIn [1]: %load_ext cudf.pandas\r\n\r\nIn [2]: import pandas as pd\r\n\r\nIn [3]: df = pd.DataFrame({'a': [1, 2, 3]})\r\n\r\nIn [4]: import pyarrow as pa\r\n\r\nIn [5]: pa.table(df)\r\n---------------------------------------------------------------------------\r\nTypeError                                 Traceback (most recent call last)\r\nCell In[5], line 1\r\n----> 1 pa.table(df)\r\n\r\nFile /nvme/0/pgali/envs/cudfdev/lib/python3.10/site-packages/pyarrow/table.pxi:5165, in pyarrow.lib.table()\r\n\r\nTypeError: Expected pandas DataFrame, python dictionary or list of arrays\r\n```\r\n\r\n","closed":false,"closedAt":null,"comments":[{"id":"IC_kwDOBWUGps5tUQOJ","author":{"login":"wence-"},"authorAssociation":"CONTRIBUTOR","body":"Plausibly, at the cost of making the `to_arrow` functions in cudf aware of things, we could do this by unwrapping the wrapped result of `to_arrow().to_pandas()` (replacing it with `to_arrow().to_pandas()._fsproxy_slow`).","createdAt":"2023-11-30T15:42:19Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/14521#issuecomment-1834025865","viewerDidAuthor":false},{"id":"IC_kwDOBWUGps5tUWEL","author":{"login":"shwina"},"authorAssociation":"CONTRIBUTOR","body":"> Plausibly, at the cost of making the to_arrow functions in cudf aware of things\r\n\r\nIf this means making `cudf` aware of `cudf.pandas` proxy types, I'm strongly -1 to this. I'd really like to keep the separation of concerns here.\r\n\r\n> Rather than letting module attribute lookup be context dependent, always deliver wrapped types such that the constructor context-dependently decides whether or not to deliver a real or wrapped type.\r\n\r\nThis would likely break a bunch of things, but specifically it would break the following:\r\n\r\n```python\r\n# somewhere inside pandas code:\r\nisinstance(df, pd.DataFrame)  # returns false\r\n```\r\n\r\n---\r\n\r\n> Something else?\r\n\r\nMaybe https://github.com/apache/arrow/issues/38325?","createdAt":"2023-11-30T15:55:39Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/14521#issuecomment-1834049803","viewerDidAuthor":false},{"id":"IC_kwDOBWUGps5tUcH0","author":{"login":"wence-"},"authorAssociation":"CONTRIBUTOR","body":"> > Plausibly, at the cost of making the to_arrow functions in cudf aware of things\r\n> \r\n> If this means making `cudf` aware of `cudf.pandas` proxy types, I'm strongly -1 to this. I'd really like to keep the separation of concerns here.\r\n\r\nYeah, I don't want that either.\r\n\r\n> > Rather than letting module attribute lookup be context dependent, always deliver wrapped types such that the constructor context-dependently decides whether or not to deliver a real or wrapped type.\r\n> \r\n> This would likely break a bunch of things, but specifically it would break the following:\r\n> \r\n> ```python\r\n> # somewhere inside pandas code:\r\n> isinstance(df, pd.DataFrame)  # returns false\r\n> ```\r\n\r\nYou could dodge that bullet by continuing to _also_ maintain the module getattr handling, perhaps allowlisted inside the pandas codebase, I _think_.\r\n\r\n> > Something else?\r\n> \r\n> Maybe [apache/arrow#38325](https://github.com/apache/arrow/issues/38325)?\r\n\r\nDoes that help? That seems to be an interface for objects consuming arrow-like things and delivering \"something\". I guess that if, as a result, rather than doing `arrow_table.to_pandas()` we instead do `pandas.from_arrow(arrow_table)` (like `cudf.from_arrow`) then we're in business because we can just call `pandas.from_arrow(...)` inside cudf, and that also becomes the blessed way to get from arrow to pandas _externally_. Then we need no change because our existing denylisting on module attribute lookup would do the right thing.","createdAt":"2023-11-30T16:09:25Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/14521#issuecomment-1834074612","viewerDidAuthor":false},{"id":"IC_kwDOBWUGps5tUgo8","author":{"login":"shwina"},"authorAssociation":"CONTRIBUTOR","body":"> You could dodge that bullet by continuing to also maintain the module getattr handling, perhaps allowlisted inside the pandas codebase, I think.\r\n\r\nYeah that might do it...","createdAt":"2023-11-30T16:18:51Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/14521#issuecomment-1834093116","viewerDidAuthor":false},{"id":"IC_kwDOBWUGps5t2qZl","author":{"login":"rjzamora"},"authorAssociation":"MEMBER","body":"While discussing some current dask + cudf.pandas problems with @shwina, he pointed me to this issue. Thanks for pushing on this!\r\n\r\nUnfortunately, I cannot suggest any new ideas here, but I do want to add a bit more Dask-related motivation:\r\n\r\nBoth `dask.dataframe` and `dask_expr` are currently using `pa.Table.to_pandas()` in several critical places. The most important places are `read_parquet` and “p2p” shuffling. This essentially means that `cudf.pandas` will run into problems for any Parquet based Dask workflow. It also means that any “p2p”-based shuffle (used by default for sorting and merging when a distributed client is active) will produce “real” pd.DataFrame objects.\r\n\r\nI know that Ashwin is already aware of these problems, but I wanted to make sure others had the same context.","createdAt":"2023-12-06T14:50:45Z","includesCreatedEdit":true,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/14521#issuecomment-1843045989","viewerDidAuthor":false}],"createdAt":"2023-11-28T19:55:10Z","id":"I_kwDOBWUGps54HX5C","labels":[{"id":"MDU6TGFiZWw1OTk2MjY1NTk=","name":"bug","description":"Something isn't working","color":"d73a4a"},{"id":"MDU6TGFiZWwxMTM5NzQxMjEz","name":"cuDF (Python)","description":"Affects Python cuDF API.","color":"1d76db"},{"id":"LA_kwDOBWUGps8AAAABlj4eYg","name":"cudf.pandas","description":"Issues specific to cudf.pandas","color":"984DFB"}],"milestone":{"number":35,"title":"Proxying - cudf.pandas","description":"","dueOn":null},"number":14521,"projectCards":[],"projectItems":[],"reactionGroups":[],"state":"OPEN","title":"[BUG] `pyarrow.table` does not accept `cudf.pandas.DataFrame`","updatedAt":"2024-05-16T05:09:17Z","url":"https://github.com/rapidsai/cudf/issues/14521"}

{"assignees":[],"author":{"id":"MDQ6VXNlcjM0NDEzMjE=","is_bot":false,"login":"revans2","name":"Robert (Bobby) Evans"},"body":"**Describe the bug**\r\nPandas and Spark are very different in what gets returned when reading a JSON file.  In pandas you provide essentially type hints, but it will return data for all columns in the file and only for columns in the file.\r\n\r\nSpark has a schema that they want and when given a schema they want to read only the columns that match the schema and nothing else.\r\n\r\nThis causes two problems for Spark.  The first one is a performance issue.  If we want to read only one column out of 100, CUDF is going to materialize 100 columns and then we are going to throw away 99 of them.  It would be great if we didn't need the memory for all of the extra columns or the computation needed to create them.\r\n\r\n\r\n~The second problem is really an odd corner case.  CUDF does not support a Table with just rows, but Spark does.  So if there is a JSON file with no columns, but rows.~\r\n~{}~\r\n~{}~\r\n~We have no way to actually read that without some help.~\r\n(see https://github.com/rapidsai/cudf/issues/5712)\r\n\r\nIt really would be nice to have a mode similar to how parquet, ORC, or CSV work where only the columns that are requested are returned and all of the requested columns are returned, even if the values are all nulls.","closed":false,"closedAt":null,"comments":[{"id":"IC_kwDOBWUGps5dw6jS","author":{"login":"GregoryKimball"},"authorAssociation":"CONTRIBUTOR","body":"Thank you @revans2 for posting this. Would you please share if you exploring JSON file read or JSON strings column parsing when you encountered these issues?\r\n\r\nThe two topics about column projection and empty rows seem like they could be different issues. Would you please let me know if there is a reason to combine them?","createdAt":"2023-06-02T03:48:59Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/13473#issuecomment-1573103826","viewerDidAuthor":false},{"id":"IC_kwDOBWUGps5d0Fvo","author":{"login":"karthikeyann"},"authorAssociation":"CONTRIBUTOR","body":"The peak memory usage of JSON reader will not reduce if we add this feature. JSON tokenizer, Tree construction and traversal will still be same. Only datatype parsing will be eliminated for non-selected columns. (saves some time, but not that big).\r\n\r\n**A quick analysis on json reader benchmark:**\r\nIn the screenshot attached of a benchmark run for 64 columns, filesize 1.28GB, datatype parsing takes ~21% (green) of the time. Also note that `get_token_stream` and `get_tree_representation` takes the peak memory usage. Not datatype parsing (in green).\r\n![image](https://github.com/rapidsai/cudf/assets/6488848/6dcfe696-6856-41b2-a634-4a69703e7e20)\r\nSpeedup could be <20%.","createdAt":"2023-06-02T15:34:33Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[{"content":"THUMBS_UP","users":{"totalCount":1}}],"url":"https://github.com/rapidsai/cudf/issues/13473#issuecomment-1573936104","viewerDidAuthor":false},{"id":"IC_kwDOBWUGps5eA8rN","author":{"login":"revans2"},"authorAssociation":"CONTRIBUTOR","body":"@GregoryKimball this was when we were reading a file, but it is the same for both code paths in this case.\r\n\r\n@karthikeyann \r\n\r\nThanks for the info. I understand that this might not have a huge impact to the memory usage or computation time.  The majority of the memory usage and computation would be going into tokenizing and parsing the data. But even then if I have a case like the following\r\n\r\n```\r\n{\"B\": true, \"A\": [100, 200, 300, 400, 500.... hundreds of values ...]}\r\n... thousands of rows ...\r\n{\"B\": false, \"A\": [1, 2, 3, 4, 5...]}\r\n```\r\n\r\nIf all I save is on not needing to materialize the output for A that is a win. May not be something that you want to prioritize super high for a performance standpoint.\r\n\r\nThe big problem for us in a really odd corner case which we did run into in one of our integration tests, and I am nervous we will run into with a customer at some point.  Spark when it writes out JSON data by default will remove entries that are null.  It is a space savings optimization.  So if we end up with a row that are all nulls we end up with an output row of `{}`. This is not that uncommon in terms of a JSON optimizations.  The problem shows up if all of the rows in a batch show up this way.  \r\n\r\n\r\n```\r\n{}\r\n{}\r\n{}\r\n```\r\n\r\nI don't think it is likely to happen for large runs of rows, but with Spark it is very possible to have a few rows at the end of a file that show up like this and because of splits they would end up in a single batch. CUDF is unable to parse that batch and had us back the number of rows.  The best that we could do as a work around is to count the number of input rows before sending the data to CUDF and catch this exception after it happens. But I am not 100% sure that it will work in all cases, especially if CUDF support [comments](https://github.com/rapidsai/cudf/issues/10265), because Spark strips out lines that are fully comments in files. Then we would not know how many rows there are without some help.\r\n\r\nAgain probably not the highest priority, but it does end up being rather hacky to work around a lack of this type of feature.","createdAt":"2023-06-05T18:59:31Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/13473#issuecomment-1577306829","viewerDidAuthor":false},{"id":"IC_kwDOBWUGps5eBHyb","author":{"login":"GregoryKimball"},"authorAssociation":"CONTRIBUTOR","body":"Linking this issue to #5712 - which seems to capture the empty row issue well.\r\n\r\nLet's leave this issue to focus on the column projection optimization.","createdAt":"2023-06-05T19:23:48Z","includesCreatedEdit":true,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/13473#issuecomment-1577352347","viewerDidAuthor":false}],"createdAt":"2023-05-30T21:45:24Z","id":"I_kwDOBWUGps5nTGI6","labels":[{"id":"MDU6TGFiZWw1OTk2MjY1NTk=","name":"bug","description":"Something isn't working","color":"d73a4a"},{"id":"MDU6TGFiZWwxMDEzOTg3MzUy","name":"0 - Backlog","description":"In queue waiting for assignment","color":"d4c5f9"},{"id":"MDU6TGFiZWwxMTM5NzQwNjY2","name":"libcudf","description":"Affects libcudf (C++/CUDA) code.","color":"c5def5"},{"id":"MDU6TGFiZWwxMTg1MjQ0MTQy","name":"cuIO","description":"cuIO issue","color":"fef2c0"},{"id":"MDU6TGFiZWwxMzIyMjUyNjE3","name":"Performance","description":"Performance related issue","color":"C2E0C6"},{"id":"MDU6TGFiZWwxNDA1MTQ2OTc1","name":"Spark","description":"Functionality that helps Spark RAPIDS","color":"7400ff"}],"milestone":{"number":13,"title":"Nested JSON reader","description":"Data-parallel reader for nested JSON text data","dueOn":null},"number":13473,"projectCards":[],"projectItems":[],"reactionGroups":[{"content":"THUMBS_UP","users":{"totalCount":1}}],"state":"OPEN","title":"[BUG] JSON reader has no option to return the columns only for the requested schema","updatedAt":"2023-06-05T19:26:37Z","url":"https://github.com/rapidsai/cudf/issues/13473"}

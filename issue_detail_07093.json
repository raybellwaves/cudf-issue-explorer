{"assignees":[{"id":"MDQ6VXNlcjM2MDI3NDAz","login":"codereport","name":"Conor Hoekstra"}],"author":{"id":"MDQ6VXNlcjM2MDI3NDAz","is_bot":false,"login":"codereport","name":"Conor Hoekstra"},"body":"**Should we change `cudf::rolling_window` API so that the `preceding` parameter is exclusive?**\r\n\r\nThis is the current API for `cudf::rolling_window`:\r\n```cpp\r\nstd::unique_ptr<column> rolling_window(\r\n  column_view const& input,\r\n  size_type preceding_window,\r\n  size_type following_window,\r\n  size_type min_periods,\r\n  std::unique_ptr<aggregation> const& agg,\r\n  rmm::mr::device_memory_resource* mr = rmm::mr::get_current_device_resource());\r\n```\r\n\r\nThe question is whether `preceding` should be exclusive or inclusive. Current examples of behaviour:\r\n```cpp\r\n// auto col = {1, 2, 3, 4, 5};\r\ncudf::rolling_window(col, 2, 1, 1, ???); // gets you [1, 2], [1, 2, 3], [2, 3, 4], [3, 4, 5], [4, 5]\r\ncudf::rolling_window(col, 2, 1, 1, min); //            1,        1,         2,         3,       4\r\ncudf::rolling_window(col, 2, 1, 1, max); //            2,        3,         4,         5,       5 \r\ncudf::rolling_window(col, 2, 1, 1, sum); //            3,        6,         9,        12,       9\r\n\r\n// auto col = {1, 2, 3, 4, 5};\r\ncudf::rolling_window(col, 1, 1, 1, ???); // gets you [1, 2], [2, 3], [3, 4], [4, 5], [5]\r\ncudf::rolling_window(col, 1, 1, 1, min); //            1,      2,      3,      4,     5\r\ncudf::rolling_window(col, 1, 1, 1, max); //            2,      3,      4,      5,     5\r\ncudf::rolling_window(col, 1, 1, 1, sum); //            3,      5,      7,      9,     5\r\n\r\n// auto col = {1, 2, 3, 4, 5};\r\ncudf::rolling_window(col, 1, 0, 1, ???); // gets you [1], [2], [3], [4], [5]\r\ncudf::rolling_window(col, 1, 0, 1, min); //           1,   2,   3,   4,   5\r\ncudf::rolling_window(col, 1, 0, 1, max); //           1,   2,   3,   4,   5\r\ncudf::rolling_window(col, 1, 0, 1, sum); //           1,   2,   3,   4,   5\r\n```\r\nRecommendation would be that all of the `preceding` parameters we be \"reduce by 1\" and the current index would be included by default. Therefore window length would always be `preceding` + `following` + 1. However, need to consider the API that takes a column of window sizes and also the future changes @mythrocks will make.\r\n\r\n**Previous discussion:**\r\n* https://github.com/rapidsai/cudf/pull/3305#discussion_r352659894\r\n* https://github.com/rapidsai/cudf/pull/3305#discussion_r353878021 \r\n\r\n**Relevant SQL Links:**\r\n* https://docs.microsoft.com/en-us/sql/t-sql/queries/select-over-clause-transact-sql?view=sql-server-ver15\r\n* https://www.red-gate.com/simple-talk/sql/learn-sql-server/window-functions-in-sql-server-part-2-the-frame/","closed":false,"closedAt":null,"comments":[{"id":"MDEyOklzc3VlQ29tbWVudDc1NTg0MjgyOQ==","author":{"login":"harrism"},"authorAssociation":"MEMBER","body":"Another important current example:\r\n\r\n```c++\r\n// auto col = {1, 2, 3, 4, 5};\r\ncudf::rolling_window(col, 0, 0, 1, ???); // null, null, null, null, null\r\ncudf::rolling_window(col, 0, 0, 1, min); // null, null, null, null, null\r\netc.\r\n```\r\n\r\nI just worked through the logic of some corner cases, and thought I would document it to help improve understanding and help others work examples. Here's the current logic for computing the window start and end.\r\n\r\n```c++\r\nsize_type preceding_window = preceding_window_begin[i];\r\nsize_type following_window = following_window_begin[i];\r\n\r\n// compute bounds\r\nsize_type start       = min(input.size(), max(0, i - preceding_window + 1));\r\nsize_type end         = min(input.size(), max(0, i + following_window + 1));\r\nsize_type start_index = min(start, end);\r\nsize_type end_index   = max(start, end); \r\n```\r\n\r\nAnd the window processing loops all look like `for (size_type j = start_index; j < end_index; j++) { ... }`  -- so `end_index` is not included.\r\n\r\nI guess what is being proposed is to change it so that passing [0, 0, 1] for preceding, following, min_periods gives you the identity, rather than the current behavior where [1, 0, 1] gives you the identity. So my first attempt at the new logic would be:\r\n\r\n```c++\r\nsize_type preceding_window = preceding_window_begin[i];\r\nsize_type following_window = following_window_begin[i];\r\n\r\n// compute bounds\r\nsize_type start       = min(input.size(), max(0, i - preceding_window));\r\nsize_type end         = min(input.size(), max(0, i + following_window + 1));\r\nsize_type start_index = min(start, end);\r\nsize_type end_index   = max(start, end); \r\n```\r\n(Leaving the processing loop alone.)\r\nNotably, my example above would now produce non-null results. \r\n\r\n```c++\r\n// auto col = {1, 2, 3, 4, 5};\r\ncudf::rolling_window(col, 0, 0, 1, ???); // [1], [2], [3], [4], [5]\r\ncudf::rolling_window(col, 0, 0, 1, min); //  1,   2,   3,   4,   5\r\netc.\r\n```\r\n\r\nTo recover the previous zero-window-size behavior would require passing `-1` for *either* one of the window sizes.\r\n\r\n```c++\r\n// auto col = {1, 2, 3, 4, 5};\r\ncudf::rolling_window(col, -1, 0, 1, ???); // null, null, null, null, null\r\ncudf::rolling_window(col, 0, -1, 1, ???); // null, null, null, null, null\r\n```\r\nBut (I think surprisingly), passing `-1` for both would be the same as passing zero for both!\r\n\r\n```c++\r\n// auto col = {1, 2, 3, 4, 5};\r\ncudf::rolling_window(col, -1, -1, 1, ???); // [1], [2], [3], [4], [5]\r\n```\r\n\r\nI would think that (-1, -1) should result in the reverse of (1, 1).  This makes me think that we would instead want to change the implementation to this:\r\n\r\n```c++\r\nsize_type preceding_window = preceding_window_begin[i];\r\nsize_type following_window = following_window_begin[i];\r\n\r\n// compute bounds\r\nsize_type start       = min(input.size() - 1, max(0, i - preceding_window));\r\nsize_type end         = min(input.size() - 1, max(0, i + following_window));\r\nsize_type start_index = min(start, end);\r\nsize_type end_index   = max(start, end); \r\n```\r\n\r\nAnd change the for loop to be inclusive. `for (size_type j = start_index; j <= end_index; j++) { ... }`\r\n\r\nImportant to also note the changes to the first argument to `min()` for `start` and `end`.\r\n\r\n```c++\r\n// auto col = {1, 2, 3, 4, 5};\r\n\r\n// 0, 0, 1 still gives the identity\r\ncudf::rolling_window(col, 0, 0, 1, ???); // [1], [2], [3], [4], [5]\r\n\r\n// Note the difference here: \r\ncudf::rolling_window(col, -1, 0, 1, ???); // [1 2], [2 3], [3 4], [4 5], [5]\r\ncudf::rolling_window(col, 0, -1, 1, ???); // [1], [1 2], [2 3], [3 4], [4 5]\r\n\r\n// The above are the same as the reversed, negated windows (this seems consistent)\r\ncudf::rolling_window(col, 0, 1, 1, ???); // [1 2], [2 3], [3 4], [4 5], [5]\r\ncudf::rolling_window(col, 1, 0, 1, ???); // [1], [1 2], [2 3], [3 4], [4 5]\r\n\r\n// -1 twice is the same as 1 twice, as expected\r\ncudf::rolling_window(col, 1, 1, 1, ???);   // [1 2], [2 3], [3 4], [4 5], [5]\r\ncudf::rolling_window(col, -1, -1, 1, ???); // [1 2], [2 3], [3 4], [4 5], [5]\r\n```\r\n\r\nBut now how do we do a zero window size? The only way is to set `min_periods` greater than 1.\r\n\r\n```c++\r\ncudf::rolling_window(col, 0, 0, 2, ???);   // null, null, null, null, null\r\n```\r\n\r\nThis kind of bothers me, but at least there is a way. And the rest of the cases are more self consistent than other implementations.\r\n\r\n","createdAt":"2021-01-07T02:29:48Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/7093#issuecomment-755842829","viewerDidAuthor":false},{"id":"MDEyOklzc3VlQ29tbWVudDc1NTg0Njk3Nw==","author":{"login":"harrism"},"authorAssociation":"MEMBER","body":"BTW, I found the original negative window sizes request. https://github.com/rapidsai/cudf/issues/3650\r\n\r\nInterestingly, the reason for the request was to enable windows that DO NOT include the current row/element. So I don't think negative window sizes are strictly necessary, just a way to exclude the current row. The assumption that the current row should always be included is not a valid assumption, it seems.\r\n\r\nLet's take the example from that issue: \r\n\r\n> So for example I may want the MAX of the 5 entries just before the current one.\r\n\r\nThe existing behavior where one of the two window sizes is exclusive makes this possible (along with negative window sizes). \r\n\r\n```c++\r\ncudf::rolling_window(col, 6, -1, 1, max); // Admittedly, this is awkward!\r\n```\r\n\r\nThe proposed new behavior would make it impossible to express -- the current element is always included.","createdAt":"2021-01-07T02:43:37Z","includesCreatedEdit":true,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/7093#issuecomment-755846977","viewerDidAuthor":false},{"id":"MDEyOklzc3VlQ29tbWVudDc1NjQ5MDc2Ng==","author":{"login":"harrism"},"authorAssociation":"MEMBER","body":"I need to correct myself. Using 5, -1, 1 should work for a window that only includes the 5 elements before the current element, and not the current element!","createdAt":"2021-01-08T01:32:40Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/7093#issuecomment-756490766","viewerDidAuthor":false},{"id":"MDEyOklzc3VlQ29tbWVudDc1NjQ5MTA0Mw==","author":{"login":"harrism"},"authorAssociation":"MEMBER","body":"Before we do anything here, we need to gather further requirements. For example @mythrocks mentioned the need for offset windows. @mythrocks can you please elaborate?","createdAt":"2021-01-08T01:33:34Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/7093#issuecomment-756491043","viewerDidAuthor":false},{"id":"MDEyOklzc3VlQ29tbWVudDc1ODI4NzA5MA==","author":{"login":"mythrocks"},"authorAssociation":"CONTRIBUTOR","body":"> For example @mythrocks mentioned the need for offset windows. @mythrocks can you please elaborate?\r\n\r\nAn offset window is one where the two ends of the window do not straddle the row itself. For instance, consider this column:\r\n```\r\n// auto col = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};\r\n```\r\nConsider a `SUM()` operation over records in a span [`2 ROWS PRECEDING`, `1 ROW PRECEDING`]. All the rows participating in a window appear before (i.e. to the left) of the current row. E.g. For row at index `5`, the sum is `7` (i.e. `3+4`). \r\nAssuming the current semantics of `preceding`/`following`, we might represent this as:\r\n```\r\ncudf::rolling_window(col, 3, -1, 1, sum); // {Ï‰, 0, 1, 3, 5, 9, 11, 13, 15}\r\n```\r\n\r\nWe will need to add checks so that the left bound do not appear to the right of the right bound. (E.g. `rolling_window(col 3, -3, ?, ???)`.)\r\n\r\nThis gets slightly more involved for timestamp-based queries, where the window might be from `7 DAYS PRECEDING` to `1 DAY PRECEDING`.","createdAt":"2021-01-11T23:22:49Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/7093#issuecomment-758287090","viewerDidAuthor":false},{"id":"MDEyOklzc3VlQ29tbWVudDc4MDA5MzMwOQ==","author":{"login":"github-actions"},"authorAssociation":"NONE","body":"This issue has been marked stale due to no recent activity in the past 30d. Please close this issue if no further response or action is needed. Otherwise, please respond with a comment indicating any updates or changes to the original issue and/or confirm this issue still needs to be addressed. This issue will be marked rotten if there is no activity in the next 60d.","createdAt":"2021-02-16T20:19:40Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/7093#issuecomment-780093309","viewerDidAuthor":false},{"id":"MDEyOklzc3VlQ29tbWVudDg0MjYzODExNA==","author":{"login":"github-actions"},"authorAssociation":"NONE","body":"This issue has been labeled `inactive-90d` due to no recent activity in the past 90 days. Please close this issue if no further response or action is needed. Otherwise, please respond with a comment indicating any updates or changes to the original issue and/or confirm this issue still needs to be addressed.","createdAt":"2021-05-17T21:04:26Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/7093#issuecomment-842638114","viewerDidAuthor":false},{"id":"IC_kwDOBWUGps5MZCvN","author":{"login":"vyasr"},"authorAssociation":"CONTRIBUTOR","body":"@harrism @mythrocks do either of you recall the motivations for this discussion or know if it's still something that we should be pursuing?","createdAt":"2022-10-17T23:39:50Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/7093#issuecomment-1281633229","viewerDidAuthor":false},{"id":"IC_kwDOBWUGps5MZc8J","author":{"login":"harrism"},"authorAssociation":"MEMBER","body":"I'm sorry, I don't.","createdAt":"2022-10-18T02:42:39Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/7093#issuecomment-1281740553","viewerDidAuthor":false},{"id":"IC_kwDOBWUGps5MjweT","author":{"login":"mythrocks"},"authorAssociation":"CONTRIBUTOR","body":"At the risk of repeating what @codereport covered in the description, I can try provide a summary:\r\n\r\nWindow bounds are defined in CUDF via a \"preceding\" and \"following\" row-count. For reasons that predate my work on window functions, the \"preceding\" count *includes* the current row. This is not intuitive:\r\n1. A window defined as `[1,1]` should intuitively cover *3* rows (1 preceding, 1 current, 1 following), as in SQL. But as per CUDF convention, it covers *2* (1 current, 1 following).\r\n2. A window of `[0,1]` is now a negative offset. :/\r\n\r\nThe Spark code currently passes `preceding - 1` before calling into CUDF, to match the semantics.\r\n\r\n@codereport's suggestion is to undo this, and make \"preceding\" \"actually preceding\" again.\r\nBut this needs to be done in lockstep with Spark (and Python), to reduce errors. There are also a metric tonne of tests to modify.","createdAt":"2022-10-19T18:56:12Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/7093#issuecomment-1284442003","viewerDidAuthor":false},{"id":"IC_kwDOBWUGps5MkEO2","author":{"login":"harrism"},"authorAssociation":"MEMBER","body":"I definitely won't stand in your way. :)","createdAt":"2022-10-19T20:14:47Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/7093#issuecomment-1284522934","viewerDidAuthor":false},{"id":"IC_kwDOBWUGps5MuCMT","author":{"login":"vyasr"},"authorAssociation":"CONTRIBUTOR","body":"@mythrocks would you be up for taking this on at some point? I'm happy to help make the Python changes if you'd like help there!","createdAt":"2022-10-21T15:39:30Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/7093#issuecomment-1287136019","viewerDidAuthor":false}],"createdAt":"2021-01-07T01:13:03Z","id":"MDU6SXNzdWU3ODA5NTI2NDc=","labels":[{"id":"MDU6TGFiZWw1OTk2MjY1NjQ=","name":"question","description":"Further information is requested","color":"D4C5F9"},{"id":"MDU6TGFiZWwxMTM5NzQwNjY2","name":"libcudf","description":"Affects libcudf (C++/CUDA) code.","color":"c5def5"}],"milestone":null,"number":7093,"projectCards":[{"project":{"name":"Other Issues"},"column":{"name":"Needs prioritizing"}}],"projectItems":[],"reactionGroups":[],"state":"OPEN","title":"[QST] Changing `cudf::rolling_window` API to have exclusive `preceding` parameter","updatedAt":"2024-02-23T18:43:16Z","url":"https://github.com/rapidsai/cudf/issues/7093"}

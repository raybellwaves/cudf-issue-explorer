{"assignees":[],"author":{"id":"MDQ6VXNlcjE0ODc2NTg1","is_bot":false,"login":"divyegala","name":"Divye Gala"},"body":"As showcased in https://github.com/rapidsai/cudf/pull/13347, there's a need for `{lhs, lhs}` and `{rhs, rhs}` comparisons in an instance of `two_table_comparator`.\r\n\r\nThis can't simply be achieved by adding more overloads because `left` and `right` terminology is [baked into the comparator](https://github.com/rapidsai/cudf/blob/76ec53fae9dad71398c115bc405317a918036e52/cpp/include/cudf/table/experimental/row_operators.cuh#L1141-L1157) when it's constructed at the host-side. In a device function, the [strongly typed indices](https://github.com/rapidsai/cudf/blob/76ec53fae9dad71398c115bc405317a918036e52/cpp/include/cudf/table/experimental/row_operators.cuh#L1012-L1039) now work with the assumption that a `comp(i, j)` that is called in a device function operates on `{lhs, rhs}` or `{rhs, lhs}`.\r\n\r\nWe need to settle on a design that lets us refactor the row operators such that the assumption of working on two different tables can be removed.\r\n\r\nDo we strongly type `device_row_comparator::operator()` [over here](https://github.com/rapidsai/cudf/blob/76ec53fae9dad71398c115bc405317a918036e52/cpp/include/cudf/table/experimental/row_operators.cuh#L541-L542) such that we can decide which columns of which tables to pass along to the `element_comparator` over [here](https://github.com/rapidsai/cudf/blob/76ec53fae9dad71398c115bc405317a918036e52/cpp/include/cudf/table/experimental/row_operators.cuh#L568-L575)?\r\n\r\nI see the design looking something like this:\r\n```\r\nclass device_row_comparator {\r\n  class element_comparator {\r\n    operator() (size_type lhs_index, size_type rhs_index);\r\n  };\r\n  dispatch_element_operator(lhs_col, rhs_col, lhs_index, rhs_index);\r\n\r\n  // these call dispatch_element_operator with the correct columns and indices\r\n  operator() (lhs_index_type lhs_index, rhs_index_type rhs_index);\r\n  operator() (lhs_index_type lhs_index, lhs_index_type rhs_index);\r\n  operator() (rhs_index_type lhs_index, rhs_index_type rhs_index);\r\n};\r\n\r\n// the template `Comparator` here and below will be an instance of `device_row_comparator`,\r\n// such that the strongly type indices can be passed along directly\r\ntemplate <typename Comparator, weak_ordering... values>\r\nclass single_table_ordering {\r\n  operator() (size_type lhs_index, size_type rhs_index) {\r\n    return comparator(lhs_index_type{lhs_index}, lhs_index_type{rhs_index});\r\n};\r\n\r\ntemplate <typename Comparator, weak_ordering... values>\r\nclass two_table_ordering {\r\n// same as current version of strong_index_comparator with added overloads for {lhs, lhs} and {rhs, rhs}\r\n};\r\n\r\nclass self_comparator {\r\n  auto less() {\r\n    return less_comparator{single_table_ordering{device_row_comparator{...}}};\r\n  }\r\n};\r\n\r\nclass two_table_comparator {\r\n  auto less() {\r\n    return less_comparator{two_table_ordering{device_row_comparator{...}}};\r\n  }\r\n};\r\n```\r\nNote: In this example, [weak_ordering_comparator_impl](https://github.com/rapidsai/cudf/blob/76ec53fae9dad71398c115bc405317a918036e52/cpp/include/cudf/table/experimental/row_operators.cuh#L612-L626) will be removed and it's functionality will instead be baked into `single_table_ordering` and `two_table_ordering`. [less_comparator](https://github.com/rapidsai/cudf/blob/76ec53fae9dad71398c115bc405317a918036e52/cpp/include/cudf/table/experimental/row_operators.cuh#L634-L644) will then be reworked with CRTP such that:\r\n```\r\ntemplate <typename Comparator>\r\nclass less_comparator : Comparator<weak_ordering::LESS>\r\n```\r\n","closed":false,"closedAt":null,"comments":[{"id":"IC_kwDOBWUGps5cgk8p","author":{"login":"ttnghia"},"authorAssociation":"CONTRIBUTOR","body":"I don't like the idea of having the ability to do self-comparison inside two-table-comparision. Instead, the ability to do comparison either between `lhs-lhs`, `lhs-rhs` and `rhs-rhs` should be a \"mixed comparison\" thus we should have a new comparator alongside with `self_comparator` and `two_table_comparator`. Something may be called `mixed_table_compartor`. Maybe with this comparator, we can remove `two_table_comparator` completely, but we should not use the name \"two table comparator\" for mixed comparison like that.","createdAt":"2023-05-17T20:33:54Z","includesCreatedEdit":true,"isMinimized":false,"minimizedReason":"","reactionGroups":[{"content":"THUMBS_UP","users":{"totalCount":1}}],"url":"https://github.com/rapidsai/cudf/issues/13371#issuecomment-1552043817","viewerDidAuthor":false},{"id":"IC_kwDOBWUGps5cgmO4","author":{"login":"divyegala"},"authorAssociation":"MEMBER","body":"@ttnghia that's acceptable. We'll still need many of the changes from the description to support mixed_table_comparator.","createdAt":"2023-05-17T20:36:10Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/13371#issuecomment-1552049080","viewerDidAuthor":false}],"createdAt":"2023-05-17T19:21:59Z","id":"I_kwDOBWUGps5mMaOT","labels":[{"id":"MDU6TGFiZWw1OTk2MjY1NjE=","name":"feature request","description":"New feature or request","color":"a2eeef"},{"id":"MDU6TGFiZWwxMDEzOTg3NDE3","name":"1 - On Deck","description":"To be worked on next","color":"bfd4f2"},{"id":"MDU6TGFiZWwxMTM5NzQwNjY2","name":"libcudf","description":"Affects libcudf (C++/CUDA) code.","color":"c5def5"}],"milestone":null,"number":13371,"projectCards":[],"projectItems":[],"reactionGroups":[{"content":"THUMBS_UP","users":{"totalCount":1}},{"content":"HEART","users":{"totalCount":1}}],"state":"OPEN","title":"[FEA] Support self comparisons in `cudf::experimental::row::lexicographic::two_table_comparator`","updatedAt":"2023-06-07T21:12:33Z","url":"https://github.com/rapidsai/cudf/issues/13371"}

{"assignees":[{"id":"MDQ6VXNlcjExMjY5ODE=","login":"wence-","name":"Lawrence Mitchell"}],"author":{"id":"MDQ6VXNlcjExMjY5ODE=","is_bot":false,"login":"wence-","name":"Lawrence Mitchell"},"body":"Followup from #10784. Hyphens and underscores are used inconsistently when separating names in metadata keys in `serialize`; go through and standardise on one choice (hyphens seem more popular).","closed":false,"closedAt":null,"comments":[{"id":"IC_kwDOBWUGps5C1jy-","author":{"login":"wence-"},"authorAssociation":"CONTRIBUTOR","body":"Going through and doing the minimum thing to add `frame_count` slots to all serializable objects, a further thought occurred which is that as well as lack of consistency in key names, there's also a lack of consistency in the metadata schema.\r\n\r\nSome of the metadata slots (in particular `type-serialized`) are picked to align with what dask names things; as far as I can tell this is not the case for others, and doesn't really need to be, but cc @jakirkham whom `git-annotate` suggests might know.\r\n\r\nSometimes, properties of nested objects are copied in to the parent header, and sometimes not, I think it makes sense to clean up and have a model of:\r\n```\r\n{\"type-serialized\": my-type,\r\n  \"properties\": {attribute: value, nested_object: nested_stuff},\r\n  \"frame-count\": number_of_frames_consumed_in_deserialization}\r\n```\r\n\r\nPerhaps something like this was considered and rejected?\r\n\r\nA much larger change would be to set up all of the serializable objects as `dataclass`-like things with constructors that just set attributes, then the schema for serialization is completely clear and lots of this code can be removed. A downside here is that serialization is not as extensible in an ad-hoc manner, and I am not sure that all cudf classes can get away with default simple constructors.","createdAt":"2022-05-09T16:46:18Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/10799#issuecomment-1121336510","viewerDidAuthor":false},{"id":"IC_kwDOBWUGps5C1mJP","author":{"login":"bdice"},"authorAssociation":"CONTRIBUTOR","body":"A small consideration that might tip the balance: using underscores makes it map more directly to valid Python identifiers, e.g.\r\n```python\r\n# Using underscores in the keys:\r\nframe_count = metadata[\"frame_count\"]\r\ntype_serialized = metadata[\"type_serialized\"]\r\n# vs. mapping dashes to underscores:\r\nframe_count = metadata[\"frame-count\"]\r\ntype_serialized = metadata[\"type-serialized\"]\r\n```","createdAt":"2022-05-09T16:57:10Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/10799#issuecomment-1121346127","viewerDidAuthor":false},{"id":"IC_kwDOBWUGps5C1uaD","author":{"login":"vyasr"},"authorAssociation":"CONTRIBUTOR","body":"I would definitely welcome more insight from a Dask expert. Some thoughts and questions:\r\n- Are you proposing that nested headers are always copied into their parents? Does that mean that we always duplicate data?\r\n- How would nesting work when nested objects that aren't buffers actually return frames? In particular, our `CategoricalDtype` serializes into both header information and a frame consisting of the categories (just curious if you've considered how this impacts your proposal, because I haven't).\r\n- You're right that simple `dataclass` constructors won't work for most of our classes like `DataFrame` or `Series`. Those must be constructible from a wide range of objects to match what pandas supports.\r\n\r\nIt might help to consider whether we could change our classes so that only `Frame` and `BaseIndex` are `Serializable`. `ColumnBase` would still need its current implementation, but we could simplify dtype and `Buffer` logic. We shouldn't need non-API classes to conform to the `dask.distributed` API, and it leads to some incongruities:\r\n- dtypes include \"frames\" when serializing even though they don't actually have frames of data. The exception is categoricals, which are tricky because they are the only dtype that stores data on device (the categories). We would probably need a special case to support those.\r\n- Buffers ultimately just insert \"self\" into the frames, so every Column could really just insert its underlying buffer into the frames list and call that good. `Buffer` is an implementation detail of cudf and shouldn't need to conform to the dask API. We really just use the CAI protocol to save and load them anyway. That would remove one additional `serialize` implementation.","createdAt":"2022-05-09T17:30:30Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/10799#issuecomment-1121379971","viewerDidAuthor":false},{"id":"IC_kwDOBWUGps5C19Y9","author":{"login":"jakirkham"},"authorAssociation":"MEMBER","body":"Dask uses `-`s\r\n\r\nNot sure I follow what else is being proposed here","createdAt":"2022-05-09T18:34:27Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/10799#issuecomment-1121441341","viewerDidAuthor":false},{"id":"IC_kwDOBWUGps5C2e_R","author":{"login":"vyasr"},"authorAssociation":"CONTRIBUTOR","body":"@jakirkham I think the two main questions for you are:\r\n- Does it matters at all for cudf to use the same field names as dask (such as type-serialized)? We think not, but would like confirmation.\r\n- What objects actually need to support the serialization protocols? Is it just DataFrame,Series, and all the types of Indexes? i.e. Is there any need for `cudf.Buffer` or each dtype to support the protocols? Of course, we need a way to serialize that information, i.e. we need to know whether a Series contains strings or ints, but here we're just talking about necessary APIs for each type of object. ","createdAt":"2022-05-09T21:04:08Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/10799#issuecomment-1121578961","viewerDidAuthor":false},{"id":"IC_kwDOBWUGps5C26v4","author":{"login":"jakirkham"},"authorAssociation":"MEMBER","body":"Yes `\"type-serialized\"` matters. It is a special field in Dask\r\n\r\nWhen adding support for cuDF serialization, we found all sorts of objects went over the wire. Any we missed supporting surfaced as errors in benchmarks. So we added them all\r\n\r\nI think what I'm missing is what we are trying to fix here","createdAt":"2022-05-09T23:48:58Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/10799#issuecomment-1121692664","viewerDidAuthor":false},{"id":"IC_kwDOBWUGps5C4fdi","author":{"login":"wence-"},"authorAssociation":"CONTRIBUTOR","body":"> I would definitely welcome more insight from a Dask expert. Some thoughts and questions:\r\n> \r\n> * Are you proposing that nested headers are always copied into their parents? Does that mean that we always duplicate data?\r\n\r\nOn the contrary. I'm proposing:\r\n```python\r\nheader = {\"properties\": {}}\r\nframes = []\r\nsub_obj = self.child # object we're serializing has a child to be serialized\r\nsub_header, sub_frames = sub_obj.serialize()\r\nheader[\"properties\"][\"child\"] = sub_header\r\nframes.extend(sub_frames)\r\n```\r\n\r\nAt the moment, depending on the particular object, in serialization, sometimes this is done, sometimes some information is carried redundantly in the `header` itself. Moreover, if adding a new slot to the \"top-level\" header key space, one has to read (or know) non-local code to know whether there are any reserved keys. For example `Serializable.device_serialize` (which calls the class-implemented `serialize`) overwrites `\"type-serialized\"`, `\"is-cuda\"`, and `\"lengths\"`, `Serializable.host_serialize` (called via pickle) additionally overwrites `\"writeable\"`.\r\n\r\n> * How would nesting work when nested objects that aren't buffers actually return frames? In particular, our `CategoricalDtype` serializes into both header information and a frame consisting of the categories (just curious if you've considered how this impacts your proposal, because I haven't).\r\n\r\nThis is not problematic. Deserialization takes a (nested) metadata descriptor and a list of frames and returns a deserialized object and a (partially) consumed list of frames. So a helper function:\r\n\r\n```python\r\ndef unpack(header, frames):\r\n    typ = pickle.loads(header[\"type-serialized\"])\r\n    count = header[\"frame_count\"]\r\n    obj = typ.deserialize(header, frames[:count])\r\n    return obj, frames[count:]\r\n```\r\n\r\nworks to unfold the part of a nested definition. So suppose we were deserializing a column with a categorical dtype:\r\n```python\r\ndtype_header = header[\"properties\"][\"dtype\"]\r\ndtype, frames = unpack(dtype_header, frames)\r\n# continue with deserialization of other properties\r\n```\r\n\r\n> * You're right that simple `dataclass` constructors won't work for most of our classes like `DataFrame` or `Series`. Those must be constructible from a wide range of objects to match what pandas supports.\r\n\r\nOne way to square that circle (though it is a big API-breaking change) is to split the munging of data for `__init__` into a free function. That is the API offers:\r\n```\r\ndef DataFrame(args):\r\n    # munge args\r\n    processed_args = ...(args)\r\n    return impl.DataFrame(processed_args)\r\n```\r\n\r\n~It may well not be worth it, however.~\r\n\r\nEDIT: that's not possible due to API constraints (as pointed out below by @shwina).\r\n\r\n> It might help to consider whether we could change our classes so that only `Frame` and `BaseIndex` are `Serializable`. `ColumnBase` would still need its current implementation, but we could simplify dtype and `Buffer` logic. We shouldn't need non-API classes to conform to the `dask.distributed` API, and it leads to some incongruities:\r\n> \r\n> * dtypes include \"frames\" when serializing even though they don't actually have frames of data. The exception is categoricals, which are tricky because they are the only dtype that stores data on device (the categories). We would probably need a special case to support those.\r\n\r\nThe advantage of everything supporting the same interface is you don't need to do any special-casing. You just recurse calling serialize until the base case is hit. If you don't have this then any dtype-carrying object that needs to be serialized has to `if isinstance(dtype, CategoricalDtype)` I think.\r\n\r\n> * Buffers ultimately just insert \"self\" into the frames, so every Column could really just insert its underlying buffer into the frames list and call that good. `Buffer` is an implementation detail of cudf and shouldn't need to conform to the dask API. We really just use the CAI protocol to save and load them anyway. That would remove one additional `serialize` implementation.\r\n\r\nI think this would work, since the wire format is to effectively send all the frames out of band and the reconstruct on the other end. The column metadata can include enough information to rebuild/validate the buffer.\r\n\r\n\r\n\r\n","createdAt":"2022-05-10T08:43:11Z","includesCreatedEdit":true,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/10799#issuecomment-1122105186","viewerDidAuthor":false},{"id":"IC_kwDOBWUGps5C4rMI","author":{"login":"wence-"},"authorAssociation":"CONTRIBUTOR","body":"> I think what I'm missing is what we are trying to fix here\r\n\r\nInitially, I was adding support for serialization that was missing on struct columns (that was #10784). As part of that, the schema for the metadata headers seemed a bit inconsistent. So I am looking at if it is worth investing effort in cleaning that up a bit.","createdAt":"2022-05-10T09:30:12Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/10799#issuecomment-1122153224","viewerDidAuthor":false},{"id":"IC_kwDOBWUGps5C-AzX","author":{"login":"shwina"},"authorAssociation":"CONTRIBUTOR","body":"Just a drive-by comment here: `DataFrame` needs to be a type (as does `Index`). Unfortunately, we cannot make those into factory free-functions.\r\n","createdAt":"2022-05-11T10:34:50Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/10799#issuecomment-1123552471","viewerDidAuthor":false},{"id":"IC_kwDOBWUGps5C-jg3","author":{"login":"wence-"},"authorAssociation":"CONTRIBUTOR","body":"> Just a drive-by comment here: `DataFrame` needs to be a type (as does `Index`). Unfortunately, we cannot make those into factory free-functions.\r\n\r\nI'm guessing because code basically relies on `isinstance(foo, cudf.DataFrame)` and the like?","createdAt":"2022-05-11T12:28:44Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/10799#issuecomment-1123694647","viewerDidAuthor":false},{"id":"IC_kwDOBWUGps5C_JXV","author":{"login":"shwina"},"authorAssociation":"CONTRIBUTOR","body":"Yes -- and also there are classmethods defined on `cudf.DataFrame` that are in the public API; e.g., `cudf.DataFrame.from_pandas()`.\r\n\r\n","createdAt":"2022-05-11T14:30:30Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/10799#issuecomment-1123849685","viewerDidAuthor":false},{"id":"IC_kwDOBWUGps5EsR1l","author":{"login":"github-actions"},"authorAssociation":"NONE","body":"This issue has been labeled `inactive-30d` due to no recent activity in the past 30 days. Please close this issue if no further response or action is needed. Otherwise, please respond with a comment indicating any updates or changes to the original issue and/or confirm this issue still needs to be addressed. This issue will be labeled `inactive-90d` if there is no activity in the next 60 days.","createdAt":"2022-06-10T15:03:39Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/10799#issuecomment-1152458085","viewerDidAuthor":false},{"id":"IC_kwDOBWUGps5J9uqo","author":{"login":"github-actions"},"authorAssociation":"NONE","body":"This issue has been labeled `inactive-90d` due to no recent activity in the past 90 days. Please close this issue if no further response or action is needed. Otherwise, please respond with a comment indicating any updates or changes to the original issue and/or confirm this issue still needs to be addressed.","createdAt":"2022-09-08T16:03:12Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/10799#issuecomment-1240918696","viewerDidAuthor":false},{"id":"IC_kwDOBWUGps5PQESh","author":{"login":"wence-"},"authorAssociation":"CONTRIBUTOR","body":"I think anything we do here will need to be in tandem with proposed serialisation changes in dask/distributed that are being contemplated. So I'll revisit this then.","createdAt":"2022-11-28T19:10:06Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/10799#issuecomment-1329611937","viewerDidAuthor":false},{"id":"IC_kwDOBWUGps5-Od9R","author":{"login":"vyasr"},"authorAssociation":"CONTRIBUTOR","body":"@wence- has anything changed in dask since the last comment to move the needle here?","createdAt":"2024-05-17T14:21:33Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/10799#issuecomment-2117721937","viewerDidAuthor":false}],"createdAt":"2022-05-05T16:45:28Z","id":"I_kwDOBWUGps5JIYzb","labels":[{"id":"MDU6TGFiZWw1OTk2MjY1NjQ=","name":"question","description":"Further information is requested","color":"D4C5F9"},{"id":"MDU6TGFiZWwxMTM5NzQxMjEz","name":"cuDF (Python)","description":"Affects Python cuDF API.","color":"1d76db"}],"milestone":null,"number":10799,"projectCards":[{"project":{"name":"Feature Planning"},"column":{"name":"Needs prioritizing"}}],"projectItems":[],"reactionGroups":[],"state":"OPEN","title":"[ENH]: serialization schema cleanup","updatedAt":"2024-05-17T14:21:34Z","url":"https://github.com/rapidsai/cudf/issues/10799"}

{"assignees":[{"id":"MDQ6VXNlcjExMjY5ODE=","login":"wence-","name":"Lawrence Mitchell"}],"author":{"id":"MDQ6VXNlcjExMjY5ODE=","is_bot":false,"login":"wence-","name":"Lawrence Mitchell"},"body":"## Context\r\n\r\nAs noted in #11085, in many cases (though inconsistently right now), obtaining a view on `Series` (probably a `DataFrame` as well) using `iloc[:]` _inadvertently_ behaves with pseudo-copy-on-write semantics\r\n\r\n```python\r\nimport cudf\r\nimport numpy as np\r\ns = cudf.Series([1, 2, 3])\r\nsview = s.iloc[:]\r\ns.iloc[[1, 2]] = [4, 5]\r\nassert np.allclose(s.values, sview.values) # => False\r\n\r\nsview = s.iloc[:]\r\ns.iloc[0:2] = 3\r\nassert np.allclose(s.values, sview.values) # => True\r\n```\r\n\r\nNote: pandas is moving towards _all_ indexing [behaving with copy semantics](https://docs.google.com/document/d/1ZCQ9mx3LBMy-nhwRl33_jgcvWo9IWdEfxDNQ2thyTb0), so for some of these cases we've already skated to the right answer :)\r\n\r\n## Why does this happen?\r\n\r\nMost (but not all) of the `__setitem__`-like calls into (e.g. `copy_range`, `scatter`) `libcudf` do not operate in place, but instead return a new `cudf::column` that must be wrapped up. As a consequence, to pretend like the operation was in place, we call `_mimic_inplace(...)` to switch out the backing data of the `Column` object we're doing `__setitem__` on:\r\n\r\n```python\r\nimport cudf\r\ns = cudf.Series([1, 2, 3])\r\nold_data = s._column.data\r\ns.iloc[1:3] = [4, 5]\r\nnew_data = s._column.data\r\nassert old_data is new_data # => False\r\n```\r\n\r\nThis is kind of fine as long as there's only one object holding on to the column data, but this breaks down as soon as we have views.\r\n\r\n## Why is the status quo problematic?\r\n\r\n1. The current inconsistencies make implementing copy-on-write rather delicate (and in many cases provoke more copies than needed).\r\n2. Operations that to the user do not provoke a copy can overflow GPU memory:\r\n     ```python\r\n      # on a system with 32 GB gpu memory\r\n      import cudf\r\n      import cupy as cp\r\n      import numpy as np\r\n      df = cudf.DataFrame({f\"{i}\": cp.ones(10**9, dtype=np.uint8) for i in range(20)}) # about 20GB\r\n      # expectation: this behaves in place, so the operation should fit in memory.\r\n      df.iloc[[0, 2]] = list(range(20)) # => MemoryError: std::bad_alloc: out_of_memory: CUDA error at: rmm/mr/device/cuda_memory_resource.hpp\r\n    ````\r\n3. If the scatter/copy_foo operations in libcudf had an in place then we would have lower memory pressure (as point 2) and in the (common) case where we have a target table view, could avoid a memcopy of the whole table.\r\n\r\n## Possible solutions\r\n\r\nI don't know the history as to why the libcudf generally tends to offer \"return a copy\" rather than \"modify in place\", but one could make an effort to offer in place versions of most functions. If these operations were available, then the Cython layer could switch to calling into them. In those cases where we really want a copy, we would allocate and copy into an empty table before calling into libcudf.\r\n\r\nEdit: modification in place only works at the libcudf level for fixed-width column types (so no strings, lists), and having in- and out-of-place modification for every operation is too much work without some significant motivating use case.\r\n\r\nSince we need a work-around that works for string/list columns that cannot by modified in-place _anyway_, I don't think this issue is a sufficiently motivating use case.\r\n\r\nThe above solution is a no-go, so what else could we do?\r\n\r\n- Given that we're trying to move to copy-on-write, we could go the other way and audit all places where `__setitem__` really is in place, and break that connection. ~Note that this is not actually copy-on-write, but copy-on-read so it's not a great option.~ Something close to this probably is copy-on-write, so looks perhaps reasonable.\r\n- ~Change the way `_mimic_inplace(self, other, inplace=True)` works: rather than rewriting where `self.data` points to, we could instead `memcopy` from `other.data` back into `self.data` and then drop `other`. This maintains the same memory footprint right now, at the cost of (another) full `memcopy`, and makes `__setitem__` really behave in place (even for views).~ As pointed out below, this doesn't work for non-fixed-width column dtypes.","closed":false,"closedAt":null,"comments":[{"id":"IC_kwDOBWUGps5M86bH","author":{"login":"shwina"},"authorAssociation":"CONTRIBUTOR","body":"Regardless of what solution (if any) we choose longer term:\r\n\r\n> Change the way _mimic_inplace(self, other, inplace=True) works:\r\n\r\nis an acceptable solution that we should be able to implement with very little code change, and should fix our behaviour for many of the buggy cases described.","createdAt":"2022-10-25T19:28:41Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/11990#issuecomment-1291036359","viewerDidAuthor":false},{"id":"IC_kwDOBWUGps5M9RLS","author":{"login":"shwina"},"authorAssociation":"CONTRIBUTOR","body":"Well, I guess I lied. Copying into the buffers works only for fixed width types, not variable width types (like strings)","createdAt":"2022-10-25T20:52:36Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/11990#issuecomment-1291129554","viewerDidAuthor":false},{"id":"IC_kwDOBWUGps5NBRQZ","author":{"login":"wence-"},"authorAssociation":"CONTRIBUTOR","body":"Can we leverage the current work introducing copy-on-write semantics (cc @galipremsagar) to square this circle in a nice way?\r\n\r\nIf we want views to behave like copies what does that mean?\r\n\r\n```\r\nsr = cudf.Series(...)\r\n\r\nsview = sr.iloc[:] # (or sr.copy() or sr.loc[:])\r\n\r\n# this makes a copy at the libcudf layer right now, \r\n# which we try and fix up to make sview == sr \r\n# this works in some cases but not others\r\nsr.iloc[...] = ... \r\n\r\n# What if we wanted sview != sr (copy-on-write)\r\n# Then we would just have to detach the view from sr\r\n# when making the update (which we do in a bunch of cases already)\r\n```","createdAt":"2022-10-26T14:54:54Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/11990#issuecomment-1292178457","viewerDidAuthor":false},{"id":"IC_kwDOBWUGps5NBR7x","author":{"login":"galipremsagar"},"authorAssociation":"CONTRIBUTOR","body":"I think we can make the view mechanism work in cudf with weak references, let me think a bit about this and get back.","createdAt":"2022-10-26T14:56:56Z","includesCreatedEdit":true,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/11990#issuecomment-1292181233","viewerDidAuthor":false},{"id":"IC_kwDOBWUGps5NBhgY","author":{"login":"wence-"},"authorAssociation":"CONTRIBUTOR","body":"> I think we can make the view mechanism work in cudf with weak references, let me think a bit about this and get back.\r\n\r\nNote that I _think_ we are \"accidentally\" doing this for many cases already ~(so it's possible no weak references are required)~\r\n\r\nEdit: we need reference tracking for the cases where a lazy copy is modified using an operation that is actually in-place at the libcudf level.","createdAt":"2022-10-26T15:43:22Z","includesCreatedEdit":true,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/11990#issuecomment-1292245016","viewerDidAuthor":false},{"id":"IC_kwDOBWUGps5NbHT-","author":{"login":"wence-"},"authorAssociation":"CONTRIBUTOR","body":"To summarise a discussion with @galipremsagar, @vyasr, and @mroeschke.\r\n\r\nAlthough there are at present inconsistencies in CUDF behaviour, they likely do not bite in too many cases (since people on the whole don't work with views).\r\n\r\nThe copy-on-write work in #11718 will (in an opt-in manner) remove the inconsistencies by removing the concept of a view (sharing data) and making everything a copy (albeit consed lazily).\r\n\r\nIn the fixed-width column case there might be a desire to expand the number of modifications in libcudf that actually operate in place (rather than being faked post-hoc via `_mimic_inplace`), but this becomes a much lower priority once copy-on-write becomes available (and then default).","createdAt":"2022-11-01T18:41:12Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/11990#issuecomment-1298953470","viewerDidAuthor":false},{"id":"IC_kwDOBWUGps5PPuX0","author":{"login":"wence-"},"authorAssociation":"CONTRIBUTOR","body":"Since this can bite in various circumstances here are some proposals:\r\n\r\n### Keep track of views and warn on read-after-write/write-after-write\r\n\r\nWhen we create a view `child` keep a weakref to it on the `parent` `Series`/`DataFrame` (and vice versa). When we do a write into `parent` (`child`) if there are any weakrefs that are live, walk through them and mark the `child` (`parent`) as invalid: any subsequent read or write on this object would raise an error.\r\n\r\nI suspect this is very similar to how the putative copy-on-write implementation keeps track of things and forces copies at the appropriate time. If so, we could probably piggy-back this warning/error system on that implementation (for the case when copy-on-write is _off_).\r\n\r\n### Restructure cuDF internals so that setitem/getitem are one level of indirection higher\r\n\r\nThe problems with views arise because views effectively take references to columns inside a `DataFrame` or `Series` which a subsequently write-after-read can't know about. If a view were of a Series and not a Column, then I _think_ the problems in this issue would not exist.\r\n\r\nI can't scope how much work this would be, but I suspect a lot.","createdAt":"2022-11-28T18:03:21Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/11990#issuecomment-1329522164","viewerDidAuthor":false}],"createdAt":"2022-10-25T17:17:48Z","id":"I_kwDOBWUGps5Uzlc_","labels":[{"id":"MDU6TGFiZWw1OTk2MjY1NjE=","name":"feature request","description":"New feature or request","color":"a2eeef"},{"id":"MDU6TGFiZWwxMDEzOTg3NTAz","name":"2 - In Progress","description":"Currently a work in progress","color":"fef2c0"},{"id":"MDU6TGFiZWwxMTM5NzQxMjEz","name":"cuDF (Python)","description":"Affects Python cuDF API.","color":"1d76db"}],"milestone":null,"number":11990,"projectCards":[{"project":{"name":"Feature Planning"},"column":{"name":"Needs prioritizing"}}],"projectItems":[],"reactionGroups":[],"state":"OPEN","title":"[ENH/QST] actually inplace updates in `__setitem__` and friends","updatedAt":"2022-12-01T15:48:15Z","url":"https://github.com/rapidsai/cudf/issues/11990"}

{"assignees":[],"author":{"id":"MDQ6VXNlcjY1NjIyODk=","is_bot":false,"login":"ShashaankV","name":""},"body":"Use case: Run a sliding window robust z-score as part of standard EEG preprocessing step. Point is to denoise a non-stationary signal. This is a general outlier detection procedure that could have value outside EEG. \r\n\r\n(There was a previous request last year but seems to have stalled: https://github.com/rapidsai/cudf/issues/2135)\r\n\r\nThe robust z-score uses the **median** for the first (expectation) and second (variance, standard deviation) moments. This is instead of the average. \r\n\r\nCurrent operation takes about 30 minutes for 10^7x20 element data frame in pandas. cuDF could bring this down to seconds. \r\n\r\n**Describe the solution you'd like**\r\nLike to have a median() agg added to rolling or UDF for apply. \r\n\r\nFor robust z the function is:\r\n\r\n$$z_i = \\kappa\\frac{x_i-median(x)}{median(absolute\\{(x_i-median(x))\\})}$$\r\n$$\\text{where } \\kappa\\textrm{ := scaling factor}$$\r\n$$x \\subseteq X \\text{, }X\\text{ column vector in DF} $$\r\n\r\n\r\nSo, some possible solution to get the sliding robust z once we have the median working with apply are: 1) run the median twice (once of the original and then again on the median absolute values of the substracted residuals), and 2) right a custom UDF once the median function solution is known. \r\n\r\n**Describe alternatives you've considered**\r\nI have tried writing a UDF but the issue is the **sort()** needed for the median calculation. I tried a numba nopython pandas rolling.apply solution. This works if I copy the windowed array (x2 = x.copy()). It spits out an error when run with cuDF. I believe it's a memory and/or broadcasting issue (I've seen two kinds of errors). If I don't copy then the pandas numba code sorts the original array and propagates this corrupt data back to the original DF.   \r\n\r\n**Additional context**\r\nHere is an example of the numba solution that works (this is for example to test on cuDF, of course pandas has a rolling median() agg). \r\n\r\n>code\r\n\r\n```\r\n@nb.jit(nopython=True)\r\ndef udf_median(x):\r\n  ##version 0\r\n  #mu = np.median(x)\r\n  ##version 1\r\n  x2 = x.copy()\r\n  x2.sort()\r\n  n = len(x2)\r\n  k = int(n/2) \r\n  if n%2 == 0:\r\n    mu = (x2[k]+x2[k+1])/2\r\n  else:\r\n    mu = x2[k]\r\n  return mu\r\n\r\n\r\n\r\ndf = pd.DataFrame()\r\ndf['a'] = (-5,-3,-1,0.2,-2)\r\ndf['b'] = (5,-3,1,-0.2,-2)\r\nprint('original df')\r\nprint(df)\r\nrolling = df.rolling(window=3,axis=0)\r\nprint(\"panda call\\nwin=3 rolling median\")\r\nprint(rolling.apply(udf_median, engine='numba', raw=True))\r\nprint('df after rolling call - if copy is not done, then corrupted original df')\r\nprint(df)\r\n\r\nprint(\"\\ncuDF call\")\r\ndf = cudf.DataFrame()\r\ndf['a'] = (-5,-3,-1,0.2,-2)\r\ndf['b'] = (5,-3,1,-0.2,-2)\r\nrolling = df.rolling(window=3,axis=0)\r\nprint(rolling.apply(udf_median))\r\n\r\n```\r\n\r\n>output\r\noriginal df\r\n     a    b\r\n0 -5.0  5.0\r\n1 -3.0 -3.0\r\n2 -1.0  1.0\r\n3  0.2 -0.2\r\n4 -2.0 -2.0\r\npanda call\r\nwin=3 rolling median\r\n     a    b\r\n0  NaN  NaN\r\n1  NaN  NaN\r\n2 -3.0  1.0\r\n3 -1.0 -0.2\r\n4 -1.0 -0.2\r\ndf after rolling call - if copy is not done, then corrupted original df\r\n(in this case the df is intact due to the copy function, comment that out to see the error)\r\n     a    b\r\n0 -5.0  5.0\r\n1 -3.0 -3.0\r\n2 -1.0  1.0\r\n3  0.2 -0.2\r\n4 -2.0 -2.0\r\n\r\ncuDF call\r\n\r\nRuntimeError                              Traceback (most recent call last)\r\n/usr/local/lib/python3.6/site-packages/numba/core/errors.py in new_error_context(fmt_, *args, **kwargs)\r\n    744     try:\r\n--> 745         yield\r\n    746     except NumbaError as e:\r\n\r\n40 frames\r\nRuntimeError: NRT required but not enabled\r\n\r\nDuring handling of the above exception, another exception occurred:\r\n\r\nLoweringError                             Traceback (most recent call last)\r\ncudf/_lib/rolling.pyx in cudf._lib.rolling.rolling()\r\n\r\ncudf/_lib/aggregation.pyx in cudf._lib.aggregation.make_aggregation()\r\n\r\ncudf/_lib/aggregation.pyx in cudf._lib.aggregation._AggregationFactory.from_udf()\r\n\r\n/usr/local/lib/python3.6/site-packages/numba/core/utils.py in reraise(tp, value, tb)\r\n     79     if value.__traceback__ is not tb:\r\n     80         raise value.with_traceback(tb)\r\n---> 81     raise value\r\n     82 \r\n     83 \r\n\r\nLoweringError: Failed in nopython mode pipeline (step: nopython mode backend)\r\nNRT required but not enabled\r\n\r\nFile \"<ipython-input-16-2c1e7f32fcdd>\", line 6:\r\ndef udf_median(x):\r\n    <source elided>\r\n  ##version 1\r\n  x2 = x.copy()\r\n  ^\r\n\r\nDuring: lowering \"$0.3 = call $0.2(func=$0.2, args=[], kws=(), vararg=None)\" at <ipython-input-16-2c1e7f32fcdd> (6)\r\n","closed":false,"closedAt":null,"comments":[{"id":"MDEyOklzc3VlQ29tbWVudDY5NjgyMjA1Mw==","author":{"login":"ShashaankV"},"authorAssociation":"NONE","body":"If someone solves this, I'd like to understand the solution because the denominator in the robust z-score is more complicated than a rolling median (https://medium.com/james-blogs/outliers-make-us-go-mad-univariate-outlier-detection-b3a72f1ea8c7). I'll need to write a UDF for the MAD that hopefully can use similar machinery needed to solve the rolling median. ","createdAt":"2020-09-22T16:10:19Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/6276#issuecomment-696822053","viewerDidAuthor":false},{"id":"MDEyOklzc3VlQ29tbWVudDY5NjkwNjY2Mg==","author":{"login":"jakirkham"},"authorAssociation":"MEMBER","body":"FWIW this is something I [solved before in C++]( https://github.com/nanshe-org/rank_filter/blob/49cd0a35998aaccebab680d14f0f3fb8ac85e5ea/include/rank_filter.hxx#L24 ). May be useful here too.","createdAt":"2020-09-22T18:39:35Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/6276#issuecomment-696906662","viewerDidAuthor":false},{"id":"MDEyOklzc3VlQ29tbWVudDY5NzkzNjgyNA==","author":{"login":"ShashaankV"},"authorAssociation":"NONE","body":"Thank you. Hoping for a higher level solution using the cuDF or other RAPIDS objects. However, I'll take a closer look at your C++ solution later. \r\n\r\nFYI - This is my latest version using pandas for calculating a rolling robust z-score (which calls for a rolling median and UDF). It takes 50 minutes per dataframe. Love to speed this up. \r\n\r\n```\r\n##CPU numba version\r\n@nb.njit()\r\ndef fun_mad(x):\r\n  return np.median(np.absolute(x - np.median(x)))\r\n\r\ndef rzscore(df,win):\r\n  mu = df.rolling(window=win).median() \r\n  mad = df.rolling(window=win).apply(fun_mad, engine='numba',raw=True) \r\n  df = 0.6745*(df.subtract(mu)).divide(mad)\r\n  return df\r\n\r\ndfz = rzscore(df,int(2*sHz))\r\n```","createdAt":"2020-09-23T19:51:53Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/6276#issuecomment-697936824","viewerDidAuthor":false},{"id":"MDEyOklzc3VlQ29tbWVudDcxMzIyODEyNQ==","author":{"login":"ShashaankV"},"authorAssociation":"NONE","body":"Working on a selection sorter UDF for the rolling median. ","createdAt":"2020-10-21T01:09:37Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/6276#issuecomment-713228125","viewerDidAuthor":false},{"id":"MDEyOklzc3VlQ29tbWVudDcxMzIzODk2Nw==","author":{"login":"jakirkham"},"authorAssociation":"MEMBER","body":"cc @gmarkall (in case you have ideas on the Numba side of things ðŸ™‚)","createdAt":"2020-10-21T01:46:58Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/6276#issuecomment-713238967","viewerDidAuthor":false},{"id":"MDEyOklzc3VlQ29tbWVudDcxMzI4MDE4Mg==","author":{"login":"ShashaankV"},"authorAssociation":"NONE","body":"Maybe crude but this UDF seems to work for rolling median with cuDF.\r\n\r\n\r\n```\r\ndef median_select(x):\r\n  #get min in array\r\n  minx = x[0]\r\n  for x2 in x[1:]:\r\n    if x2<minx:\r\n      minx = x2\r\n  #iterate until center index\r\n  kcenter = int(len(x)/2)\r\n  #if odd\r\n  if len(x)%2 != 0:\r\n    lb = minx\r\n    for k in range(kcenter):\r\n      ub = 1*10^100\r\n      for x2 in x:\r\n        if x2>lb and x2<ub:\r\n          ub = x2\r\n      lb = ub\r\n    mu = lb\r\n  #if even\r\n  else:\r\n    lb = minx\r\n    for k in range(kcenter-1):\r\n      ub = 1*10^100\r\n      for x2 in x:\r\n        if x2>lb and x2<ub:\r\n          ub = x2\r\n      lb = ub\r\n    mu = lb\r\n    lb = minx\r\n    for k in range(kcenter):\r\n      ub = 1*10^100\r\n      for x2 in x:\r\n        if x2>lb and x2<ub:\r\n          ub = x2\r\n      lb = ub\r\n    mu += lb\r\n    mu = mu/2\r\n  return mu\r\n```\r\n\r\n```\r\nwin = 28\r\nn = win+2\r\n\r\ndf = cudf.DataFrame()\r\ndf['a'] = np.random.normal(0,1,n)\r\ndf['b'] = np.random.normal(0,1,n)\r\nrolling = df.rolling(window=win,axis=0)\r\nprint(rolling.apply(median_select))\r\n\r\npdf = df.to_pandas()\r\nprint(np.median(pdf.iloc[:-2,:],axis=0))\r\nprint(np.median(pdf.iloc[1:-1,:],axis=0))\r\nprint(np.median(pdf.iloc[2:,:],axis=0))\r\n\r\n```","createdAt":"2020-10-21T03:49:25Z","includesCreatedEdit":true,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/6276#issuecomment-713280182","viewerDidAuthor":false},{"id":"MDEyOklzc3VlQ29tbWVudDcxMzMwMDU3NQ==","author":{"login":"ShashaankV"},"authorAssociation":"NONE","body":"This is two times slower than running the equivalent pandas rolling median. Could try a quicksort but not sure how to implement partition without generating new arrays or altering the original data. ","createdAt":"2020-10-21T04:47:59Z","includesCreatedEdit":true,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/6276#issuecomment-713300575","viewerDidAuthor":false},{"id":"MDEyOklzc3VlQ29tbWVudDc4MDEyMzQ3Ng==","author":{"login":"github-actions"},"authorAssociation":"NONE","body":"This issue has been marked rotten due to no recent activity in the past 90d. Please close this issue if no further response or action is needed. Otherwise, please respond with a comment indicating any updates or changes to the original issue and/or confirm this issue still needs to be addressed.","createdAt":"2021-02-16T21:17:39Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/6276#issuecomment-780123476","viewerDidAuthor":false}],"createdAt":"2020-09-20T04:50:18Z","id":"MDU6SXNzdWU3MDUwNDQ5MTc=","labels":[{"id":"MDU6TGFiZWw1OTk2MjY1NjE=","name":"feature request","description":"New feature or request","color":"a2eeef"},{"id":"MDU6TGFiZWwxMTM5NzQwNjY2","name":"libcudf","description":"Affects libcudf (C++/CUDA) code.","color":"c5def5"},{"id":"MDU6TGFiZWwxMTM5NzQxMjEz","name":"cuDF (Python)","description":"Affects Python cuDF API.","color":"1d76db"}],"milestone":null,"number":6276,"projectCards":[{"project":{"name":"Feature Planning"},"column":{"name":"Needs prioritizing"}}],"projectItems":[],"reactionGroups":[],"state":"OPEN","title":"[FEA] rolling median()","updatedAt":"2023-04-06T05:28:40Z","url":"https://github.com/rapidsai/cudf/issues/6276"}

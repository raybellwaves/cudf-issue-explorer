{"assignees":[],"author":{"id":"MDQ6VXNlcjExMjY5ODE=","is_bot":false,"login":"wence-","name":"Lawrence Mitchell"},"body":"**Is your feature request related to a problem? Please describe.**\r\n\r\nWhen running in a multi-gpu setting, message passing with ucx-py takes a `DeviceBuffer` and obtains the device memory pointer through the `__cuda_array_interface__`. This, correctly, marks the buffer as unspillable. \r\n\r\nIt would be nice if there were a way to expose a pointer that is marked as unspillable until the external library drops the reference (kind of like `acquire_spill_lock`). `ucx-py` could then use it, and scope the pointer use to the lifetime of the message request (once the request is completed, the pointer can be dropped and is available for spilling again).\r\n\r\n**Describe the solution you'd like**\r\n\r\nIf we were to hand back an object that had a `weakref.finalize(obj, unmark_spillable)` callback, when it was dropped, we could let the buffer be spillable again.\r\n\r\n**Describe alternatives you've considered**\r\n\r\nMaking ucx-py aware of cudf and using `acquire_spill_lock`.\r\n\r\ncc @madsbk / @vyasr / @galipremsagar ","closed":false,"closedAt":null,"comments":[{"id":"IC_kwDOBWUGps5lpgeO","author":{"login":"madsbk"},"authorAssociation":"MEMBER","body":"Agree, this would be very useful but notice we do something like this already when serializing. \r\n`SpillableBuffer.serialize()` returns a `Buffer` with the *spill lock* as owner:\r\nhttps://github.com/rapidsai/cudf/blob/branch-23.10/python/cudf/cudf/core/buffer/spillable_buffer.py#L460-L474","createdAt":"2023-09-04T14:38:52Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/14029#issuecomment-1705379726","viewerDidAuthor":false},{"id":"IC_kwDOBWUGps5lpnoR","author":{"login":"wence-"},"authorAssociation":"CONTRIBUTOR","body":"Ah, I think I hadn't spotted that. That also works I think, so things are less bad than I thought","createdAt":"2023-09-04T14:57:56Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/14029#issuecomment-1705409041","viewerDidAuthor":false}],"createdAt":"2023-09-01T16:35:34Z","id":"I_kwDOBWUGps5v69Fb","labels":[{"id":"MDU6TGFiZWw1OTk2MjY1NjE=","name":"feature request","description":"New feature or request","color":"a2eeef"},{"id":"MDU6TGFiZWwxMDEzOTg3MzUy","name":"0 - Backlog","description":"In queue waiting for assignment","color":"d4c5f9"},{"id":"MDU6TGFiZWwxMTM5NzQxMjEz","name":"cuDF (Python)","description":"Affects Python cuDF API.","color":"1d76db"},{"id":"MDU6TGFiZWwxMzIyMjUyNjE3","name":"Performance","description":"Performance related issue","color":"C2E0C6"},{"id":"MDU6TGFiZWwyNTQ2NTIxMDI0","name":"improvement","description":"Improvement / enhancement to an existing function","color":"bfd4f2"}],"milestone":{"number":20,"title":"Stabilizing large workflows (OOM, spilling, partitioning)","description":"","dueOn":null},"number":14029,"projectCards":[],"projectItems":[],"reactionGroups":[],"state":"OPEN","title":"[FEA] provide external libraries a way of getting a `DeviceBuffer` pointer that can become spillable again","updatedAt":"2023-09-04T14:57:56Z","url":"https://github.com/rapidsai/cudf/issues/14029"}

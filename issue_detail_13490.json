{"assignees":[],"author":{"id":"MDQ6VXNlcjE1MzgxNjU=","is_bot":false,"login":"vyasr","name":"Vyas Ramasubramani"},"body":"**Is your feature request related to a problem? Please describe.**\r\nlibcudf has multiple functions (both internal and external) for manipulating bitmasks. These functions often make use of bitwise operations and CUDA intrinsics in kernels, which may have sharp edges around when bitmasks contain uninitialized bits or in other ways. We recently uncovered one in #13479, and it was only uncovered via intermittent failures from dask_cudf (Python) tests.\r\n\r\n**Describe the solution you'd like**\r\nWe should consider adding more tests that directly play with bitmasks, perhaps bitmasks containing invalid data in certain ways, to better understand the potential failure modes. In some cases these may be test cases that we do not need to support since libcudf generally follows a \"garbage in, garbage out\" approach, but in some cases the \"garbage in\" may be generated by libcudf itself and therefore something that we need to support.\r\n\r\nI will update this issue with specific tests cases that may prove relevant:\r\n- A bitmask with enough bits that we have > 1 CUDA block of data, and potentially with junk bits either at the beginning or the end.\r\n","closed":false,"closedAt":null,"comments":[{"id":"IC_kwDOBWUGps5d-RQh","author":{"login":"wence-"},"authorAssociation":"CONTRIBUTOR","body":"Some (slightly unstructured) thoughts here.\r\n\r\n- The fix for #13479 (https://github.com/rapidsai/cudf/pull/13489) was actually a race condition (so only indirectly uninitialised bits). Unfortunately, it wasn't spotted by compute-sanitizer in synccheck mode, since, AFAICT synccheck only detects hazards on shared memory conflicts, whereas the relevant kernel in this case had a RAW-conflict in global memory.\r\n\r\n- Bitmasks allocations are always a multiple of 64 bytes (512 bits), and any words not contributing to the actual bitmask are left uninitialised. This has a twofold consequence, `memcheck` will not catch off-by-one errors (for most kernels) since the memory is _allocated_; `initcheck` complains on most `memcpy`-like operations because the source array for a bitmask is almost-always partially uninitialised. There is good reason not to fully initialise the extra bits by making an additional kernel call to memzero the relevant parts every time a bitmask is manipulated. However, it _might_ be worthwhile adapting all of the bitmask-manipulation kernels to explicitly zero out the trailing allocation (that doesn't correspond to an actual bitmask). That way we might be able to spot actual bugs due to `initcheck` errors. But see discussion in #12667.","createdAt":"2023-06-05T11:19:36Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/13490#issuecomment-1576604705","viewerDidAuthor":false}],"createdAt":"2023-06-01T17:09:13Z","id":"I_kwDOBWUGps5nhLre","labels":[{"id":"MDU6TGFiZWw1OTk2MjY1NjE=","name":"feature request","description":"New feature or request","color":"a2eeef"},{"id":"MDU6TGFiZWwxMDEzOTg3MzUy","name":"0 - Backlog","description":"In queue waiting for assignment","color":"d4c5f9"},{"id":"MDU6TGFiZWwxMDE2MzQyNTY3","name":"tests","description":"Unit testing for project","color":"204ea3"},{"id":"MDU6TGFiZWwxMTM5NzQwNjY2","name":"libcudf","description":"Affects libcudf (C++/CUDA) code.","color":"c5def5"}],"milestone":null,"number":13490,"projectCards":[],"projectItems":[],"reactionGroups":[],"state":"OPEN","title":"[FEA] Test more edge cases in bitmask operations","updatedAt":"2023-07-22T20:13:52Z","url":"https://github.com/rapidsai/cudf/issues/13490"}

{"assignees":[],"author":{"id":"MDQ6VXNlcjExMjY5ODE=","is_bot":false,"login":"wence-","name":"Lawrence Mitchell"},"body":"**Is your feature request related to a problem? Please describe.**\r\n\r\nTo date, cudf has attempted to match pandas semantics when matching join keys in a merge. libcudf does not perform merges between mismatching table dtypes. Consequently, the first step of a merge in cudf is to determine a \"common\" dtype for each pair of columns used as keys in the merge.\r\n\r\nThe pandas rules are mostly (though not completely since there is some under the table work that happens in the join algorithm) encoded in https://github.com/pandas-dev/pandas/blob/f7c73a5f1aaf0724598e60c0cc5732604ec842a8/pandas/core/reshape/merge.py#L1340\r\n\r\nThere are a few problems when trying to match these in cudf:\r\n\r\n- not all column types in pandas can be represented in cudf (we do not have an `object` column for example)\r\n- it is difficult to unambiguously determine the type promotion rules since they are not written down anywhere\r\n    - for example, promotion rules for categorical columns differ depending on whether the categorical is the left or right key.\r\n\r\nMoreover, there are other, correctness, problems. The current type promotion rules admit lossy conversions that can result in false positive matches in merges.\r\n\r\nExample:\r\n```\r\nleft = cudf.DataFrame({\"key\": [1, 2, 2**53]})\r\nright = cudf.DataFrame({\"key\": [2**53 + 1, 10]})\r\nright[\"key\"] = right.key.astype(\"uint64\")\r\nleft.merge(right, on=\"key\", how=\"inner\")\r\n#            key\r\n# 0  9.007199e+15\r\nleft\r\n#                key\r\n# 0                 1\r\n# 1                 2\r\n# 2  9007199254740992\r\nright\r\n#                key\r\n# 0  9007199254740993\r\n# 1                10\r\n```\r\n\r\nPandas is also susceptible to this, but produces a different wrong result.\r\n\r\nI would like to tighten up the rules in cudf, so that it is impossible for the user to get a \"surprising\" result without some explicit intervention on their behalf. We would also try and match pandas more closely where that is possible, but my preference is to be correct in a subset of cases over dubiously correct in a larger set.\r\n\r\n**Describe the solution you'd like**\r\n\r\nThere are, I think, three levels of things we could do:\r\n\r\n1. Push the burden of dtype matching completely on to the user: complain (raise) if merge keys do not match dtypes _exactly_\r\n2. Promote keys whose dtypes allow so safely (without needing to inspect values), and raise for cases where that is not possible. The user can still perform the merge by intentionally casting to matching types. But then they must know that it is safe.\r\n3. Try and match pandas promotions as closely as possible and accept that there might be false positives.\r\n\r\nI would like to go for (2). (1) is easiest; (3) is difficult, probably a moving target and can result in false positives without the user explicitly \"requesting\" them.\r\n\r\nWith cudf-pandas (2), I think, skates the line between ease of use and correctness reasonably well. We can run as much on the GPU as possible and raise (possibly providing a warning in pandas-compat mode) with fallback to CPU. When using cudf directly, users will hopefully be willing to accept a few more edge cases in the name of consistency. \r\n\r\n\r\nConcretely this would mean:\r\n\r\n- No casting for strings\r\n- No casting for lists\r\n- No casting for structs\r\n- Categoricals:\r\n    - if both columns are categorical and match, no casting\r\n    - if both columns are categorical and _do not_ match, raise[^1]\r\n    - if one column is categorical, unwrap, and go round again[^2]\r\n - No casting for decimals\r\n - No casting for datetimes[^3]\r\n - For numeric types, use a type promotion lattice that has lossless least upper bounds for all types[^4]\r\n\r\nFor numeric types, that means that we would only promote pairs of types where there exists a wider type whose values are uniquely and unambiguously mapped onto from the narrower types.\r\n\r\nFor example `(int32, uint32) -> int64` would be allowed, but merging a pair `(int32, uint64)` would raise (since there is no signed 128bit int that we could use). Similarly, we would safely be able to promote `(intX, floatY)` pairs (and similarly with `uintX`) as long as the integer type is 32 or fewer bits wide[^5].\r\n\r\n\r\n\r\n[^1]: I could also be convinced to unwrap and go round again, but that would lose information about the categorical nature of the inputs\r\n[^2]: Pandas behaviour in this case depends on whether the left or right key is categorical (and which merge type it is): it casts the non-categorical to object, and the categorical to its underlying dtype, then imperfectly goes through its matching process again\r\n[^3]: I haven't looked at what pandas does here, but I guess the other thing one could do is promote when one can losslessly convert\r\n[^4]: See, for example https://jax.readthedocs.io/en/latest/jep/9407-type-promotion.html though I disagree with their approach of selecting a \"weak\" float64 as the least upper bound for `(int64, uint64)`\r\n[^5]: Merging between float and int columns is kind of weird, so I could also be convinced to raise when merging between mismatching numeric kinds.","closed":false,"closedAt":null,"comments":[{"id":"IC_kwDOBWUGps5uBuce","author":{"login":"wence-"},"authorAssociation":"CONTRIBUTOR","body":"Another question that comes to mind is whether these _same_ rules should be applied to binops (there's a different set of rules in pandas for merges compared to binops AFAICT).","createdAt":"2023-12-07T19:06:30Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/14594#issuecomment-1845946142","viewerDidAuthor":false},{"id":"IC_kwDOBWUGps5uFntM","author":{"login":"wence-"},"authorAssociation":"CONTRIBUTOR","body":"Here's what I concretely propose for integer promotions:\r\n\r\n```\r\n      +----+    +-----+    +-----+    +-----+\r\n      | i8 |--->| i16 |--->| i32 |--->| i64 |\r\n      +----+    +--^--+    +--^--+    +--^--+\r\n                  /          /          /\r\n              /---'      /---'      /---'\r\n          /---'      /---'      /---'        \r\n      +--+-+    +---+-+    +---+-+    +-----+\r\n      | u8 |--->| u16 |--->| u32 |--->| u64 |\r\n      +----+    +-----+    +-----+    +-----+\r\n```\r\n\r\nFor floating point (noting that we don't have float 16 right now):\r\n\r\n```\r\n      +-----+    +-----+    +-----+\r\n      | f16 |--->| f32 |--->| f64 |\r\n      +-----+    +-----+    +-----+\r\n```\r\n\r\nThe thorny one is unifying these two. If you send (for example), the pair `(i16, f32)` to `f32`, and the pair `(u16, f32)` to `f32`, which is safe since you lose no data, then that breaks the lattice property of the promotion scheme with the consequence that type promotion is no longer associative. `((i16, u16),  f32) -> (i32, f32) -> f64`, but `(i16, (u16, f32)) -> (i16, f32) -> f32`.\r\n\r\nJax solves this problem by letting arbitrary width float win over arbitrary width integer, so that `(i64, f16) -> f16`. But I don't think that's a reasonable solution for cudf.\r\n\r\nWe can remove the lattice property and have integer to float conversions where they are lossless. The issue is that a sequence of merges might or might not raise depending on their order (and join reordering is a common optimisation).\r\n\r\nConsequently, having thought harder, I am inclined to raise for joins between integral and float keys, and promote safely using the lattices above for same-kind keys.","createdAt":"2023-12-08T11:01:47Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/14594#issuecomment-1846967116","viewerDidAuthor":false},{"id":"IC_kwDOBWUGps5uIxza","author":{"login":"mroeschke"},"authorAssociation":"CONTRIBUTOR","body":"Just for comparison, pandas essentially dispatches to `np.result_type` to determine promotion. This logic generally does not apply when an element is trying to be set into an existing typed column.\r\n\r\n```python\r\nIn [1]: import numpy as np\r\n\r\nIn [2]: types = [np.int8, np.int16, np.int32, np.int64, np.uint8, np.uint16, np.uint32, np.uint64, np.float32, np.float64]\r\n\r\nIn [3]: np.__version__\r\nOut[3]: '1.26.0'\r\n\r\nIn [4]: import itertools\r\n\r\nIn [5]: for typ1, typ2 in itertools.combinations(types, 2):\r\n    ...:     print(f\"{np.dtype(typ1)} + {np.dtype(typ2)} -> {np.result_type(typ1, typ2)}\")\r\n    ...: \r\nint8 + int16 -> int16\r\nint8 + int32 -> int32\r\nint8 + int64 -> int64\r\nint8 + uint8 -> int16\r\nint8 + uint16 -> int32\r\nint8 + uint32 -> int64\r\nint8 + uint64 -> float64\r\nint8 + float32 -> float32\r\nint8 + float64 -> float64\r\nint16 + int32 -> int32\r\nint16 + int64 -> int64\r\nint16 + uint8 -> int16\r\nint16 + uint16 -> int32\r\nint16 + uint32 -> int64\r\nint16 + uint64 -> float64\r\nint16 + float32 -> float32\r\nint16 + float64 -> float64\r\nint32 + int64 -> int64\r\nint32 + uint8 -> int32\r\nint32 + uint16 -> int32\r\nint32 + uint32 -> int64\r\nint32 + uint64 -> float64\r\nint32 + float32 -> float64\r\nint32 + float64 -> float64\r\nint64 + uint8 -> int64\r\nint64 + uint16 -> int64\r\nint64 + uint32 -> int64\r\nint64 + uint64 -> float64\r\nint64 + float32 -> float64\r\nint64 + float64 -> float64\r\nuint8 + uint16 -> uint16\r\nuint8 + uint32 -> uint32\r\nuint8 + uint64 -> uint64\r\nuint8 + float32 -> float32\r\nuint8 + float64 -> float64\r\nuint16 + uint32 -> uint32\r\nuint16 + uint64 -> uint64\r\nuint16 + float32 -> float32\r\nuint16 + float64 -> float64\r\nuint32 + uint64 -> uint64\r\nuint32 + float32 -> float64\r\nuint32 + float64 -> float64\r\nuint64 + float32 -> float64\r\nuint64 + float64 -> float64\r\nfloat32 + float64 -> float64\r\n```","createdAt":"2023-12-08T20:20:55Z","includesCreatedEdit":true,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/14594#issuecomment-1847794906","viewerDidAuthor":false}],"createdAt":"2023-12-07T19:04:54Z","id":"I_kwDOBWUGps55FBUr","labels":[{"id":"MDU6TGFiZWw1OTk2MjY1NjE=","name":"feature request","description":"New feature or request","color":"a2eeef"}],"milestone":null,"number":14594,"projectCards":[],"projectItems":[],"reactionGroups":[],"state":"OPEN","title":"[FEA] Tighten up promotion when merging with non-equal key column dtypes","updatedAt":"2024-03-04T15:41:47Z","url":"https://github.com/rapidsai/cudf/issues/14594"}

{"assignees":[],"author":{"id":"MDQ6VXNlcjc0MTY5MzU=","is_bot":false,"login":"ttnghia","name":"Nghia Truong"},"body":"Currently, many cudf's APIs (such as `copy_bitmask` or `valid_if` and many others) always generate an output bitmask if the input columns are nullable. However, the input columns may not have any null element. Thus, it may be a waste of time and memory to generate such a bitmask containing all valid bit. So, a good practice is to avoid generating a bitmask if the input does not contain any null element. Some APIs have already followed this practice, but not all.\r\n\r\nHowever, if not generating a bitmask for the output, there may be potential issues emerging from the inconsistency between the input and output. Consider an example that an algorithm processing data through several stages. One of the intermediate stages cuts out the bitmask from its output, but all the subsequent stages continue to use the nullable information from the first input. In such cases, the system may crash, or some stages throw an exception, or the final result is undefined. \r\n\r\nSo, the question here is, should we keep the consistency between the input and output column? (i.e., if the input column has a bitmask, should we always generate a bitmask for the output column even if it doesn't have any null?)\r\n\r\n---------\r\nI have observed a lot of bugs that emerged due to mixing `nullable()` and `null_count()` in the current cudf implementation. Thus, I think a good way to avoid (maybe) all potential issues is to totally remove the `nullable()` API and use `null_count()` all the time. Maybe this is a little bit more expensive for the users to execute the code, but it could definitely eliminate all the headaches from having unexpected bugs and make developers/users much happier.","closed":false,"closedAt":null,"comments":[{"id":"MDEyOklzc3VlQ29tbWVudDg1NjQxNDgyNQ==","author":{"login":"harrism"},"authorAssociation":"MEMBER","body":"I don't think we should force null counting until we have memoization of the null count.","createdAt":"2021-06-08T03:43:55Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/8454#issuecomment-856414825","viewerDidAuthor":false},{"id":"MDEyOklzc3VlQ29tbWVudDg1NjQxODk4Mw==","author":{"login":"ttnghia"},"authorAssociation":"CONTRIBUTOR","body":"Does that mean we already have a plan for implementing null count memoization?","createdAt":"2021-06-08T03:57:44Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/8454#issuecomment-856418983","viewerDidAuthor":false},{"id":"MDEyOklzc3VlQ29tbWVudDg1NjQyNDI2Nw==","author":{"login":"harrism"},"authorAssociation":"MEMBER","body":"Please ignore my comment. Column null_count is already memoized. I was thinking of something else.","createdAt":"2021-06-08T04:12:52Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/8454#issuecomment-856424267","viewerDidAuthor":false},{"id":"MDEyOklzc3VlQ29tbWVudDg1NjcxNTY2Mw==","author":{"login":"davidwendt"},"authorAssociation":"CONTRIBUTOR","body":"I think the issue is the handling of sliced columns specifically but maybe there are other examples.\r\n\r\nIf a column does not contain a bitmask, then a sliced column will also not have a bitmask and `copy_bitmask` returns a nullptr bitmask.\r\n\r\nIf a column does contain a bitmask, then a sliced column will also have a bitmask but the sliced region _may_ technically contain no null entries regardless if the source column contains nulls or not. Here, `copy_bitmask` will create an appropriate sliced copy of the bitmask. Having `copy_bitmask` also check to see if all the copied bits are also all set (non-null) seems unnecessarily expensive.\r\n\r\nI think it is reasonable for `copy_bitmask` to return a bitmask if the input `column_view` contains a bitmask without requiring it to also check the bits within the `column_view`'s range.","createdAt":"2021-06-08T12:18:32Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[{"content":"THUMBS_UP","users":{"totalCount":1}}],"url":"https://github.com/rapidsai/cudf/issues/8454#issuecomment-856715663","viewerDidAuthor":false},{"id":"MDEyOklzc3VlQ29tbWVudDg1NjcyNjgyMQ==","author":{"login":"ttnghia"},"authorAssociation":"CONTRIBUTOR","body":"Thanks David. I raised this issue that includes such specific case but not just for it. More generally, I see that there are a lot of places where people mixing `nullable` and `null_count`. These APIs are similar but may yield different/unexpected/wrong results if we don't pay enough attention to their use contexts.","createdAt":"2021-06-08T12:34:43Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/8454#issuecomment-856726821","viewerDidAuthor":false},{"id":"MDEyOklzc3VlQ29tbWVudDg1NzA3MjgwMQ==","author":{"login":"vyasr"},"authorAssociation":"CONTRIBUTOR","body":"I interpret `nullable` as \"this column may contain nulls\" and `has_nulls` (`null_count() > 0`) as \"this column currently contains nulls\". The former is a semantic distinction about the type of data that is up to the user, whereas the latter is a less fundamental property that only describes the current state of the data. As a consumer of this API I would not expect non-nullable outputs from a `libcudf` function that I called with nullable inputs, except in specific scenarios like reductions where there is some well-defined expected behavior for how nulls are removed. Assuming that you're not proposing to make columns always nullable (which I assume is a non-starter) I wouldn't want nullability to suddenly vanish in the middle of a pipeline.\r\n\r\nThat said, while I don't think we can optimize away the allocation of the bitmask, parts of libcudf can probably benefit significantly by using `has_nulls` rather than `nullable` to dispatch code paths. By that, I mean that in many cases the only difference between how some function should operate on a non-nullable column and a nullable column with zero nulls is the allocation of the null mask. In cases where that is true, it should be sufficient to simply allocate an all valid null mask and then follow the same code path that would be used for a non-nullable column. I don't know if/how much we leverage that throughout libcudf. Taking advantage of that would not address your concerns about misuse of `has_nulls` vs `nullable` leading to incorrect behavior, but it might help ameliorate performance issues in the case of nullable columns that have no nulls.","createdAt":"2021-06-08T19:57:35Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/8454#issuecomment-857072801","viewerDidAuthor":false},{"id":"MDEyOklzc3VlQ29tbWVudDg1NzEyMDY4OA==","author":{"login":"jrhemstad"},"authorAssociation":"CONTRIBUTOR","body":"> These APIs are similar but may yield different/unexpected/wrong results if we don't pay enough attention to their use contexts.\r\n\r\nI'm not familiar with a case where the choice of `nullable` vs `has_nulls` will end up in wrong results. I'd think the only difference is in performance. Do you have an example of a bug because of this? ","createdAt":"2021-06-08T20:42:01Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/8454#issuecomment-857120688","viewerDidAuthor":false},{"id":"MDEyOklzc3VlQ29tbWVudDg1NzEzNDgzNw==","author":{"login":"ttnghia"},"authorAssociation":"CONTRIBUTOR","body":"Hi Jake. This is an example: https://github.com/rapidsai/cudf/pull/8374/files. The bug was reported from the Spark team when the given data have inconsistency in nullability (comparing two structs columns both having no null but one has a bitmask). We have that bug not because we implemented the library incorrectly at the beginning. It is just a hole in functionalities of `nullable` and `null_count` that we support.\r\n\r\nOne can argue that if we are careful enough, pay attention enough to the meaning of `nullable` and `has_null` then we can avoid all bugs in our softwares. However, how can we guarantee that we will always pay \"enough attention\" throughout the development time? Everybody can make a mistake. If there exists any potential way leading to that mistake, we may accidentally step on that way eventually. The best (and only) way to avoid mistake(s) is to totally remove such potential way from our path.","createdAt":"2021-06-08T20:54:27Z","includesCreatedEdit":true,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/8454#issuecomment-857134837","viewerDidAuthor":false},{"id":"MDEyOklzc3VlQ29tbWVudDg1NzE0MDk4Mw==","author":{"login":"jrhemstad"},"authorAssociation":"CONTRIBUTOR","body":"> We have that bug not because we implemented the library incorrectly at the beginning. \r\n\r\nMy understanding is that that bug was because we weren't passing `column_nullability::FORCE` like was done in https://github.com/rapidsai/cudf/pull/7963 ","createdAt":"2021-06-08T20:59:40Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/8454#issuecomment-857140983","viewerDidAuthor":false},{"id":"MDEyOklzc3VlQ29tbWVudDg1NzE0NTc0MQ==","author":{"login":"ttnghia"},"authorAssociation":"CONTRIBUTOR","body":"Yes, passing in `...::FORCE` will produce the correct result. However, you will always pay for the cost of materializing the nullability into a real column.","createdAt":"2021-06-08T21:04:06Z","includesCreatedEdit":true,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/8454#issuecomment-857145741","viewerDidAuthor":false},{"id":"IC_kwDOBWUGps45xqEM","author":{"login":"github-actions"},"authorAssociation":"NONE","body":"This issue has been labeled `inactive-90d` due to no recent activity in the past 90 days. Please close this issue if no further response or action is needed. Otherwise, please respond with a comment indicating any updates or changes to the original issue and/or confirm this issue still needs to be addressed.","createdAt":"2021-11-15T21:03:45Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/8454#issuecomment-969318668","viewerDidAuthor":false}],"createdAt":"2021-06-07T21:45:24Z","id":"MDU6SXNzdWU5MTM5Nzk5ODE=","labels":[{"id":"MDU6TGFiZWw1OTk2MjY1NjE=","name":"feature request","description":"New feature or request","color":"a2eeef"},{"id":"MDU6TGFiZWw1OTk2MjY1NjQ=","name":"question","description":"Further information is requested","color":"D4C5F9"},{"id":"MDU6TGFiZWwxMTM5NzQwNjY2","name":"libcudf","description":"Affects libcudf (C++/CUDA) code.","color":"c5def5"}],"milestone":null,"number":8454,"projectCards":[{"project":{"name":"Feature Planning"},"column":{"name":"Needs prioritizing"}}],"projectItems":[],"reactionGroups":[],"state":"OPEN","title":"[FEA] Better handling for nullable columns that do not have any null element","updatedAt":"2022-11-21T04:12:36Z","url":"https://github.com/rapidsai/cudf/issues/8454"}

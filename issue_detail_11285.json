{"assignees":[{"id":"MDQ6VXNlcjM5NDM3NjE=","login":"bdice","name":"Bradley Dice"}],"author":{"id":"MDQ6VXNlcjExMjY5ODE=","is_bot":false,"login":"wence-","name":"Lawrence Mitchell"},"body":"A common pattern in dask is to shuffle distributed data around by some hash-based index. For example, this comes up in merging dataframes. Since the determination of index buckets is typically carried out independently from the splitting of the dataframe, this turns into calls to `libcudf.partitioning.partition`. The other option for this particular case would be to call `libcudf.hash.hash_partition`. The latter appears  to be signficantly (~5x) faster for large dataframes (code attached below, which partitions a dataframe with row columns and 100_000_000 rows on the first column into a configurable number of partitions, for the results below I used 10). Typical numbers of partitions for this use case are likely O(10-1000). Although this performance difference is not the order one cost in a distributed shuffle, flipping the switch from partition by index to partition by hash in dask-cuda provides a 10% speedup in some benchmarks (see rapidsai/dask-cuda#952).\r\n\r\n```\r\n$ python scatter-test.py\r\npartition-by-indices: 52ms\r\npartition-by-hash: 9.5ms\r\n```\r\n\r\nTo help the timings for the `partition-by-indices` case, I only compute the indices to partition on once. Profiling with nsight shows this takes ~2.7ms. The `partition` call takes 52 ms (of which `scatter` takes 22ms), in contrast `hash-and-scatter` in one go via `hash_partition` takes 9.5ms. Since `partition` by indices needs to read an extra column (the indices), I might expect things to be a bit slower, but this large difference was a bit surprising.\r\n\r\nThere's a note in the partitioning code that it might make sense to avoid atomics:\r\n\r\nhttps://github.com/rapidsai/cudf/blob/ec0b32bf73fc725982f62b0932782718d3886125/cpp/src/partitioning/partitioning.cu#L631\r\n\r\nAside: the pathological case of `npartitions == 1` is a factor of 2x slower for the partition-by-indices case, and 10x slower for partition-by-hash (probably worthwhile dispatching into a fast-path copy for that).\r\n\r\n```python\r\nimport rmm\r\nimport cudf\r\nimport cudf._lib as libcudf\r\nimport cupy\r\nimport time\r\n\r\n\r\ndef build_dataframe(nrows):\r\n    return cudf.DataFrame({\"key\": cupy.arange(nrows),\r\n                           \"value\": cupy.arange(nrows)})\r\n\r\n\r\ndef partition_by_indices(df, indices, npartitions):\r\n    cols, offsets = libcudf.partitioning.partition(\r\n        list(df._columns),\r\n        indices,\r\n        npartitions\r\n    )\r\n    return cols, offsets\r\n\r\n\r\ndef partition_by_hash(df, key, npartitions):\r\n    cols, offsets = libcudf.hash.hash_partition(\r\n        list(df._columns),\r\n        [df._column_names.index(key)],\r\n        npartitions\r\n    )\r\n    return cols, offsets\r\n\r\n\r\ndef run(*, nrows=10**8, with_pool=True, npartitions=10):\r\n    rmm.reinitialize(pool_allocator=with_pool)\r\n    df = build_dataframe(nrows)\r\n    key = \"key\"\r\n    indices = (libcudf.hash.hash([df[key]._column], \"murmur3\") % npartitions)\r\n    start = time.time()\r\n    for _ in range(100):\r\n        _ = partition_by_indices(df, indices, npartitions)\r\n    end = time.time()\r\n    print(f\"partition-by-indices: {(end - start)*10:.3g}ms\")\r\n    start = time.time()\r\n    for _ in range(100):\r\n        _ = partition_by_hash(df, key, npartitions)\r\n    end = time.time()\r\n    print(f\"partition-by-hash: {(end - start)*10:.3g}ms\")\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    run(nrows=10**8, with_pool=True, npartitions=10)\r\n```\r\n\r\ncc: @bdice, @shwina \r\n\r\n","closed":false,"closedAt":null,"comments":[{"id":"IC_kwDOBWUGps5GxJHs","author":{"login":"bdice"},"authorAssociation":"CONTRIBUTOR","body":"Assigning myself for now - I have some ideas I'd like to explore for improvement. If someone else is interested in this before I get a chance to work on it, please reach out and I can share my thoughts!","createdAt":"2022-07-18T12:30:05Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/11285#issuecomment-1187287532","viewerDidAuthor":false},{"id":"IC_kwDOBWUGps5ImS5D","author":{"login":"github-actions"},"authorAssociation":"NONE","body":"This issue has been labeled `inactive-30d` due to no recent activity in the past 30 days. Please close this issue if no further response or action is needed. Otherwise, please respond with a comment indicating any updates or changes to the original issue and/or confirm this issue still needs to be addressed. This issue will be labeled `inactive-90d` if there is no activity in the next 60 days.","createdAt":"2022-08-17T13:17:18Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/11285#issuecomment-1217998403","viewerDidAuthor":false}],"createdAt":"2022-07-18T11:46:41Z","id":"I_kwDOBWUGps5N8_QN","labels":[{"id":"MDU6TGFiZWw1OTk2MjY1NjE=","name":"feature request","description":"New feature or request","color":"a2eeef"},{"id":"MDU6TGFiZWwxMTM5NzQwNjY2","name":"libcudf","description":"Affects libcudf (C++/CUDA) code.","color":"c5def5"},{"id":"MDU6TGFiZWwxMzIyMjUyNjE3","name":"Performance","description":"Performance related issue","color":"C2E0C6"}],"milestone":null,"number":11285,"projectCards":[{"project":{"name":"Feature Planning"},"column":{"name":"Needs prioritizing"}}],"projectItems":[],"reactionGroups":[{"content":"THUMBS_UP","users":{"totalCount":1}}],"state":"OPEN","title":"[FEA] Potential missing performance in `partitioning.partition` (compared to `hash.hash_partition`)","updatedAt":"2023-04-02T22:40:23Z","url":"https://github.com/rapidsai/cudf/issues/11285"}

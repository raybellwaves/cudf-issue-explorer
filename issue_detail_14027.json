{"assignees":[],"author":{"id":"MDQ6VXNlcjEwNjQ3MDgy","is_bot":false,"login":"mroeschke","name":"Matthew Roeschke"},"body":"**Is your feature request related to a problem? Please describe.**\r\nWould be nice if `hash(CategoricalDtype(...))` was supported\r\n\r\n```\r\nIn [9]: import cudf\r\n\r\nIn [10]: import pandas\r\n\r\nIn [11]: hash(cudf.CategoricalDtype(list(\"abc\")))\r\n---------------------------------------------------------------------------\r\nTypeError                                 Traceback (most recent call last)\r\nCell In[11], line 1\r\n----> 1 hash(cudf.CategoricalDtype(list(\"abc\")))\r\n\r\nTypeError: unhashable type: 'CategoricalDtype'\r\n\r\nIn [12]: hash(pandas.CategoricalDtype(list(\"abc\")))\r\nOut[12]: 1532899084736511412\r\n```\r\n\r\n**Describe the solution you'd like**\r\nDefine `__hash__` on `CategoricalDtype`\r\n\r\n**Describe alternatives you've considered**\r\nCustom hash based on order and categories\r\n\r\n**Additional context**\r\nAdd any other context, code examples, or references to existing implementations about the feature request here.\r\n","closed":false,"closedAt":null,"comments":[{"id":"IC_kwDOBWUGps5leyQG","author":{"login":"wence-"},"authorAssociation":"CONTRIBUTOR","body":"Hmmm, this opens a can of worms:\r\n```\r\nimport cudf\r\ndt = cudf.CategoricalDtype([\"a\", \"b\", \"c\"])\r\nhash(dt) # TypeError\r\nhash(dt.categories) # works, dt.categories is a `StringIndex`, so that's immutable, so hashing is ok.\r\nhash(dt.categories._column) # works?! This seems bad, since a column is _not_ immutable\r\nhash(cudf.StringIndex([\"a\", \"b\", \"c\"])) == hash(cudf.StringIndex([\"a\", \"b\", \"c\"])) # False, uh-oh\r\n```\r\n\r\nWhat is going on?\r\n\r\nRecall that if you define no dunder ops on a class, then you get `__eq__` and `__hash__` from `object`, which uses `id` for equality and a hash of `id` for `__hash__`.\r\n\r\nIf you define a class that sets `__eq__` but not `__hash__` then the interpreter automatically sets `__hash__ = None`, to indicate that the object is unhashable. Since it can't automatically construct a hash function that satisfies the invariant `x == y => hash(x) == hash(y) and x is y`. See https://docs.python.org/3/reference/datamodel.html#object.__hash__\r\n\r\n`Column`s and `Index`s have `__eq__` defined, so why can we hash them? Turns out the `__eq__` method is set programmatically through a mixin class, through `__init_subclass__`, and it appears that this is sufficiently dynamic that the interpreter doesn't spot the `__eq__` method and set `__hash__ = None`.\r\n\r\n`CategoricalDtype` explicitly defines `__eq__`, hence we get `__hash__ = None`.\r\n\r\nTo hash this we need to compute a deterministic hash of the categories, and mix with the ordered flag (as you note). This requires, ideally, a libcudf implementation of a hash of a column of values: right now all of the hashes that are implemented produce a per-row hash.","createdAt":"2023-09-01T11:00:44Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/14027#issuecomment-1702568966","viewerDidAuthor":false}],"createdAt":"2023-08-31T21:45:05Z","id":"I_kwDOBWUGps5v1u4T","labels":[{"id":"MDU6TGFiZWw1OTk2MjY1NjE=","name":"feature request","description":"New feature or request","color":"a2eeef"},{"id":"MDU6TGFiZWwxMTM5NzQxMjEz","name":"cuDF (Python)","description":"Affects Python cuDF API.","color":"1d76db"}],"milestone":null,"number":14027,"projectCards":[],"projectItems":[],"reactionGroups":[],"state":"OPEN","title":"[FEA] Define `__hash__` on CategoricalDtype","updatedAt":"2023-09-01T11:00:44Z","url":"https://github.com/rapidsai/cudf/issues/14027"}

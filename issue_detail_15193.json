{"assignees":[],"author":{"id":"MDQ6VXNlcjEyNzI1MTEx","is_bot":false,"login":"GregoryKimball","name":"Gregory Kimball"},"body":"**Is your feature request related to a problem? Please describe.**\r\nArrow is in general a difficult dependency to work with, increasing build system complexity and fragility on its own while simultaneously expanding the full dependency tree, which particularly complicates use cases like conda where it leads to meaningful constraints on core system packages like protobuf, abseil, or the AWS SDK. This often hinders developer velocity when builds or CI are broken, but can also have far-reaching impacts when it creates problems with installation or running in specific environments. To prevent this, we would like to reduce or remove our dependence on Arrow libraries entirely.\r\n\r\nCurrently cudf makes use of Arrow in various ways at different levels of the stack. The primary uses of Arrow boil down to interop with host Arrow data and I/O with specific types of files. This involves interaction at both the Python layer via pyarrow, at the Cython layer (also via pyarrow), and in C++. Both Cython and C++ interactions are particularly problematic because they involve C-level interactions, which sets ABI-level constraints that are significantly tighter than we would like while also significantly complicating build (CMake, Python builds) and packaging (narrow Arrow version support ranges leading to limited support of other packages in the dependency tree). Python interactions are generally less difficult to work around, especially since Python code can be written to dynamically adapt to the pyarrow version.\r\n\r\n**Describe the solution you'd like**\r\n\r\nWe should look to remove the Arrow dependencies from the various layers of cudf (Java, Python, Cython, C++) to the greatest extent possible, ideally entirely.\r\n\r\nFor Arrow Array interop code, this can be accomplished by using the Arrow C Data Interface (see #5097), which provides an ABI-stable way to interchange Arrow data without directly using Arrow libraries. To make this even easier, the [nanoarrow](https://github.com/apache/arrow-nanoarrow) library was created to support clients that wish to produce or interpret [Arrow C Data](https://arrow.apache.org/docs/format/CDataInterface.html) and [Arrow C Streams](https://arrow.apache.org/docs/format/CStreamInterface.html) structures, without having to include a dependency on libarrow. We can make use of that (see also #13678 which discusses this in depth). For Python interaction we can use [Arrow's pycapsule interface](https://arrow.apache.org/docs/format/CDataInterface/PyCapsuleInterface.html), which provides a standard way to interchange this data from Python. We can write Cython code leveraging this interface to get Arrow C Data from pyarrow objects without relying directly on pyarrow's Cython, therefore also allowing us to remove this dependency from the Cython layer.\r\n\r\nFor I/O, the question is a bit trickier. We currently have limited usage of libarrow headers in our C++, and those features largely exist only for Python support for reading Arrow's NativeFiles. We could in principle remove those from the C++ entirely, which would in turn allow us to remove libarrow as a dependency of libcudf. However, libcudf tests would still need libarrow (removing that dependency would require significant additional work). Moreover, those features would still be used by cudf Cython, so we would just be limiting the dependency. However, this could at least allow us to remove Arrow as a build-time dependency for both libcudf and the low-level pylibcudf Python API (#13921) that we are currently developing, which would still be a significant improvement since it would avoid imposing the Arrow dependency on low-level consumers of our APIs at the Python level. Then we could come back to working on replacing the cudf Cython usage.\r\n\r\nBased on the above, the current plan is the following:\r\n1. Remove libarrow as a dependency of libcudf/pylibcudf:\r\n    a. Remove the compiled parts of `arrow_io_source.cpp` and make `arrow_io_source.hpp` a standalone header not compiled by anything in libcudf.\r\n    b. Rewrite cudf Cython to use the arrow headers directly.\r\n    c. Add new interop code that uses the Arrow C Data interface (see #15047)\r\n    d. Rewrite Python interop code to call through to the new interfaces\r\n    e. Remove the old Cython bindings for interop\r\n2. Remove pyarrow Cython linkages from cudf Cython\r\n    a. This will require some exploration as to how we can maintain performant file reading. We may have to implement our own minimal version of something like Arrow's NativeFile reader interface.\r\n    b. Once the above is done, we'll need to rewrite cuIO C++ to consume this interface and remove the current functions.\r\n3. Rewrite libcudf tests to remove libarrow dependence.\r\n    a. This will require further investigation into how tests could be rewritten without Arrow. One possibility would be rewriting these tests as pylibcudf tests (see #15133) that use pyarrow instead (only the Python API, no Cython). That would give us access to the same functionality without tying us to linking to the libarrow library\r\n\r\n**Additional context**\r\n\r\nCode pointers where libarrow is used in 24.04\r\n| Source file | Arrow include | Notes |\r\n|---|---|---|\r\n| `detail/interop.hpp` | `api.h` | `to_arrow_array` uses many array classes: `arrow::*Array`, `arrow::TimeUnit::*`, `arrow::*Type` also `arrow::MemoryPool`, `arrow::Scalar`, `arrow::Table`. I believe all of these are covered by nanoarrow |\r\n| `include/cudf/interop.hpp`  | `api.h` | uses `arrow::Table`, `arrow::MemoryPool`, `arrow::default_memory_pool`, `arrow::Scalar`. I believe all of these are covered by nanoarrow |\r\n| `include/cudf/io/arrow_io_source.hpp` | `filesystem/filesystem.h` <br> `io/interfaces.h`  | uses `arrow::io:RandomAccessFile`, `arrow::fs::FileSystem`. See #13698 for the work to refactor `arrow_io_source` out of `datasource` |\r\n| `include/cudf/io/arrow_io_source.cpp` | `buffer.h` <br> `filesystem/filesystem.h` <br> `result.h`  | uses `arrow::Buffer`, `arrow::fs::FileSystemFromUri`, |\r\n| `src/io/utilities/datasource.cpp` | `io/memory.h` | to be solved by #15189 |\r\n\r\n| Test file | Arrow include | Notes |\r\n|---|---|---|\r\n| `tests/interop/arrow_utils.hpp` | `util/bitmap_builders.h` for `arrow::internal::BytesToBits` | Also uses many arrow types such as: `arrow::Array`, `arrow:DictionaryArray`, `arrow::dictionary`, `arrow::Table`,  `arrow::Decimal128Builder`, `arrow::decimal`, `arrow::default_memory_pool`, `arrow::ListArray`, `arrow::list` , `arrow::Buffer`, `arrow::StringBuilder`, `arrow::StringArray` , `arrow::BooleanArray`, `arrow::BooleanBuilder` <br> needs research - can all of these references be migrated to nanoarrow? |\r\n| `tests/io/arrow_io_source_test.cpp`  | `io/api.h`  <br> `filesystem/filesystem.h` <br> `filesystem/s3fs.h` <br> `util/config.h` | uses `arrow::fs::FileSystemFromUri`, `arrow::fs::EnsureS3Finalized` |\r\n| `tests/io/json_test.cpp` | `io/api.h` | Uses `arrow::io::ReadableFile` as part of a test for reading from an `ArrowFileSource` |\r\n| `tests/io/csv_test.cpp` | `io/api.h` | uses `arrow::io::ReadableFile` |\r\n| `tests/quantiles/percentile_approx_test.cpp` | `util/tdigest.h` | uses `arrow::internal::TDigest`. presumably we could replace this with our own limited implementation |\r\n","closed":false,"closedAt":null,"comments":[{"id":"IC_kwDOBWUGps51izBc","author":{"login":"vyasr"},"authorAssociation":"CONTRIBUTOR","body":"Other relevant issues:\r\n- #5097 \r\n- #13678 ","createdAt":"2024-02-29T22:10:42Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/15193#issuecomment-1972056156","viewerDidAuthor":false},{"id":"IC_kwDOBWUGps51q9wX","author":{"login":"vyasr"},"authorAssociation":"CONTRIBUTOR","body":"One important correction to the table above, nanoarrow does not support scalars and neither does the Arrow C data interface, which focuses only on arrays. Previously this was a significant concern due to concerns with Python interoperability, but it looks like pyarrow 13 patched in some critical support for scalar->array conversion that ought to make this concern moot for us now. See #15213","createdAt":"2024-03-02T02:11:49Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/15193#issuecomment-1974197271","viewerDidAuthor":false},{"id":"IC_kwDOBWUGps52TmKu","author":{"login":"vyasr"},"authorAssociation":"CONTRIBUTOR","body":"I've substantially updated this issue with a more holistic discussion of how we can stage the removal of Arrow at different layers of our library (C++, Cython, Python).","createdAt":"2024-03-08T00:42:09Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[{"content":"HEART","users":{"totalCount":1}}],"url":"https://github.com/rapidsai/cudf/issues/15193#issuecomment-1984848558","viewerDidAuthor":false},{"id":"IC_kwDOBWUGps52wJWC","author":{"login":"zeroshade"},"authorAssociation":"CONTRIBUTOR","body":"Just wanted to point out that a big step towards this is the work started in https://github.com/rapidsai/cudf/pull/15047 and discussed in https://github.com/rapidsai/cudf/issues/14926. Once the `to_arrow_device` and `from_arrow_device` functionality is crafted, it should be pretty simple to re-implement several of the interoperability areas in terms of the Arrow C Data and Device interfaces, making strides towards eliminating the need for libarrow as a dependency in favor of nanoarrow\r\n\r\nEDIT: Just re-read and saw this was already mentioned in the OP.... oops :smile: ","createdAt":"2024-03-12T18:52:26Z","includesCreatedEdit":true,"isMinimized":false,"minimizedReason":"","reactionGroups":[{"content":"THUMBS_UP","users":{"totalCount":2}}],"url":"https://github.com/rapidsai/cudf/issues/15193#issuecomment-1992332674","viewerDidAuthor":false},{"id":"IC_kwDOBWUGps52-DxU","author":{"login":"vyasr"},"authorAssociation":"CONTRIBUTOR","body":"Yup! Your PR was top of mind while writing up this issue!","createdAt":"2024-03-13T22:11:24Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/15193#issuecomment-1995979860","viewerDidAuthor":false}],"createdAt":"2024-02-29T17:13:26Z","id":"I_kwDOBWUGps6A2XsD","labels":[{"id":"MDU6TGFiZWw1OTk2MjY1NjE=","name":"feature request","description":"New feature or request","color":"a2eeef"},{"id":"MDU6TGFiZWwxMTM5NzQwNjY2","name":"libcudf","description":"Affects libcudf (C++/CUDA) code.","color":"c5def5"},{"id":"MDU6TGFiZWwxMTM5NzQxMjEz","name":"cuDF (Python)","description":"Affects Python cuDF API.","color":"1d76db"}],"milestone":{"number":25,"title":"Helps libcudf C++ integrations","description":"","dueOn":null},"number":15193,"projectCards":[],"projectItems":[],"reactionGroups":[],"state":"OPEN","title":"[FEA] Reduce arrow library dependencies in cudf","updatedAt":"2024-03-13T22:11:24Z","url":"https://github.com/rapidsai/cudf/issues/15193"}

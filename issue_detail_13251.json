{"assignees":[{"id":"MDQ6VXNlcjE1MzgxNjU=","login":"vyasr","name":"Vyas Ramasubramani"},{"id":"MDQ6VXNlcjE2MDA1Njkw","login":"vuule","name":"Vukasin Milovanovic"}],"author":{"id":"MDQ6VXNlcjE2MDA1Njkw","is_bot":false,"login":"vuule","name":"Vukasin Milovanovic"},"body":"Decode of decimal files is an order of magnitude slower than decode of integral types. \r\nThe reason is the use of a single thread to find the sizes of the next batch of elements, which are then decoded using the whole block. To improve kernel performance, it needs to use multiple threads to find varint boundaries:\r\n\r\nPass 1: every thread runs `is_boundary_byte` (highest bit == 0) to find if it's at the last byte of a varint element.\r\n```\r\nA = 0 0 0 0 1 0 0 1 0 0 0 1\r\n```\r\n \r\nPass 2: Scan A to produce B. Also gets the number of elements (3 in this case).\r\n```\r\nB = 0 0 0 0 1 1 1 2 2 2 2 3\r\n    ^       ^     ^\r\n    t0      t4    t7\r\n```\r\nPass 3: Threads that are on a boundary decode the element that starts at their index and store it at col[t].\r\nt=0 writes to [0]\r\nt=4 writes to [1]\r\nt=7 writes to [2]\r\nAlternatively, step 3 can store the offsets of each element so they can be decoded in parallel.","closed":false,"closedAt":null,"comments":[{"id":"IC_kwDOBWUGps5bF7dd","author":{"login":"vuule"},"authorAssociation":"CONTRIBUTOR","body":"Additional optimization:\r\n\r\n- divide your threads into 2 chunks based on the average length of a varint.\r\n- Let's say 2 bytes / 1 varint.   2:1\r\n- Divide your block of say 768 threads into 2 chunks of 512 and 256. \r\n- Overlap generation of the next set of offsets (512 threads) with decoding the last set (256 threads).","createdAt":"2023-04-29T00:14:14Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/13251#issuecomment-1528280925","viewerDidAuthor":false},{"id":"IC_kwDOBWUGps5bNlRJ","author":{"login":"GregoryKimball"},"authorAssociation":"CONTRIBUTOR","body":"Also see https://github.com/rapidsai/cudf/issues/12677 for profiling examples","createdAt":"2023-05-01T21:13:41Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/13251#issuecomment-1530287177","viewerDidAuthor":false}],"createdAt":"2023-04-29T00:13:39Z","id":"I_kwDOBWUGps5ksEZ-","labels":[{"id":"MDU6TGFiZWw1OTk2MjY1NjE=","name":"feature request","description":"New feature or request","color":"a2eeef"},{"id":"MDU6TGFiZWwxMDEzOTg3MzUy","name":"0 - Backlog","description":"In queue waiting for assignment","color":"d4c5f9"},{"id":"MDU6TGFiZWwxMTM5NzQwNjY2","name":"libcudf","description":"Affects libcudf (C++/CUDA) code.","color":"c5def5"},{"id":"MDU6TGFiZWwxMTg1MjQ0MTQy","name":"cuIO","description":"cuIO issue","color":"fef2c0"},{"id":"MDU6TGFiZWwxMzIyMjUyNjE3","name":"Performance","description":"Performance related issue","color":"C2E0C6"}],"milestone":{"number":23,"title":"ORC continuous improvement","description":"","dueOn":null},"number":13251,"projectCards":[],"projectItems":[],"reactionGroups":[],"state":"OPEN","title":"[FEA] Improve ORC reader performance for decimal types","updatedAt":"2023-08-21T19:46:31Z","url":"https://github.com/rapidsai/cudf/issues/13251"}

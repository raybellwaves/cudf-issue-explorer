{"assignees":[],"author":{"id":"MDQ6VXNlcjIzOTYzMTY=","is_bot":false,"login":"xhkong","name":""},"body":"Please add merge_asof to cudf to match pandas merge_asof capabilities. Thanks!","closed":false,"closedAt":null,"comments":[{"id":"MDEyOklzc3VlQ29tbWVudDUxMTQyNDMwNQ==","author":{"login":"kkraus14"},"authorAssociation":"COLLABORATOR","body":"For reference: https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.merge_asof.html\r\n\r\nI can only see this working with a sort based join FYI.","createdAt":"2019-07-15T14:24:52Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/2231#issuecomment-511424305","viewerDidAuthor":false},{"id":"IC_kwDOBWUGps403rI9","author":{"login":"beckernick"},"authorAssociation":"MEMBER","body":"@vyasr might the recent conditional join / AST work perhaps be relevant for this issue? Copying the summary from the pandas docs linked above.\r\n\r\n\r\nPerform an asof merge.\r\n\r\nThis is similar to a left-join except that we match on nearest key rather than equal keys. Both DataFrames must be sorted by the key.\r\n\r\nFor each row in the left DataFrame:\r\n\r\n- A “backward” search selects the last row in the right DataFrame whose ‘on’ key is less than or equal to the left’s key.\r\n- A “forward” search selects the first row in the right DataFrame whose ‘on’ key is greater than or equal to the left’s key.\r\n- A “nearest” search selects the row in the right DataFrame whose ‘on’ key is closest in absolute distance to the left’s key.\r\n\r\nThe default is “backward” and is compatible in versions below 0.20.0. The direction parameter was added in version 0.20.0 and introduces “forward” and “nearest”.\r\n\r\nOptionally match on equivalent keys with ‘by’ before searching with ‘on’.\r\n","createdAt":"2021-07-26T20:37:24Z","includesCreatedEdit":true,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/2231#issuecomment-887009853","viewerDidAuthor":false},{"id":"IC_kwDOBWUGps403wJa","author":{"login":"jrhemstad"},"authorAssociation":"CONTRIBUTOR","body":"This could not be implemented with the AST as it requires storing state (i.e., the \"closest so far\" value). I'm not sure how you would implement this in a way that is not terrible. ","createdAt":"2021-07-26T21:12:28Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/2231#issuecomment-887030362","viewerDidAuthor":false},{"id":"IC_kwDOBWUGps4032Q6","author":{"login":"vyasr"},"authorAssociation":"CONTRIBUTOR","body":"The kernel computing conditional joins currently uses a 1D grid to parallelize only over the rows of the left table. We probably want to retain the flexibility to change the grid layout in the future if we find a more performant approach for conditional joins, but a slightly modified version of the current kernel that stores the \"closest so far\" value in a kernel-local variable should work for this use case, right? Note that the pandas API specifically requires that both DataFrames are sorted to begin with. I'm imagining something like the following (in very rough pseudocode):\r\n```\r\njoin_index = SENTINEL\r\nfinished = false\r\nfor row in right:\r\n    if not finished and condition(row):\r\n        join_index = index(row)\r\n    else:\r\n        finished = true\r\n\r\nif join_index == SENTINEL:\r\n    handle_no_join()\r\nelse:\r\n    add_pair_to_cache(left_row, join_index)\r\n```\r\nwith `condition =  ast_operator::GREATER` for `backwards` and `condition = ast_operator::LESS` for `forwards`. `nearest` would require a little extra logic using `ast_operator::GREATER` but then doing a comparison of two values the first time the condition is False.","createdAt":"2021-07-26T22:00:21Z","includesCreatedEdit":true,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/2231#issuecomment-887055418","viewerDidAuthor":false},{"id":"IC_kwDOBWUGps5Zbxw8","author":{"login":"GregoryKimball"},"authorAssociation":"CONTRIBUTOR","body":"Quick update: my interest in this issue has grown since I started researching sort-based join algorithms such as the \"[inequality_join](https://duckdb.org/2022/05/27/iejoin.html)\" in DuckDB, \"[asof join](https://pola-rs.github.io/polars-book/user-guide/transformations/joins/#asof-join)\" in polars, and \"[merge_asof](https://pandas.pydata.org/docs/reference/api/pandas.merge_asof.html)\" in pandas. ","createdAt":"2023-04-07T16:46:57Z","includesCreatedEdit":true,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/2231#issuecomment-1500453948","viewerDidAuthor":false},{"id":"IC_kwDOBWUGps5cklXH","author":{"login":"beckernick"},"authorAssociation":"MEMBER","body":"DuckDB has officially added \"AS OF\" joins as of the v8.0.0 release (pun intended).\r\n\r\n- https://duckdb.org/2023/05/17/announcing-duckdb-080.html\r\n- https://duckdb.org/docs/guides/sql_features/asof_join.html\r\n- https://github.com/duckdb/duckdb/pull/6719","createdAt":"2023-05-18T13:55:05Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[{"content":"HEART","users":{"totalCount":1}}],"url":"https://github.com/rapidsai/cudf/issues/2231#issuecomment-1553094087","viewerDidAuthor":false},{"id":"IC_kwDOBWUGps5clfnc","author":{"login":"revans2"},"authorAssociation":"CONTRIBUTOR","body":"Both Spark and DuckDB implement \"ASOF\" join using slightly different translations to operators that I think both CUDF and Dask already support. These translations allow the processing to be mostly distributed, which is really nice.\r\n\r\nSpark's translation will do a join followed by an aggregation. \r\n\r\nhttps://github.com/apache/spark/blob/d7a8b852eaa6cc04df1eea0018a9b9de29b1c4fe/sql/catalyst/src/main/scala/org/apache/spark/sql/catalyst/optimizer/RewriteAsOfJoin.scala#L27-L47\r\n\r\nIn this `MIN_BY` is essentially an `ARGMIN` aggregation followed by gather using the index returned on the first column passed to the `MIN_BY`. The problem here is that the join will likely explode. They use the tolerance from pandas to reduce the window (Spark only supports this for their pandas compatibility layer currently).\r\n\r\nI have not tried but want to. We have not been looking at it in depth because it is only for pandas compatibility right now.\r\n\r\nWhere as DuckDB appears to be doing a lead of 1 in a window operation to get a min/max value, but the default for the last value in the lead not `null` it is `infinity` so that they can get the proper range.\r\n\r\nhttps://github.com/duckdb/duckdb/blob/1d304769a4451e69f2cf4c376dad498226615c2c/src/execution/physical_plan/plan_asof_join.cpp#L48\r\n\r\nAnd then DuckDB does a conditional join bounding the left hand side key by values in that range.  It is a conditional join.\r\n\r\nhttps://github.com/duckdb/duckdb/blob/1d304769a4451e69f2cf4c376dad498226615c2c/src/execution/physical_plan/plan_asof_join.cpp#L73\r\n\r\nThe problem here is that if the asof join does not include any equality operations the window operation is likely to require all of the data to go to a single task (at least when doing this how Spark does it, not sure on DuckDB or Dask)\r\n\r\nBoth of these implementations are likely to require a cross join if are no equality operations in the join condition. I don't think that is very likely (I think the DuckDB example is bad), but I do think that there are ways that we can make it much better if we need to.","createdAt":"2023-05-18T16:47:31Z","includesCreatedEdit":true,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/2231#issuecomment-1553332700","viewerDidAuthor":false},{"id":"IC_kwDOBWUGps5x6i0r","author":{"login":"GregoryKimball"},"authorAssociation":"CONTRIBUTOR","body":"This feature is still of interest for libcudf, and we may choose a segmented sort-based join that uses binary search to locate correct matches. \r\n\r\nLooking at the pandas API for [merge_asof](https://pandas.pydata.org/pandas-docs/version/0.25.0/reference/api/pandas.merge_asof.html), there are a few key arguments that our algorithm should support:\r\n* `on`: references the numeric column that is used to find closest matches\r\n* `by`: references one or more columns that must be equal in `right` and `left` before searching the `on` values\r\n* `direction`: \"forward\", \"backward\" or \"nearest\" defines how to match the `on` values\r\n* `tolerance`: don't match if the closest `on` values are too far apart\r\n* `allow_exact_matches`: whether to match when `on` values are `==` or only find the closest non-equal\r\n\r\nPossible primitives needed:\r\nDevice-callable binary search that can work with custom functors. This will allow us to interface implementations of `backward/forward/nearest` with template dispatch to support `tolerance/nearest` for primitive types\r\n","createdAt":"2024-01-25T23:39:18Z","includesCreatedEdit":true,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/2231#issuecomment-1911172395","viewerDidAuthor":false}],"createdAt":"2019-07-12T17:04:59Z","id":"MDU6SXNzdWU0Njc1MTM1Mzg=","labels":[{"id":"MDU6TGFiZWw1OTk2MjY1NjE=","name":"feature request","description":"New feature or request","color":"a2eeef"},{"id":"MDU6TGFiZWwxMDEzOTg3MzUy","name":"0 - Backlog","description":"In queue waiting for assignment","color":"d4c5f9"},{"id":"MDU6TGFiZWwxMTM5NzQwNjY2","name":"libcudf","description":"Affects libcudf (C++/CUDA) code.","color":"c5def5"},{"id":"MDU6TGFiZWwxMTM5NzQxMjEz","name":"cuDF (Python)","description":"Affects Python cuDF API.","color":"1d76db"}],"milestone":{"number":27,"title":"Joins continuous improvement","description":"","dueOn":null},"number":2231,"projectCards":[{"project":{"name":"Feature Planning"},"column":{"name":"Needs prioritizing"}}],"projectItems":[],"reactionGroups":[],"state":"OPEN","title":"[FEA]Add merge_asof to cudf","updatedAt":"2024-01-25T23:40:31Z","url":"https://github.com/rapidsai/cudf/issues/2231"}

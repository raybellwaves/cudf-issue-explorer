{"assignees":[{"id":"MDQ6VXNlcjUzNzk2MDk5","login":"brandon-b-miller","name":""}],"author":{"id":"MDQ6VXNlcjQzODI0OTY1","is_bot":false,"login":"yidong72","name":"Yi Dong"},"body":"**Is your feature request related to a problem? Please describe.**\r\nEWM is a very popular method used in time series analysis, especially in the domain of FSI. cuIndicator is using EWM a lot to compute the technical indicators. It is good to have official support in the cuDF. \r\n\r\n**Describe the solution you'd like**\r\nDataFrame.ewm(com=None, span=None, halflife=None, alpha=None, min_periods=0, adjust=True, ignore_na=False, axis=0). The same interface as the Pandas [EWM function](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.ewm.html)\r\n\r\n**Describe alternatives you've considered**\r\ncuIndicator has the implementation that is based on rolling window methods. [cuIndicator EWM](https://yagr.nvidia.com/saefsi/cuindicator/blob/master/cuindicator/ewm.py). \r\n\r\n**Additional context**\r\nEWM can be implemented by prefix-sum method if we weight the past carefully. I have the example implementation for it.\r\n\r\n\r\n- [ ] mean\r\n- [ ] standard deviation\r\n- [ ] variance\r\n- [ ] covariance\r\n- [ ] correlation","closed":false,"closedAt":null,"comments":[{"id":"MDEyOklzc3VlQ29tbWVudDUwODM0NjU4NA==","author":{"login":"harrism"},"authorAssociation":"MEMBER","body":"@yidong72 @randerzander @beckernick What are the specific aggregations needed to implement this on top of the new rolling window functionality?","createdAt":"2019-07-04T05:44:16Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/1263#issuecomment-508346584","viewerDidAuthor":false},{"id":"MDEyOklzc3VlQ29tbWVudDY1MDg2MTk5Ng==","author":{"login":"rouniuyizu"},"authorAssociation":"NONE","body":"Hello, any plan in merging this or other implementation/s of EWM function? Or any temp fix that I could use for now? \r\nAppreciated.","createdAt":"2020-06-29T01:59:41Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/1263#issuecomment-650861996","viewerDidAuthor":false},{"id":"MDEyOklzc3VlQ29tbWVudDY1Mjc3NjY1Mg==","author":{"login":"harrism"},"authorAssociation":"MEMBER","body":"@kkraus14 @yidong72 @beckernick need help understanding what is needed from libcudf.","createdAt":"2020-07-02T04:38:20Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/1263#issuecomment-652776652","viewerDidAuthor":false},{"id":"MDEyOklzc3VlQ29tbWVudDY1Mjc3OTE4Mw==","author":{"login":"kkraus14"},"authorAssociation":"COLLABORATOR","body":"We haven't scoped this function as of yet from the cuDF Python side so we can't guide libcudf as of yet. I don't think this is currently a high priority for us.","createdAt":"2020-07-02T04:48:50Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/1263#issuecomment-652779183","viewerDidAuthor":false},{"id":"MDEyOklzc3VlQ29tbWVudDY1MzIwOTk0NQ==","author":{"login":"yidong72"},"authorAssociation":"NONE","body":"@harrism. The implementation I have is just adding a weight term to the time series items in the rolling window fun. So it should be straight forward implementation on top of rolling window fun ","createdAt":"2020-07-02T20:37:41Z","includesCreatedEdit":true,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/1263#issuecomment-653209945","viewerDidAuthor":false},{"id":"MDEyOklzc3VlQ29tbWVudDY3MjkzNjI0OA==","author":{"login":"yidong72"},"authorAssociation":"NONE","body":"We have seen some folks at FSI who are interested in the official EWM function. Check this issue we got from gQuant project. I can fix it in a hacky way but it is nice to have official support from cudf.\r\n\r\nhttps://github.com/rapidsai/gQuant/issues/100\r\n\r\nPlease increase the priority of this issue.\r\n\r\n","createdAt":"2020-08-12T15:16:05Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/1263#issuecomment-672936248","viewerDidAuthor":false},{"id":"MDEyOklzc3VlQ29tbWVudDg3OTk4NzM2NA==","author":{"login":"beckernick"},"authorAssociation":"MEMBER","body":"In pandas, EWM provides various exponential weighted functions including mean, variance, standard deviation, and more. I'm going to update the issue to include a task-list of the various functions.\r\n\r\nExponential weighted mean is the canonical usage, which makes it a good starting point for the next release.","createdAt":"2021-07-14T15:24:40Z","includesCreatedEdit":true,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/1263#issuecomment-879987364","viewerDidAuthor":false},{"id":"IC_kwDOBWUGps409NjP","author":{"login":"brandon-b-miller"},"authorAssociation":"CONTRIBUTOR","body":"I've scoped this out and there's a couple of design caveats I would like to discuss before proceeding with an implementation. \r\n\r\nTL;DR: I am not sure how to do this in a way that is actually performant. \r\n\r\nThis function in pandas behaves more like a single large window over the entire data than a rolling window function like what is normally envisioned. That is to say that by default, each element of the result is the weighted average of *all* of those that come before it in the sequence.\r\n\r\nThe formula for a single result is quite clear from the [pandas documentation:](https://pandas.pydata.org/docs/user_guide/window.html#window-exponentially-weighted)\r\n\r\n<img width=\"461\" alt=\"Screen Shot 2021-07-28 at 11 32 12 AM\" src=\"https://user-images.githubusercontent.com/53796099/127361239-d11574d7-2308-44e9-9f9a-3e8db4cf3582.png\">\r\n\r\nThere's really two straightforward ways of computing this sequence and neither of them seem to really help us very much. \r\n\r\n1. Compute all the `y`s in parallel (each processing element is responsible for a single `y`). This doesn't help us because the work is very uneven, with the worst off thread (the last one) still needing to compute coefficients for the entire sequence and then reduce the result into a weighted average. \r\n2. Generate the results sequentially, keeping track of the numerator and denominator of the equation, and recognizing that each time we advance we need only multiply the numerator by a factor of `(1 - α)`, and multiply the denominator by the same `(1 - α)` and add `1` to get the next result. This is indeed how [pandas](https://github.com/pandas-dev/pandas/blob/f72c19b5db8773708d0cd384e8f3467163cd819b/pandas/_libs/window/aggregations.pyx#L1555-L1556) makes the calculation tractable. \r\n\r\nIn the case where we really are using this within a window function, this problem goes away, as long as the window size is small relative to the data size (each thread applies the above sequential algorithm for its window). We could thus implement this on top of rolling *technically*, but we can't just wrap that functionality with `window=len(data)` otherwise the performance will be abysmal. \r\n\r\nIt seems like what is needed here is a truly parallel algorithm that properly balances the work each computing element is doing across the moving average calculation. ","createdAt":"2021-07-28T16:47:39Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/1263#issuecomment-888461519","viewerDidAuthor":false},{"id":"IC_kwDOBWUGps40-HNG","author":{"login":"harrism"},"authorAssociation":"MEMBER","body":"This can be computed efficiently in parallel using two scans (one for the numerator, one for the denominator) and a binop (divide).  ","createdAt":"2021-07-29T00:02:04Z","includesCreatedEdit":true,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/1263#issuecomment-888697670","viewerDidAuthor":false},{"id":"IC_kwDOBWUGps41A9_v","author":{"login":"brandon-b-miller"},"authorAssociation":"CONTRIBUTOR","body":"Unless I am misunderstanding that works for getting one of the datapoints we need (any single one) but not the entire sequence. Each element of the result is the result of dividing two things, but those things are the sums of sequences and those sequences are different for each element in question. Consider the first few denominators `d_i` and let `beta = (1 - alpha)`:\r\n\r\n`d_0 = 1`\r\n`d_1 = 1 + beta`\r\n`d_2 = 1 + beta + beta ** 2`\r\n\r\nIn general `d_n = sum(k = 0:n [beta ** n])` which is a finite series for which I do not think there is a closed form solution in terms of simple arithmetic operations. That said, one can see that \r\n\r\n`d_1 = beta * (1) + 1 = (beta * d_0) + 1`\r\n`d_2 = beta * (1 + beta) + 1 = (beta * d_1) + 1`\r\n\r\nMeaning each successive term is related to the last by \r\n\r\n`d_this = (beta * d_previous) + 1`\r\n\r\nWhich makes for an efficient *serial* algorithm for computing these terms without having to actually sum over an entirely new set of numbers. Unfortunately this doesn't seem to help us towards a thrust implementation because if we were trying to do an inclusive scan, we'd have this as our binary_op:\r\n\r\n```python\r\ndef f(d_previous, d_this):\r\n    return (beta * d_previous) + 1\r\nbeta = 0.1\r\nf(1, f(2,3))\r\n# 1.11\r\nf(f(1,2), 3)\r\n# 1.1\r\n```\r\n\r\nI believe this breaks the associativity needed for an inclusive scan.\r\n","createdAt":"2021-07-29T20:50:13Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/1263#issuecomment-889446383","viewerDidAuthor":false},{"id":"IC_kwDOBWUGps41BKRr","author":{"login":"cwharris"},"authorAssociation":"CONTRIBUTOR","body":"Is this the naive implementation, or is this totally wrong?\r\n```\r\nstd::vector<double> input(...);\r\nstd::vector<double> output(...);\r\ndouble alpha = 0.5;\r\nauto running_sum = 0;\r\n\r\nfor (auto i = 0; i < input.size(); i++) {\r\n  running_sum = input[i] + running_sum * (1 - alpha);\r\n  output[i] = running_sum;\r\n}\r\n```","createdAt":"2021-07-29T22:15:52Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/1263#issuecomment-889496683","viewerDidAuthor":false},{"id":"IC_kwDOBWUGps41BSxJ","author":{"login":"harrism"},"authorAssociation":"MEMBER","body":"Solving recurrence equations is in Guy Bleloch's classic paper \"Prefix Sums and their applications\". http://www.cs.cmu.edu/~blelloch/papers/Ble93.pdf (Section 1.4)\r\n\r\nThe trick is to maintain the intermediates as pairs, rather than as individual values. Let `b = 1-alpha`. For the numerator, the input is a list of pairs [(b, x_0), (b, x_1), (b, x_2), ...]. The numerator operator (in Python), is:  \r\n\r\n```\r\ndef f(pair_i, pair_j):\r\n    return (pair_i[0]*pair_j[0], pair_i[1]*pair_j[0] + pair_j[1])\r\n```\r\n\r\nTest input demonstrates associativity: \r\n```\r\n>>> beta=0.1\r\n>>> a=(beta, 1)\r\n>>> b=(beta, 2)\r\n>>> c=(beta, 3)\r\n>>> f(a, f(b, c))\r\n(0.0010000000000000002, 3.21)\r\n>>> f(f(a, b), c)\r\n(0.0010000000000000002, 3.21)\r\n```\r\n\r\nTo get the numerator out of the scan, after performing the inclusive scan, just extract all the second elements of the pairs.\r\n\r\nIntuitively, we are propagating the product of the `1-alpha`s separately from the summation.  This is a really simple recurrence, for which Blelloch gives a comprehensive proof and requirements on the operator. He also proves that higher order recurrences can be reduced and implemented with scans the same way, with the appropriate operator.\r\n\r\nThis paper is required reading, IMO. You will see scans everywhere once you start seeing them. :) \r\n\r\n(Note, implementation with Thrust is pretty simple -- just use a zip iterator with a constant iterator (1-alpha) and the input iterator and use a lambda that returns the modified pair as in the Python `f`.)","createdAt":"2021-07-29T23:52:37Z","includesCreatedEdit":true,"isMinimized":false,"minimizedReason":"","reactionGroups":[{"content":"THUMBS_UP","users":{"totalCount":3}},{"content":"HEART","users":{"totalCount":3}},{"content":"ROCKET","users":{"totalCount":2}}],"url":"https://github.com/rapidsai/cudf/issues/1263#issuecomment-889531465","viewerDidAuthor":false},{"id":"IC_kwDOBWUGps41DboR","author":{"login":"vyasr"},"authorAssociation":"CONTRIBUTOR","body":"I stumbled on this paper this morning while Googling \"Prefix sums recursion relations\" after a few of us met to discuss this problem yesterday. It's so elegant how separating the current power of the prefactor makes the recursion operator associative! Thanks for pointing us in the right direction.","createdAt":"2021-07-30T18:59:38Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/1263#issuecomment-890092049","viewerDidAuthor":false},{"id":"IC_kwDOBWUGps41HMmt","author":{"login":"brandon-b-miller"},"authorAssociation":"CONTRIBUTOR","body":"thanks @harrism this works perfectly using thrust in my experiments. It's a little hard to for me to tell if this really belongs as a rolling aggregation, should that still be the plan or is there a more appropriate place for this to live inside of libcudf?","createdAt":"2021-08-02T14:35:22Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/1263#issuecomment-891079085","viewerDidAuthor":false},{"id":"IC_kwDOBWUGps41I3n6","author":{"login":"harrism"},"authorAssociation":"MEMBER","body":"My pleasure. I don't know the answer to your question. Is it different from a rolling aggregation in some way? Does it have finite window extents, or does every element depend on all preceding elements over the entire series?  CC @jrhemstad ","createdAt":"2021-08-03T04:37:09Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/1263#issuecomment-891517434","viewerDidAuthor":false},{"id":"IC_kwDOBWUGps41J3pD","author":{"login":"brandon-b-miller"},"authorAssociation":"CONTRIBUTOR","body":"The particular pandas API is the version where every element depends on all the previous ones. \r\n\r\npandas does support a windowed version of this via different API. But I am not sure our version, were we ever to support it, would need to actually parallelize within the windows -  at least for small window sizes relative to the data the normal recurrence relation might perform fine on its own within the windows. ","createdAt":"2021-08-03T11:46:05Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/1263#issuecomment-891779651","viewerDidAuthor":false},{"id":"IC_kwDOBWUGps41Ooov","author":{"login":"harrism"},"authorAssociation":"MEMBER","body":"For the one where every element depends on all previous ones, it may be best to add this as an operator to our existing scan API.\r\n\r\nThe windowed version sounds like rolling. Or could be done as an operator to the segmented scan API.","createdAt":"2021-08-04T23:00:53Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/1263#issuecomment-893028911","viewerDidAuthor":false},{"id":"IC_kwDOBWUGps5WjrjG","author":{"login":"Haidow"},"authorAssociation":"NONE","body":"Dose it i supported in 23.02? ","createdAt":"2023-03-02T16:51:40Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/1263#issuecomment-1452193990","viewerDidAuthor":false},{"id":"IC_kwDOBWUGps5WzASl","author":{"login":"brandon-b-miller"},"authorAssociation":"CONTRIBUTOR","body":"Hi @Haidow ,\r\nWe've been focusing on some other priorities for a while since we last looked at this, but there's been some more interest recently, so I'll start a conversation about finishing this up in the next few releases.","createdAt":"2023-03-06T14:13:02Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/1263#issuecomment-1456211109","viewerDidAuthor":false},{"id":"IC_kwDOBWUGps5hjjIr","author":{"login":"felixmccuaig"},"authorAssociation":"NONE","body":"@brandon-b-miller Yes plz!","createdAt":"2023-07-15T08:26:30Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/1263#issuecomment-1636708907","viewerDidAuthor":false},{"id":"IC_kwDOBWUGps5ss8hL","author":{"login":"cpowr"},"authorAssociation":"NONE","body":"Thanks @brandon-b-miller, any update on this? ","createdAt":"2023-11-23T01:28:09Z","includesCreatedEdit":false,"isMinimized":false,"minimizedReason":"","reactionGroups":[],"url":"https://github.com/rapidsai/cudf/issues/1263#issuecomment-1823721547","viewerDidAuthor":false}],"createdAt":"2019-03-22T19:05:54Z","id":"MDU6SXNzdWU0MjQzNTkxNzY=","labels":[{"id":"MDU6TGFiZWw1OTk2MjY1NjE=","name":"feature request","description":"New feature or request","color":"a2eeef"},{"id":"MDU6TGFiZWwxMTM5NzQwNjY2","name":"libcudf","description":"Affects libcudf (C++/CUDA) code.","color":"c5def5"},{"id":"MDU6TGFiZWwxMTM5NzQxMjEz","name":"cuDF (Python)","description":"Affects Python cuDF API.","color":"1d76db"}],"milestone":{"number":1,"title":"Time Series Analysis","description":"","dueOn":null},"number":1263,"projectCards":[{"project":{"name":"Feature Planning"},"column":{"name":"Needs prioritizing"}}],"projectItems":[],"reactionGroups":[{"content":"THUMBS_UP","users":{"totalCount":1}}],"state":"OPEN","title":"[FEA] need official EWM function","updatedAt":"2023-11-23T01:28:09Z","url":"https://github.com/rapidsai/cudf/issues/1263"}
